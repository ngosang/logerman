2 / 110 | libreoffice-4.4.0.3/formula/source/core/api/token.cxx
//! Reihenfolge ist wichtig
// als Ergebnis jeder Funktion wird einfach ein Double angenommen


1 / 9 | libreoffice-4.4.0.3/formula/source/ui/dlg/parawin.cxx
//  Unique-IDs muessen gleich bleiben fuer Automatisierung


2 / 71 | libreoffice-4.4.0.3/formula/source/ui/dlg/formula.cxx
//  Test, ob vorne/hinten noch mehr Funktionen sind
//! oder 0 (zuletzt benutzte)


1 / 7 | libreoffice-4.4.0.3/formula/source/ui/dlg/parawin.hxx
//Sichtbare Editzeilen


5 / 8 | libreoffice-4.4.0.3/svx/inc/sxmtaitm.hxx
// Den Text automatisch zurechtdrehen (Automatisches UpsideDown).
// TextUpsideDown bleibt trotzdem weiterhin wirksam und dreht
// den Text bei sal_True nochmal.
// Der bevorzugte Blickwinkel zum lesen des Textes. Wird nur ausgewertet, wenn
// TextAutoAngle=TRUE. Winkel in 1/100deg aus der Zeichnung zum Betrachter.


1 / 217 | libreoffice-4.4.0.3/svx/source/svdraw/svdoedge.cxx
// Vertex


1 / 180 | libreoffice-4.4.0.3/svx/source/svdraw/svdoole2.cxx
/*
        if (pModel && pModel->GetRefDevice() &&
            pModel->GetRefDevice()->GetOutDevType() == OUTDEV_PRINTER)
        {
            // Kein RefDevice oder RefDevice kein Printer
            bool bModified = (*ppObjRef)->IsModified();
            Printer* pPrinter = (Printer*) pModel->GetRefDevice();
            (*ppObjRef)->OnDocumentPrinterChanged( pPrinter );
            (*ppObjRef)->SetModified( bModified );
        }*/


2 / 87 | libreoffice-4.4.0.3/svx/source/svdraw/svdtrans.cxx
// Negieren, denn '+' ist Rechtskursivierung
// Metrisch


1 / 144 | libreoffice-4.4.0.3/svx/source/svdraw/svdpage.cxx
// Ruft u.a. den UserCall


34 / 117 | libreoffice-4.4.0.3/svx/source/inc/fmshimp.hxx
// Timer um verzoegerte Markierung vorzunehmen
// da ich beim Suchen fuer die Behandlung des "gefunden" ein SdrObject markieren will, besorge ich mir vor dem
// Hochreissen des Suchen-Dialoges alle relevanten Objekte
// (das Array ist damit auch nur waehrend des Suchvorganges gueltig)
// nur im alive mode verfuegbar
// Aktueller container einer Page
// nur im designmode verfuegbar
// und das ist ebenfalls fuer's 'gefunden' : Beim Finden in GridControls brauche ich die Spalte, bekomme aber
// nur die Nummer des Feldes, die entspricht der Nummer der Spalte + <offset>, wobei der Offset von der Position
// des GridControls im Formular abhaengt. Also hier eine Umrechnung.
// soll ich (bzw. der Owner diese Impl-Klasse) mich um die Aktualisierung des ::com::sun::star::beans::Property-Browsers kuemmern ?
// Gibt es eine Datenbankleiste
// Wird ein Controller aktiviert
// Darf der Focus umgesetzt werden
// Wird gerade ein Filter auf die Controls angesetzt
// UNO Anbindung
// sammelt in strNames die Namen aller Formulare
// methode fuer nicht designmode (alive mode)
// ein Menue, das alle ControlConversion-Eintraege enthaelt
// das Setzen des curObject/selObject/curForm erfolgt verzoegert (SetSelectionDelayed), mit den folgenden
// Funktionen laesst sich das abfragen/erzwingen
// Invalidierung von Slots
// Locking der Invalidierung - wenn der interne Locking-Counter auf 0 geht, werden alle aufgelaufenen Slots
// (asynchron) invalidiert
// = ein Iterator, der ausgehend von einem Interface ein Objekt sucht, dessen
// = ::com::sun::star::beans::Property-Set eine ControlSource- sowie eine BoundField-Eigenschaft hat,
// = wobei letztere einen Wert ungleich NULL haben muss.
// = Wenn das Interface selber diese Bedingung nicht erfuellt, wird getestet,
// = ob es ein Container ist (also ueber eine ::com::sun::star::container::XIndexAccess verfuegt), dann
// = wird dort abgestiegen und fuer jedes Element des Containers das selbe
// = versucht (wiederum eventuell mit Abstieg).
// = Wenn irgendein Objekt dabei die geforderte Eigenschaft hat, entfaellt
// = der Teil mit dem Container-Test fuer dieses Objekt.
// der aktuelle Wert der ControlSource-::com::sun::star::beans::Property


1 / 11 | libreoffice-4.4.0.3/svx/source/inc/filtnav.hxx
// die Position, an der der DropTimer angeschaltet wurde


2 / 79 | libreoffice-4.4.0.3/svx/source/inc/formcontroller.hxx
// Focuslistener nur fuer Datenbankformulare
// ist der Inhalt eines Controls modifiziert ?


2 / 17 | libreoffice-4.4.0.3/svx/source/inc/fmobj.hxx
// Informationen fuer die Controlumgebung
// werden nur vorgehalten, wenn ein Object sich nicht in einer Objectliste befindet


6 / 21 | libreoffice-4.4.0.3/svx/source/inc/fmexch.hxx
// baut aus m_aSelectedEntries m_aControlPaths auf
// (es wird davon ausgegangen, dass die Eintraege in m_aSelectedEntries sortiert sind in Bezug auf die Nachbar-Beziehung)
// der umgekehrte Weg : wirft alles aus m_aSelectedEntries weg und baut es mittels m_aControlPaths neu auf
// fuegt ein SVX_FML_HIDDEN_CONTROLS-Format hinzu und merk sich dafuer die uebergebenen Interfaces
// (es erfolgt KEINE Ueberpruefung, ob dadurch auch tatsaechlich nur hidden Controls bezeichnet werden, dass muss der
// Aufrufer sicherstellen)


3 / 23 | libreoffice-4.4.0.3/svx/source/inc/fmundo.hxx
// UNO Anbindung
// Methoden zur Zuordnung von Controls zu Forms,
// werden von der Seite und der UndoUmgebung genutzt


20 / 110 | libreoffice-4.4.0.3/svx/source/inc/gridcell.hxx
// DbGridColumn, Spaltenbeschreibung
// Verbindung zum Datenbankfeld
// Struktur zum Verwalten der Controls fuer eine Spalte
// diese wird von der DbBrowseBox auf die jeweiligen Zellen
// einer Spalte positioniert
// nur gueltig, wenn m_bHidden == sal_True
// wird mit TXT_ALIGN_LEFT .... angegeben
// Verweist die Column auf ein Object Datentyp?
//      Zeichnen eines Feldes an einer Position, ist ein View gesetzt
//      uebernimmt dieser das Zeichnen, z.B. fuer CheckBoxen
//      Inititialierung im alive mode
//      Ist kein ColumnController gesetzt, wird eine DefaultInitialisierung
//      Editieren einer Zelle
//      freigeben aller Daten, die fuer den AliveMode noetig sind
// Properties, die auf den ::com::sun::star::frame::Controller durchschlagen koennen
// DbCellControl, liefert die Daten fuer einen CellController
// wird in der Regel nur f\FCr komplexe Controls wie z.B ComboBoxen
// Initialisieren bevor ein Control angezeigt wird
// Schreiben des Wertes in das Model
// Painten eines Zellinhalts im vorgegeben Rechteck


26 / 43 | libreoffice-4.4.0.3/svx/source/inc/fmexpl.hxx
// die Daten des Eintrages, der ein neues Model bekommen hat
// FmNavRequestSelectHint - jemand teilt dem NavigatorTree mit, dass er bestimmte Eintraege selektieren soll
// einen RequestSelectHint mit den aktuell markierten Objekten broadcasten
// ist ein Helper fuer vorherige, managet das Abteigen in SdrObjGroups
// Rueckgabe sal_True, wenn das Objekt eine FormComponent ist (oder rekursiv nur aus solchen besteht)
// beim Droppen will ich scrollen und Folder aufklappen koennen, dafuer :
// die Meta-Daten ueber meine aktuelle Selektion
// die Images, die ich brauche (und an FormDatas und EntryDatas weiterreiche)
// die Position, an der der DropTimer angeschaltet wurde
// (die Zahl geht in m_nControlsSelected mit ein)
// wenn das sal_True ist, brauche ich auf die RequestSelectHints nicht reagieren
// bin ich das erste Mal im UpdateContent ?
// sammelt in m_arrCurrentSelection die aktuell selektierten Eintraege, normalisiert die Liste wenn verlangt
// SDI_NORMALIZED bedeutet einfach, dass alle Eintraege, die schon einen selektierten Vorfahren haben, nicht mit gesammelt
// SDI_NORMALIZED_FORMARK bedeutet, dass wie bei SDI_NORMALIZED verfahren wird, aber Eintraege, deren direktes Elter nicht
// selektiert ist, aufgenommen werden (unabhaengig vom Status weiterer Vorfahren), desgleichen Formulare, die selektiert sind,
// unabhaengig vom Status irgendwelcher Vorfahren
// Bei beiden Normalized-Modi enthalten die m_nFormsSelected, ... die richtige Anzahl, auch wenn nicht alle dieser Eintraege
// SDI_DIRTY ist natuerlich nicht erlaubt als Parameter
// ein einziges Interface fuer alle selektierten Eintraege zusammensetzen
// alle selektierten Elemnte loeschen
// nach dem Aufruf dieser Methode sind genau die Eintraege selektiert, die in dem Array bezeichnet sind
// macht das selbe, nimmt die MarkList der View
// umgekehrte Richtung von SynchronizeMarkList : markiert in der View alle der aktuellen Selektion entsprechenden Controls
// im Select aktualisiere ich normalerweise die Marklist der zugehoerigen View, mit folgenden Funktionen
// kann ich das Locking dieses Verhaltens steuern


3 / 16 | libreoffice-4.4.0.3/svx/source/inc/fmpgeimp.hxx
// lauscht an allen Containern, um festzustellen, wann Objecte
// eingefuegt worden sind und wann diese entfernt wurden
//  nur wichtig fuer den DesignMode


2 / 29 | libreoffice-4.4.0.3/svx/source/inc/fmvwimp.hxx
// Liste der markierten Object, dient zur Restauration beim Umschalten von Alive in DesignMode
// UNO Anbindung


5 / 40 | libreoffice-4.4.0.3/svx/source/toolbars/extrusionbar.cxx
// Standardinterface deklarieren (Die Slotmap darf nicht leer sein, also
// tragen wir etwas ein, was hier (hoffentlich) nie vorkommt).
// wireframe
// force SelectionHasChanged() being called
// wire frame


2 / 14 | libreoffice-4.4.0.3/svx/source/toolbars/fontworkbar.cxx
// Standardinterface deklarieren (Die Slotmap darf nicht leer sein, also
// tragen wir etwas ein, was hier (hoffentlich) nie vorkommt).


3 / 23 | libreoffice-4.4.0.3/svx/source/form/tabwin.cxx
// ListBox loeschen
// an dem PropertySet nach Aenderungen der ControlSource lauschen
// Titel setzen


1 / 9 | libreoffice-4.4.0.3/svx/source/form/tbxform.cxx
// Click auf den Button SID_FM_CONFIG in der ObjectBar


1 / 83 | libreoffice-4.4.0.3/svx/source/form/datanavi.cxx
// #i59395# / 2005-12-15 / frank.schoenheit@sun.com


10 / 45 | libreoffice-4.4.0.3/svx/source/form/fmpgeimp.cxx
// suche die Standardform
// Wenn Datenbank und CursorSource gesetzt sind, dann wird
// die Form anhand dieser Kriterien gesucht, ansonsten nur aktuelle
// und die StandardForm
// erst in der aktuellen form suchen
// wenn keine ::com::sun::star::form gefunden, dann eine neue erzeugen
// jetzt noch ueberpruefen ob CursorSource und Type uebereinstimmen
// Ist noch keine Datenquelle gesetzt, wird dieses hier nachgeholt
// setzen eines default Namens ueber die ClassId
// bei Radiobuttons, die einen Namen haben, diesen nicht ueberschreiben!


40 / 62 | libreoffice-4.4.0.3/svx/source/form/navigatortreemodel.cxx
// keine Undoaction einfuegen
// EntryData loeschen
// an einer FmControlData sollte eine XFormComponent haengen
// EntryData loeschen
// RootList loeschen
// UI benachrichtigen
// das Element muss den Typ haben, den der Container erwartet
// Daten aus Model entfernen
// UI benachrichtigen
// Form und Parent holen
// jetzt die eigentliche Entfernung der Daten aus dem Model
// aus dem Container entfernen
// beim Vater austragen
// Wenn keine Form mehr in der Root, an der Shell CurForm zuruecksetzen
// UI benachrichtigen
// Eintrag loeschen
// Form und Parent holen
// Child ist Form -> rekursiver Aufruf
// Control und Parent holen
// Alle Eintraege dieses Zweiges loeschen
// Forms aus der Root einfuegen
// Neuer Branch, wenn SubForm wiederum Subforms enthaelt
// Componenten einfuegen
// die aktuelle Component ist eine Form
// Neuer Branch, wenn SubForm wiederum Subforms enthaelt
// Neue EntryData setzen
// Neue EntryData einfuegen
// hat sich die shell verabschiedet?
// hat sich die Markierung der Controls veraendert ?
// rekursiv absteigen
// gehen wir durch alle markierten Objekte und suchen wir die raus, mit denen ich was anfangen kann
// bei einem Nicht-Form-Control liefert InsertFormComponent sal_False !
// eine leere Liste interpretiert der NavigatorTree so, dass er seine Selektion komplett rausnimmt
// Model von der Root aufwaerts neu fuellen
// jetzt in meinem Tree genau die das in meiner View markierte Control selektieren
// (bzw alle solchen), falls es eines gibt ...
// keine Shell -> wech
// Wenn Shell sich nicht veraendert hat, nichts machen
// Von der Form Components holen
// Wenn Name schon vorhanden, Fehlermeldung


11 / 43 | libreoffice-4.4.0.3/svx/source/form/fmview.cxx
// Model setzen
// DesignMode vom Model holen
// dieses wird in der Shell vorgenommen
// bDesignMode = !bInitDesignMode;  // erzwingt, dass SetDesignMode ausgefuehrt wird
// #i39269# / 2004-12-20 / frank.schoenheit@sun.com
// fuer die Zeit des Uebergangs das Undo-Environment ausschalten, das sichert, dass man dort auch nicht-transiente
// Properties mal eben aendern kann (sollte allerdings mit Vorsicht genossen und beim Rueckschalten des Modes
// auch immer wieder rueckgaegig gemacht werden. Ein Beispiel ist das Setzen der maximalen Text-Laenge durch das
// FmXEditModel an seinem Control.)
// und mein Undo-Environment wieder an
// damit der Formular-Navigator auf den Seitenwechsel reagieren kann


38 / 319 | libreoffice-4.4.0.3/svx/source/form/formcontroller.cxx
// Freigeben der Aggregation
// ist ein Control disposed worden
// Suchen der aktuellen Row
// 85511 - 29.05.2001 - frank.schoenheit@germany.sun.com
// #i88458# / 2009-01-12 / frank.schoenheit@sun.com
// normalerweise sollte ein gelocktes Control nicht modified sein, also muss wohl mein bModified aus einem anderen Kontext
// gesetzt worden sein, was ich nicht verstehen wuerde ...
// zunaechst das Control fragen ob es das IFace unterstuetzt
// Commit nicht erfolgreich, Focus zuruecksetzen
// Immer noch ein und dasselbe Control
// Control erhaelt Focus, dann eventuell in den sichtbaren Bereich
// anmelden beim Eventattacher
// Und die Position des ControlModel darin suchen
// abmelden beim Eventattacher
// Und die Position des ControlModel darin suchen
// einsammeln der Controls
// Datenbank spezifische Dinge vornehmen
// Welche Controls gehoeren zum Container ?
// einsammeln der Controls
// am Container horchen
// Datenbank spezifische Dinge vornehmen
// befinden sich die Controls in der richtigen Reihenfolge
// Umsortieren der Controls entsprechend der TabReihenfolge
// es wird gelockt
// a.) wenn der ganze Datensatz gesperrt ist
// b.) wenn das zugehoerige Feld gespeert ist
// beim entlocken immer einzelne Felder ueberprÃ¼fen
// gibt es eine Datenquelle
// wie sieht mit den Properties ReadOnly und Enable aus
// alle Controls, die mit einer Datenquelle verbunden sind locken/unlocken
// alle die Text um vorzeitig ein modified zu erkennen
// alle die Text um vorzeitig ein modified zu erkennen
// jetzt anmelden bei gebundenen feldern
// jetzt anmelden bei gebundenen feldern
// TabOrder nicht neu berechnen, da das intern schon funktionieren muss!
// Austauschen der Kontrols fuer das aktuelle Formular
// abmelden vom EventManager
// Austauschen der Kontrols fuer das aktuelle Formular


3 / 16 | libreoffice-4.4.0.3/svx/source/form/fmexch.cxx
// erst mal sammeln wir den Pfad in einem Array ein
// pLoop == NULL heisst, dass ich am oberen Ende angelangt bin, dann sollte das Ganze abbrechen, was nur bei pRoot == NULL der Fall sein wird
// dann koennen wir ihn in die ::com::sun::star::uno::Sequence uebertragen


1 / 28 | libreoffice-4.4.0.3/svx/source/form/fmcontrolbordermanager.cxx
// #i37434# / 2004-11-19 / frank.schoenheit@sun.com


3 / 14 | libreoffice-4.4.0.3/svx/source/form/fmexpl.cxx
// Titel setzen
// Titel setzen
// Images neu setzen


1 / 20 | libreoffice-4.4.0.3/svx/source/form/fmtools.cxx
// Feststellen an welcher Position sich das Kind befindet


2 / 12 | libreoffice-4.4.0.3/svx/source/form/fmpage.cxx
// testen, ob es ein Protokoll-Typ ist, den ich anzeigen will
// Hilfe anzeigen


71 / 366 | libreoffice-4.4.0.3/svx/source/form/fmshimp.cxx
// wird fuer Invalidate verwendet -> mitpflegen
// wird fuer Invalidate verwendet -> mitpflegen
// aufsteigend sortieren !!!!!!
// vom SelObject abhaengige Slots
// die folgenden Arrays muessen kosistent sein, also einander entsprechende Eintraege an der selben relativen Position
// innerhalb ihres jeweiligen Arrays stehen
// enthaelt die liste nur Controls und mindestens ein control
// wird der Controller freigeben dann alles loslassen
// Das gleich folgenden Update erzwingt ein Neu-Painten der entsprechenden Slots. Wenn ich mich aber hier nicht
// in dem HauptThread der Applikation befinde (weil zum Beispiel ein Cursor gerade Datensaetze zaehlt und mir dabei
// immer diese PropertyChanges beschert), kann sich das mit en normalen Paints im HauptThread der Applikation beissen.
// (Solche Paints passieren zum Beispiel, wenn man einfach nur eine andere Applikation ueber das Office legt und wieder
// zurueckschaltet).
// Deshalb die Benutzung des SolarMutex, der sichert das ab.
// alles, was sich waehrend der gelockten Phase angesammelt hat, (asynchron) invalidieren
// die Invalidierung der Slots, die implizit von SetSelection besorgt wird, eventuell abschalten
// das entsprechende Image dran
// Properties uebertragen
// neues Model setzen
// das Control zum Model suchen
// der Context ist schon von einem Typ, der dem Eitnrag entspricht -> disable
// eine Sammlung aller (logischen) Formulare
// es gibt keine Controls, die alle Bedingungen fuer eine Suche erfuellen
// jetzt brauche ich noch einen 'initial context'
// wenn der Dialog initial den Text des aktiven Controls anbieten soll, muss dieses ein XTextComponent-Interface habe,
// ausserdem macht das nur Sinn, wenn das aktuelle Feld auch an ein Tabellen- (oder was-auch-immer-)Feld gebunden ist
// ... das bekomme ich von meinem FormController
// das Control kann mir sein Model sagen ...
// das Model frage ich nach der ControlSource-Eigenschaft ...
// (nur wenn das Ding wirklich gebunden ist)
// und das Control selber nach einem TextComponent-Interface (damit ich mir dort den Text abholen kann)
// das Control selber hat keine ControlSource, aber vielleicht ist es ein GridControl
// fuer strActiveField brauche ich die ControlSource der Column, dafuer den Columns-Container, dafuer die
// um eventuelle GridControls, die ich kenne, kuemmern
// jetzt bin ich reif fuer den Dialog
// wenn die potentiellen Deadlocks, die durch die Benutzung des Solar-Mutex in MTs VCLX...-Klasen entstehen, irgendwann mal
// ausgeraeumt sind, sollte hier ein SM_USETHREAD rein, denn die Suche in einem eigenen Thread ist doch etwas fluessiger
// sollte allerdings irgendwie von dem unterliegenden Cursor abhaengig gemacht werden, DAO zum Beispiel ist nicht thread-sicher
// GridControls wieder restaurieren
// da ich in OnFoundData (fals ich dort war) Controls markiert habe
// im Design-Modus (ohne aktive Controls) soll sich das Haupt-Dokument darum kuemmern
// kein aktuelles Formular (also insbesondere kein aktuelles Control) -> das Haupt-Dokument soll sich kuemmern
// kein aktives Formular gefunden -> alle aktuell vorhandenen Formulare durchiterieren
// im alive-Modus sind meine Forms nicht gesetzt, wohl aber die an der Page
// ist das aktuelle Element eine DatabaseForm ?
// Ist die Routine ein zweites Mal gerufen worden,
// dann sollte der Focus nicht mehr umgesetzt werden
// beim Wechsel des Controllers den Inhalt speichern, ein Commit
// wurde bereits ausgefuehrt
// #i88186# / 2008-04-12 / frank.schoenheit@sun.com
// wenn es eine Datenquelle gibt, dann den Listener aufbauen
// suchen des Controllers, ueber den eine Navigation moeglich ist
// an dem Controller, der die Navigation regelt, wg. RecordCount lauschen
// was soll ich da machen ?
// zum Datensatz
// und zum Feld (dazu habe ich vor dem Start des Suchens die XVclComponent-Interfaces eingesammelt)
// wenn das Feld sich in einem GridControl befindet, muss ich dort noch in die entsprechende Spalte gehen
// dummer weise muss ich mir das Control erst wieder besorgen
// wenn eine der Asserts anschlaegt, habe ich beim Aufbauen von m_arrSearchedControls wohl was falsch gemacht
// als der Cursor neu positioniert wurde, habe ich (in positioned) meine Formularleisten-Slots invalidiert, aber das greift
// hier dummerweise nicht, da i.A. ja der (modale) Suchdialog oben ist ... also Gewalt ...
// leider geht das Update im Gegensatz zum Invalidate nur mit einzelnen Slots)
// was soll ich da machen ?
// zum Datensatz
// am Container horchen
// und absteigen
// #i88186# / 2008-04-12 / frank.schoenheit@sun.com
// wenn das Ding eine ControlSource und einen BoundField-Property hat
// und das BoundField gueltig ist
// nehmen wir's
// wenn es ein Grid-Control ist


184 / 323 | libreoffice-4.4.0.3/svx/source/form/navigatortree.cxx
// solange dauert es, bis das Scrollen anspringt
// in diesen Intervallen wird jeweils eine Zeile gescrollt
// das ist die Basis, mit der beide Angaben multipliziert werden (in ms)
// dieser Betrag an Millisekunden wird gewartet, ehe der Explorer nach einem Select oder Deselect die View synchronisiert
// neue Shell, waehrend ich gerade editiere ?
// sicherheitshalber, auch wenn ich gar nicht dragge
// wenn es eine Form gibt, die Root expandieren
// wenn es GENAU eine Form gibt, auch diese expandieren
// die Informationen fuer das AcceptDrop und ExecuteDrop
// testen, ob es sich vielleicht ausschliesslich um hidden controls handelt (dann koennte ich pCtrlExch noch ein
// zusaetzliches Format geben)
// eine entsprechende Sequenz aufbauen
// und das neue Format
// jetzt haben wir alle in der aktuelle Situation moeglichen Formate eingesammelt, es kann also losgehen ...
// die Stelle, an der geklickt wurde
// kann nur bei Kontextmenue ueber Tastatur passieren
// meine Selektionsdaten auf den aktuellen Stand
// wenn mindestens ein Nicht-Root-Eintrag selektiert ist und die Root auch, dann nehme ich letztere aus der Selektion
// fix wieder raus
// solte nicht passieren, da ich oben bei der IsSelected-Abfrage auf jeden Fall einen selektiert haette,
// wenn das vorher nicht der Fall gewesen waere
// das Menue zusammenbasteln
// das 'Neu'-Untermenue gibt es nur, wenn genau die Root oder genau ein Formular selektiert sind
// 'Neu'\'Formular' unter genau den selben Bedingungen
// 'Neu'\'verstecktes...', wenn genau ein Formular selektiert ist
// der TabDialog, wenn es genau ein Formular ist ...
// Umbenennen gdw wenn ein Element und nicht die Root
// der Reandonly-Eintrag ist nur auf der Root erlaubt
// die ConvertTo-Slots sind enabled, wenn genau ein Control selektiert ist, der
// dem Control entsprechende Slot ist disabled
// jetzt alles, was disabled wurde, wech
// der Slot war nur verfuegbar, wenn es genau einen selektierten Eintrag gibt und dieser die Root
// oder ein Formular ist
// dieser Slot war guletig bei (genau) einem selektierten Formular
// dieser Slot galt bei genau einem selektierten Formular
// das war bei genau einem Nicht-Root-Eintrag erlaubt
// das Image neu setzen
// Default-Eintrag "Formulare"
// wenn m_bMarkingObjects sal_True ist, markiere ich gerade selber Objekte, und da der ganze Mechanismus dahinter synchron ist,
// ist das genau der Hint, der durch mein Markieren ausgeloest wird, also kann ich ihn ignorieren
// in diesem Fall habe ich alles deselektiert, obwohl die View u.U. eine gemischte Markierung hatte
// ich muss also im naechsten Select den Navigator an die View anpassen
// Aktuellen Eintrag einfuegen
// Wenn Root-Eintrag Root expandieren
// Children einfuegen
// der Entry zu den Daten
// Eintrag aus TreeListBox entfernen
// ich darf das Select, das ich ausloese, nicht behandeln :
// Select aendert die MarkList der View, wenn das gerade auch jemand anders macht und dabei ein Remove
// triggert, haben wir mit ziemlicher Sicherheit ein Problem - Paradebeispiel war das Gruppieren von Controls mit
// ein kleines Problem : ich merke mir meine selektierten Daten, wenn mir jetzt jemand einen selektierten Eintrag
// unter dem Hintern wegschiesst, werde ich inkonsistent ... was schlecht waere
// beim eigentlichen Entfernen kann die Selection geaendert werden, da ich aber das SelectionHandling abgeschaltet
// habe, muss ich mich hinterher darum kuemmern
// und standardmaessig behandle ich das Select natuerlich
// ich befinde mich zwar in der Shell/Page, aus der die Controls stammen, habe aber kein Format, das den stattgefundenen
// Shell-Wechsel ueberlebt hat (SVX_FM_CONTROLS_AS_PATH)
// da die Shell waehrend des Draggens umgeschaltet wude, muss ich die Liste des ExchangeObjektes wieder neu aufbauen
// (dort stehen SvLBoxEntries drin, und die sind bei der Umschaltung floeten gegangen)
// die Liste der gedroppten Eintraege aus dem DragServer
// TODO : die obige Zeile wieder rein, dann muss aber ExecuteDrop das Vertauschen auch beherrschen
// kuemmern wir uns erst mal um moeglich DropActions (Scrollen und Aufklappen)
// auf dem ersten Eintrag ?
// auf dem letzten (bzw. in dem Bereich, den ein Eintrag einnehmen wuerde, wenn er unten genau buendig
// abschliessen wuerde) ?
// auf einem Entry mit Children, der nicht aufgeklappt ist ?
// -> aufklappen
// neu anfangen zu zaehlen
// die Pos merken, da ich auch AcceptDrops bekomme, wenn sich die Maus gar nicht bewegt hat
// und den Timer los
// gibt es den Timer schon ?
// ware schlecht, wenn nach dem Droppen noch gescrollt wird ...
// das sollte in AcceptDrop erledigt worden sein : dort wird in _rData die Liste der Controls aufgebaut und m_bDragDataDirty
// zurueckgesetzt
// das sollte das AcceptDrop abgefangen haben
// da ich gleich die Zielobjekte alle selektieren will (und nur die)
// innerhalb eines Undo ...
// die Conrtols kopieren
// neues Control anlegen
// und die Properties des alten in das neue kopieren
// nur mal eben sehen, ob das Ding tatsaechlich ein hidden control ist
// wenn das SVX_FM_HIDDEN_CONTROLS-Format vorhanden ist, dann sollten wirklich nur hidden controls in der Sequenz
// (read-only attribs werden natuerlich nicht gesetzt, dito der Name, den hat das NewControl schon eindeutig
// die Liste der gedraggten Eintraege
// die Shell und das Model
// ich nehme vor dem Einfuegen eines Eintrages seine Selection raus, damit die Markierung dabei nicht flackert
// -> das Handeln des Select locken
// jetzt durch alle gedroppten Eintraege ...
// ein paar Daten zum aktuellen Element
// die Root darf nicht gedraggt werden
// beim Vater austragen
// aus dem Container entfernen
// die Undo-Action fuer das Rausnehmen
// Events mitkopieren
// die Selection raus
// und weg
// die Stelle innerhalb des DropParents, an der ich die gedroppten Eintraege einfuegen muss
// immer ganz hinten einfuegen
// UndoAction fuer das Einfuegen
// einfuegen im neuen Container
// es wird in eine Form eingefuegt, dann brauche ich eine FormComponent
// zuerst dem Eintrag das neue Parent
// dann dem Parent das neue Child
// dann bei mir selber bekanntgeben und neu selektieren
// die Wurzel, die ich nicht umbenennen darf, hat als UserData NULL
// Neue Form erzeugen
// Form einfuegen
// Neue Form als aktive Form setzen
// In EditMode schalten
// Neue Component erzeugen
// FormComponent einfuegen
// In EditMode schalten
// BasisNamen erzeugen
// Neuen Namen erstellen
// tja, eigentlich muesste ich noch testen, ob die Node nicht schon expandiert ist, aber ich
// habe dazu weder in den Basisklassen noch im Model eine Methode gefunden ...
// aber ich denke, die BK sollte es auch so vertragen
// nach dem Expand habe ich im Gegensatz zum Scrollen natuerlich nix mehr zu tun
// zuerst brauche ich die FormShell
// keine Shell -> ich koennte kein curObject setzen -> raus
// es ist genau eine Form selektiert
// es ist genau ein Control selektiert (egal ob hidden oder normal)
// wir haben eine MultiSelection, also muessen wir ein MultiSet dafuer aufbauen
// erstmal die PropertySet-Interfaces der Forms einsammeln
// ein MultiSet fuer die Properties der hidden controls
// und dann meine Form und mein SelObject
// und jetzt kann ich das Ganze dem PropertyBrowser uebergeben
// die Root darf ich natuerlich nicht mitloeschen
// die Root plus andere Elemente ?
// ja -> die Root raus
// immer noch die Root ?
// -> sie ist das einzige selektierte -> raus
// ich brauche unten das FormModel ...
// jetzt muss ich noch die DeleteList etwas absichern : wenn man ein Formular und ein abhaengiges
// Element loescht - und zwar in dieser Reihenfolge - dann ist der SvLBoxEntryPtr des abhaengigen Elementes
// natuerlich schon ungueltig, wenn es geloescht werden soll ... diesen GPF, den es dann mit Sicherheit gibt,
// gilt es zu verhindern, also die 'normalisierte' Liste
// eine Form ?
// da ich das Loeschen im folgenden der View ueberlasse und dabei auf deren MarkList aufbaue, im Normalfall aber bei
// einem makierten Formular nur die direkt, nicht die indirekt abhaengigen Controls markiert werden, muss ich das hier
// noch nachholen
// das zweite sal_True heisst "deep"
// ein hidden control ?
// Forms und hidden Controls muss ich behalten, alles andere nicht
// noch ein kleines Problem, bevor ich das ganz loesche : wenn es eine Form ist und die Shell diese als CurrentObject
// kennt, dann muss ich ihr das natuerlich ausreden
// die Shell kennt die zu loeschende Form ?
// -> wegnehmen ...
// erst mal die Zaehlung der verschiedenen Elemente
// alles, was schon einen selektierten Vorfahr hat, nicht mitnehmen
// eigentlich muesste ich testen, ob das Parent in der m_arrCurrentSelection steht ...
// Aber wenn es selektiert ist, dann steht es in m_arrCurrentSelection, oder wenigstens einer seiner Vorfahren,
// wenn der auch schon selektiert war. In beiden Faellen reicht also die Abfrage IsSelected
// bis (exclusive) zur Root gab es kein selektiertes Parent -> der Eintrag gehoert in die normalisierte Liste
// erst mal gleiche ich meine aktuelle Selektion mit der geforderten SelectList ab
// der Entry ist schon selektiert, steht aber auch in der SelectList -> er kann aus letzterer
// der Entry ist selektiert, aber steht nicht in der SelectList -> Selektion rausnehmen
// und sichtbar machen (kann ja sein, dass das die einzige Modifikation ist, die ich hier in dem
// ganzen Handler mache, dann sollte das zu sehen sein)
// jetzt habe ich in der SelectList genau die Eintraege, die noch selektiert werden muessen
// zwei Moeglichkeiten : 1) ich gehe durch die SelectList, besorge mir zu jedem Eintrag meinen SvTreeListEntry
// und selektiere diesen (waere irgendwie intuitiver ;)) 2) ich gehe durch alle meine SvLBoxEntries und selektiere
// genau die, die ich in der SelectList finde
// 1) braucht O(k*n) (k=Laenge der SelectList, n=Anzahl meiner Entries), plus den Fakt, dass FindEntry nicht den
// Pointer auf die UserDaten vergleicht, sondern ein aufwendigeres IsEqualWithoutChildren durchfuehrt
// 2) braucht O(n*log k), dupliziert aber etwas Code (naemlich den aus FindEntry)
// da das hier eine relativ oft aufgerufenen Stelle sein koennte (bei jeder Aenderung in der Markierung in der View !),
// nehme ich doch lieber letzteres
// die Shell werde ich brauchen ...
// Die View soll jetzt kein Notify bei einer Aenderung der MarkList rauslassen
// Bei Formselektion alle Controls dieser Form markieren
// Bei Controlselektion Control-SdrObjects markieren
// Beim HiddenControl kann kein Object selektiert werden
// wenn der PropertyBrowser offen ist, muss ich den entsprechend meiner Selektion anpassen
// (NICHT entsprechend der MarkList der View : wenn ich ein Formular selektiert habe, sind in der
// View alle zugehoerigen Controls markiert, trotzdem moechte ich natuerlich die Formular-Eigenschaften
// sehen)
// Flag an View wieder zuruecksetzen
// wenn jetzt genau eine Form selektiert ist, sollte die Shell das als CurrentForm mitbekommen
// (wenn SelectionHandling nicht locked ist, kuemmert sich die View eigentlich in MarkListHasChanged drum,
// aber der Mechanismus greift zum Beispiel nicht, wenn die Form leer ist)
// das passiert manchmal, ich glaube, die Basisklasse geht zu sehr auf Nummer sicher ;)
// In der Page das entsprechende SdrObj finden und selektieren
// In der Page das entsprechende SdrObj finden und selektieren


12 / 93 | libreoffice-4.4.0.3/svx/source/form/fmundo.cxx
// ist das Control noch einer Form zugeordnet
// ist das Control noch einer Form zugeordnet
// das Object wird aus einer Liste herausgenommen
// existiert ein Vater wird das Object beim beim Vater entfernt und
// wird das Object wieder eingefuegt und ein Parent existiert, so wird dieser
// Parent wiederum gesetzt
// Feststellen an welcher Position sich das Kind befunden hat
// #i41029# / 2005-01-31 / frank.schoenheit@sun.com
// neues Object zum lauschen
// am Container horchen
// am Container horchen
// 86299 - 05/02/2001 - frank.schoenheit@germany.sun.com


62 / 123 | libreoffice-4.4.0.3/svx/source/form/fmsrcimp.cxx
// das Feld selber
// von dem weiss ich jetzt, dass es den DatabaseRecord-Service unterstuetzt (hoffe ich)
// fuer den FormatKey und den Typ brauche ich das PropertySet
// die FieldInfo dazu aufbauen
// und merken
// sonst werden Datumsflder zum Beispiel zu irgendeinem Default-Wert formatiert
// analoge Situation wie unten
// ich bin im single-field-modus, da ist auch die richtige Feld-Nummer erlaubt, obwohl dann der richtige ::com::sun::star::sdbcx::Index
// fuer meinen Array-Zugriff natuerlich 0 ist
// der aktuell zu vergleichende Inhalt
// naechstes Feld (implizit naechster Datensatz, wenn noetig)
// beim Bewegen auf das naechste Feld ging was schief ... weitermachen ist nicht drin, da das naechste Mal genau
// das selbe bestimmt wieder schief geht, also Abbruch
// vorher aber noch, damit das Weitersuchen an der aktuellen Position weitermacht :
// und wech
// das heisst, ich habe mich auf einen neuen Datensatz bewegt
// abbrechen gefordert ?
// der aktuell zu vergleichende Inhalt
// jetzt ist der Test einfach ...
// naechstes Feld (implizit naechster Datensatz, wenn noetig)
// beim Bewegen auf das naechste Feld ging was schief ... weitermachen ist nicht drin, da das naechste Mal genau
// das selbe bestimmt wieder schief geht, also Abbruch
// vorher aber noch, damit das Weitersuchen an der aktuellen Position weitermacht :
// und wech
// das heisst, ich habe mich auf einen neuen Datensatz bewegt
// abbrechen gefordert ?
// der aktuell zu vergleichende Inhalt
// das heisst hier 'forward' aber das bezieht sich nur auf die Suche innerhalb von sCurrentCheck, hat also mit
// der Richtung meines Datensatz-Durchwanderns nix zu tun (darum kuemmert sich MoveField)
// checken, ob die Position stimmt
// laeuft in den naechsten Case rein !
// naechstes Feld (implizit naechster Datensatz, wenn noetig)
// beim Bewegen auf das naechste Feld ging was schief ... weitermachen ist nicht drin, da das naechste Mal genau
// das selbe bestimmt wieder schief geht, also Abbruch (ohne Fehlermeldung, von der erwarte ich, dass sie im Move
// angezeigt wurde)
// vorher aber noch, damit das Weitersuchen an der aktuellen Position weitermacht :
// und wech
// das heisst, ich habe mich auf einen neuen Datensatz bewegt
// abbrechen gefordert ?
// -1 hat schon eine Bedeutung, also nehme ich -2 fuer 'ungueltig'
// -1 hat schon eine Bedeutung, also nehme ich -2 fuer 'ungueltig'
// das muss konsistent sein mit m_xSearchCursor, der i.A. == m_xOriginalIterator ist
// der Cursor kann mir einen Record (als PropertySet) liefern, dieser unterstuetzt den DatabaseRecord-Service
// in der Feld-Sammlung suchen
// ich benutzte keinen Formatter, sondern TextComponents -> der SearchIterator muss angepasst werden
// damit ich mit dem neuen Iterator wirklich dort weitermache, wo ich vorher aufgehoert habe
// ich muss die Fields neu binden, da der Textaustausch eventuell ueber diese Fields erfolgt und sich der unterliegende Cursor
// geaendert hat
// die Parameter der Suche
// brauche ich non-const
// 'normale' Suche fuehre ich auf jeden Fall ueber WildCards durch, muss aber vorher je nach Modus den OUString anpassen
// da natuerlich in allen anderen Faellen auch * und ? im Suchstring erlaubt sind, aber nicht als WildCards zaehlen
// sollen, muss ich normieren
// fuer Arbeit auf Feldliste
// im Feld nach (oder vor) der letzten Fundstelle weitermachen
// gefunden ?
// die "letzte Fundstelle" invalidieren
// per definitionem muss der Link Thread-sicher sein (das verlange ich einfach), so dass ich mich um so etwas hier nicht kuemmern muss
// der loescht sich nach Beendigung selber ...
// (da ich keinen Wechsel des Iterators von aussen zulasse, heisst selber ::com::sun::star::sdbcx::Index auch immer selbe Spalte, also habe ich nix zu tun)
// alle Felder, die ich durchsuchen muss, einsammeln
// und natuerlich beginne ich die naechste Suche wieder jungfraeulich


1 / 82 | libreoffice-4.4.0.3/svx/source/form/fmtextcontrolshell.cxx
// #i51621# / 2005-08-19 / frank.schoenheit@sun.com


4 / 9 | libreoffice-4.4.0.3/svx/source/form/fmobjfac.cxx
// Konfigurations-::com::sun::star::frame::Controller und NavigationBar registrieren
// Registrieung von globalen fenstern
// Interface fuer die Formshell registrieren
// ::com::sun::star::form::Form-Objekte erzeugen


26 / 71 | libreoffice-4.4.0.3/svx/source/form/fmshell.cxx
// wird fuer Invalidate verwendet -> mitpflegen
// aufsteigend sortieren !!!!!!
// Zunaechst werden die aktuellen Inhalte der Controls gespeichert
// Wenn alles glatt gelaufen ist, werden die modifizierten Datensaetze gespeichert
// mein m_bDesignMode wird auch von der Impl gesetzt ...
// nur wenn auch formulare verfuegbar
// nur wenn auch formulare verfuegbar
// Identifier und Inventor des Uno-Controls setzen
// nach dem Konvertieren die Selektion neu bestimmern, da sich ja das selektierte Objekt
// geaendert hat
// PropertyBrowser anzeigen
// setzen der View Forcieren
// Ist der ::com::sun::star::drawing::Layer gelocked, so m???ssen die Slots disabled werden. #36897
// der Impl eventuell die Moeglichjkeit geben, ihre an der aktuellen MarkList ausgerichteten Objekte
// auf den neuesten Stand zu bringen
// der Impl eventuell die Moeglichjkeit geben, ihre an der aktuellen MarkList ausgerichteten Objekte
// auf den neuesten Stand zu bringen
// der Impl eventuell die Moeglichjkeit geben, ihre an der aktuellen MarkList ausgerichteten Objekte
// auf den neuesten Stand zu bringen
// Existieren Formulare auf der aktuellen Page
// fuer die Zeit des Uebergangs das Undo-Environment ausschalten, das sichert, dass man dort auch nicht-transiente
// Properties mal eben aendern kann (sollte allerdings mit Vorsicht genossen und beim Rueckschalten des Modes
// auch immer wieder rueckgaegig gemacht werden. Ein Beispiel ist das Setzen der maximalen Text-Laenge durch das
// OEditModel an seinem Control.)
// dann die eigentliche Umschaltung
// und mein Undo-Environment wieder an


2 / 60 | libreoffice-4.4.0.3/svx/source/form/fmobj.cxx
// liegt das UnoControlModel in einer Eventumgebung,
// dann koennen noch Events zugeordnet sein


1 / 15 | libreoffice-4.4.0.3/svx/source/form/formdispatchinterceptor.cxx
// 88936 - 23.07.2001 - frank.schoenheit@sun.com


25 / 118 | libreoffice-4.4.0.3/svx/source/form/filtnav.cxx
// solange dauert es, bis das Scrollen anspringt
// in diesen Intervallen wird jeweils eine Zeile gescrollt
// das ist die Basis, mit der beide Angaben multipliziert werden (in ms)
// UI benachrichtigen
// UI benachrichtigen
// UI benachrichtigen
// tja, eigentlich muesste ich noch testen, ob die Node nicht schon expandiert ist, aber ich
// habe dazu weder in den Basisklassen noch im Model eine Methode gefunden ...
// aber ich denke, die BK sollte es auch so vertragen
// nach dem Expand habe ich im Gegensatz zum Scrollen natuerlich nix mehr zu tun
// kuemmern wir uns erst mal um moeglich DropActions (Scrollen und Aufklappen)
// auf dem ersten Eintrag ?
// auf dem letzten (bzw. in dem Bereich, den ein Eintrag einnehmen wuerde, wenn er unten genau buendig
// abschliessen wuerde) ?
// -> aufklappen
// neu anfangen zu zaehlen
// die Pos merken, da ich auch QueryDrops bekomme, wenn sich die Maus gar nicht bewegt hat
// und den Timer los
// gibt es den Timer schon ?
// Hat das Object das richtige Format?
// ware schlecht, wenn nach dem Droppen noch gescrollt wird ...
// das Ziel des Drop sowie einige Daten darueber
// das passiert manchmal, ich glaube, die Basisklasse geht zu sehr auf Nummer sicher ;)
// der Entry zu den Daten
// die Stelle, an der geklickt wurde


19 / 133 | libreoffice-4.4.0.3/svx/source/form/fmvwimp.cxx
// jetzt die Subforms durchgehen
// Am ControlContainer horchen um Aenderungen mitzbekommen
// Wird gerufen, wenn
// - in den Design-Modus geschaltet wird
// - ein Window geloescht wird, waehrend man im Design-Modus ist
// - der Control-Container fuer ein Window entfernt wird, waehrend
//   der aktive Modus eingeschaltet ist.
// und fertig
// Textbreite ist mindestens 4cm
// wenn das entfernte Objekt in meiner MarkList, die ich mir beim Umschalten in den Alive-Mode gemerkt habe, steht,
// muss ich es jetzt da rausnehmen, da ich sonst beim Zurueckschalten versuche, die Markierung wieder zu setzen
// (interesanterweise geht das nur bei gruppierten Objekten schief (beim Zugriff auf deren ObjList GPF), nicht bei einzelnen)
// ich brauche nicht in GroupObjects absteigen : wenn dort unten ein Objekt geloescht wird, dann bleibt der
// Zeiger auf das GroupObject, den ich habe, trotzdem weiter gueltig bleibt ...
// wichtig ist das auf die Objecte der markliste nicht zugegriffen wird
// da diese bereits zerstoert sein koennen
// gibt es noch alle Objecte
// Das LastObject auswerten
// Objecte jetzt Markieren


1 / 92 | libreoffice-4.4.0.3/svx/source/table/svdotable.cxx
// weil GetSize() ein draufaddiert


1 / 10 | libreoffice-4.4.0.3/svx/source/table/tablertfexporter.cxx
// Zeilen nicht zu lang werden lassen


3 / 67 | libreoffice-4.4.0.3/svx/source/table/cell.cxx
// Propertymap fuer einen Outliner Text
// Default aus ItemPool holen
// Default aus ItemPool holen


2 / 100 | libreoffice-4.4.0.3/svx/source/table/tablecontroller.cxx
// Bei nur einem Pararaph
// FALSE= InvalidItems nicht al Default, sondern als "Loecher" betrachten


1 / 41 | libreoffice-4.4.0.3/svx/source/table/tablelayouter.cxx
// last column get round errors


5 / 24 | libreoffice-4.4.0.3/svx/source/tbxctrls/tbunocontroller.cxx
// ge"andert => neuen Wert setzen
// Wert in der Anzeige l"oschen
// Sizes-Liste auff"ullen
// alten Wert wiederherstellen
// zum R"ucksetzen bei ESC merken


1 / 4 | libreoffice-4.4.0.3/svx/source/tbxctrls/SvxColorChildWindow.cxx
// Ableitung vom SfxChildWindow als "Behaelter" fuer Animator


2 / 15 | libreoffice-4.4.0.3/svx/source/tbxctrls/tbxalign.cxx
/*
 * Wenn man ein PopupWindow erzeugen will
 */
/*
 * Hier wird das Fenster erzeugt
 * Lage der Toolbox mit GetToolBox() abfragbar
 * rItemRect sind die Screen-Koordinaten
 */


1 / 21 | libreoffice-4.4.0.3/svx/source/tbxctrls/fontworkgallery.cxx
// Ueber die Gallery werden die Favoriten eingelesen


17 / 36 | libreoffice-4.4.0.3/svx/source/tbxctrls/colrctrl.cxx
// Als Link, damit asynchron ohne ImpMouseMoveMsg auf dem Stack auch die
// Farbleiste geloescht werden darf
// Die Liste der Farben hat sich geaendert
// Zeilen und Spalten berechnen
// Spalten mit ScrollBar berechnen
// sonst wird LineHeight ignoriert
// unsichtbar
// Wenn wir eine DrawView haben und uns im TextEdit-Modus befinden,
// wird nicht die Flaechen-, sondern die Textfarbe zugewiesen
// unsichtbar
// unsichtbar
// Sollte der LineStyle unsichtbar sein, so wird er auf SOLID gesetzt
// unsichtbar
// Spalten und Reihen ermitteln
// Spalten mit ScrollBar berechnen
// Max. Reihen anhand der gegebenen Spalten berechnen
// Groesse des Windows setzen


2 / 15 | libreoffice-4.4.0.3/svx/source/mnuctrls/SmartTagCtl.cxx
// ohne dispatcher!!!
// GetBindings().Execute( GetId(), SfxCallMode::RECORD,meine beiden items, 0L );*/


7 / 10 | libreoffice-4.4.0.3/svx/source/mnuctrls/fntctl.cxx
/*  [Beschreibung]

    Ctor; setzt den Select-Handler am Men"u und tr"agt das Men"u
    in seinen Parent ein.
*/
/*  [Beschreibung]

    F"ullt das Men"u mit den aktuellen Fonts aus der Fontlist
    der DocumentShell.
*/
/*  [Beschreibung]

    Statusbenachrichtigung;
    f"ullt ggf. das Men"u mit den aktuellen Fonts aus der Fontlist
    der DocumentShell.
    Ist die Funktionalit"at disabled, wird der entsprechende
    Men"ueintrag im Parentmen"u disabled, andernfalls wird er enabled.
    Der aktuelle Font wird mit einer Checkmark versehen.
*/
/*  [Beschreibung]

    Statusbenachrichtigung "uber Bindings;  bei DOCCHANGED
    wird das Men"u mit den aktuellen Fonts aus der Fontlist
    der DocumentShell gef"ullt.
*/
/*  [Beschreibung]

    Select-Handler des Men"us; der Name des selektierten Fonts
    wird in einem SvxFontItem verschickt. Das F"ullen mit den
    weiteren Fontinformationen mu\s durch die Applikation geschehen.
*/
/*  [Beschreibung]

    Dtor; gibt das Men"u frei.
*/
/*  [Beschreibung]

    Gibt das Men"u zur"uck
*/


8 / 11 | libreoffice-4.4.0.3/svx/source/mnuctrls/fntszctl.cxx
/*  [Beschreibung]

    Select-Handler des Men"us; die aktuelle Fontgr"o\se
    wird in einem SvxFontHeightItem verschickt.
*/
/*  [Beschreibung]

    Statusbenachrichtigung;
    Ist die Funktionalit"at disabled, wird der entsprechende
    Men"ueintrag im Parentmenu disabled, andernfalls wird er enabled.
    die aktuelle Fontgr"o\se wird mit einer Checkmark versehen.
*/
// else manche Shells haben keine Fontliste (z.B. Image)
// irgendwie muss man ja das Men"u f"ullen
// daf"ur von der Shell eine Fontliste besorgen
/*  [Beschreibung]

    Ctor; setzt den Select-Handler am Men"u und tr"agt Men"u
    in seinen Parent ein.
*/
/*  [Beschreibung]

    Dtor; gibt das Men"u frei.
*/
/*  [Beschreibung]

    Gibt das Men"u zur"uck
*/


2 / 67 | libreoffice-4.4.0.3/svx/source/engine3d/dragmt3d.cxx
// Hide wireframe
// constrain to auf Y -> X equal


44 / 166 | libreoffice-4.4.0.3/svx/source/fmcomp/fmgridcl.cxx
// a.) Name des Feldes fuer Label und ControlSource
// b.) FormatKey, um festzustellen, welches Feld erzeugt werden soll
// diese Datentypen koennen im Gridcontrol nicht verarbeitet werden
// Erstellen der Column
// EinfuegePosition, immer vor der aktuellen Spalte
// jetzt einfuegen
// ist die component::Form an die Datenbankangebunden?
// Aufbau des Insert Menues
// EinfuegePosition, immer vor der aktuellen Spalte
// ein paar Properties hinueberretten
// waehrend Positionierung wird kein abgleich  der Properties vorgenommen
// selection aufheben
// An den DatenCursor anpassen
// #154303# / 2008-04-23 / frank.schoenheit@sun.com
// Sind alle Zeilen Selectiert
// Zweite bedingung falls keine einguegeZeile existiert
// An den DatenCursor anpassen
// es konnten nicht alle Zeilen geloescht werden
// da nie nicht geloeschten wieder selektieren
// waren alle selektiert
// einfuegeZeile nicht
// Zeile konnte nicht geloescht werden
// Commit nur ausfuehren, wenn nicht bereits ein Update vom ::com::sun::star::form::component::GridControl ausgefuehrt
// wird
// Zeile ist eingefuegt worden, dann den status und mode zuruecksetzen
// Wert ans model uebergeben
// Umrechnen in 10THMM
// suchen der Spalte und verschieben im Model
// Einfuegen muss sich an den Column Positionen orientieren
// Spalten wieder neu setzen
// wenn es nur eine HandleColumn gibt, dann nicht
// Einfuegen muss sich an den Column Positionen orientieren
// und jetzt noch die hidden columns rausnehmen
// (wir haben das nicht gleich in der oberen Schleife gemacht, da wir dann Probleme mit den
// IDs der Spalten bekommen haetten : AppendColumn vergibt die automatisch, die Spalte _nach_
// einer versteckten braucht aber eine um eine erhoehte ID ....
// Spalten initialisieren
// Einfuegen muss sich an den Column Positionen orientieren
// leerzeile nicht loeschen
// selection aufheben fuer leerzeile
// Zunaechst den DatenCursor auf den selektierten Satz pos.
// ... betrifft das unsere Spalten ?
// die HandleColumn wird nicht selektiert
// VOR dem Aufruf des select am SelectionSupplier !


8 / 369 | libreoffice-4.4.0.3/svx/source/fmcomp/gridctrl.cxx
// Handler fuer Buttons einrichten
// Wenn kein Cursor -> keine Rows im Browser.
// neue Zeile
// #i67147# / 2006-07-17 / frank.schoenheit@sun.com
// in der Debug-Version rechnen wir die ModelPos in eine ViewPos um und vergleichen das mit dem Wert,
// den wir zurueckliefern werden (nId an der entsprechenden Col in m_aColumns)
// macht nur Sinn, wenn die Spalte sichtbar ist
// 94093 - 02.11.2001 - frank.schoenheit@sun.com


10 / 206 | libreoffice-4.4.0.3/svx/source/fmcomp/fmgridif.cxx
// 14.05.2001 - 86836 - frank.schoenheit@germany.sun.com
// eine 'Konvertierungstabelle'
// das Control zur angegebenen Row fahren
// und durch alle Spalten durch
// Handle Column beruecksichtigen
// jetzt die Spalte setzen
// Handle Column beruecksichtigen
// Handle Column beruecksichtigen
// ist das der Default
// (wenn das nicht greift, wurde das selectionChanged implizit von dem Control selber ausgeloest


48 / 175 | libreoffice-4.4.0.3/svx/source/fmcomp/gridcell.cxx
// Grundeinstellung
// Alles nur damit die Selektion bei Focuserhalt von rechts nach links geht
// wenn man _irgendeine_ Formatierung zulaesst, kann man da sowieso keine Eingabe-Ueberpruefung
// machen (das FormattedField unterstuetzt das sowieso nicht, nur abgeleitete Klassen)
// von dem Uno-Model den Formatter besorgen
// (Ich koennte theoretisch auch ueber den ::com::sun::star::util::NumberFormatter gehen, den mir der Cursor bestimmt
// liefern wuerde. Das Problem dabei ist, dass ich mich eigentlich nicht darauf verlassen
// kann, dass die beiden Formatter die selben sind, sauber ist das Ganze, wenn ich ueber das
// mal sehen, ob das Model einen hat ...
// wenn wir den Supplier vom Model nehmen, dann auch den Key
// nein ? vielleicht die ::com::sun::star::form::component::Form hinter dem Cursor ?
// wenn wir vom Cursor den Formatter nehmen, dann auch den Key vom Feld, an das wir gebunden sind
// alles hingfaellig : der Supplier ist vom falschen Typ, dann koennen wir uns auch nicht darauf verlassen, dass
// ein Standard-Formatter den (eventuell nicht-Standard-)Key kennt.
// einen Standard-Formatter ...
// ... und einen Standard-Key
// Min- und Max-Werte
// das Ding kann ein double oder ein String sein
// defaultmaessig keine Farb-Angabe
// das IsNumeric an der Column sagt nichts aus ueber die Klasse des benutzen Formates, sondern
// ueber die des an die Column gebundenen Feldes. Wenn man also eine FormattedField-Spalte an
// ein double-Feld bindet und als Text formatiert, liefert m_rColumn.IsNumeric() sal_True. Das heisst
// also einfach, dass ich den Inhalt der Variant mittels getDouble abfragen kann, und dann kann
// ich den Rest (die Formatierung) dem FormattedField ueberlassen.
// Hier kann ich nicht mit einem double arbeiten, da das Feld mir keines liefern kann.
// Also einfach den Text vom ::com::sun::star::util::NumberFormatter in die richtige ::com::sun::star::form::component::Form brinden lassen.
// das IsNumeric an der Column sagt nichts aus ueber die Klasse des benutzen Formates, sondern
// ueber die des an die Column gebundenen Feldes. Wenn man also eine FormattedField-Spalte an
// ein double-Feld bindet und als Text formatiert, liefert m_rColumn.IsNumeric() sal_True. Das heisst
// also einfach, dass ich den Inhalt der Variant mittels getDouble abfragen kann, und dann kann
// ich den Rest (die Formatierung) dem FormattedField ueberlassen.
// Hier kann ich nicht mit einem double arbeiten, da das Feld mir keines liefern kann.
// Also einfach den Text vom ::com::sun::star::util::NumberFormatter in die richtige ::com::sun::star::form::component::Form brinden lassen.
// ein LeerString wird erst mal standardmaessig als void weitergereicht
// dem Field und dem Painter einen Formatter spendieren
// zuerst testen, ob ich von dem Service hinter einer Connection bekommen kann
// der Cursor fuehrte nicht zum Erfolg -> Standard
// und dann ein Format generieren, dass die gewuenschten Nachkommastellen usw. hat
//VclBuilder::mungeAdjustment
// selection von rechts nach links
// ein Statement aufbauen und abschicken als query
// max anzahl eintraege
// In JAVA wird auch ein textChanged ausgeloest, in VCL nicht.
// ::com::sun::star::awt::Toolkit soll JAVA-komform sein...
// 91210 - 22.08.2001 - frank.schoenheit@sun.com
// Nicht wenn 0xFFFF, weil LIST_APPEND
// Bei Mehrfachselektion 0xFFFF, sonst die ID
// Bei Mehrfachselektion 0xFFFF, sonst die ID


1 / 4 | libreoffice-4.4.0.3/svx/source/fmcomp/gridcols.cxx
// Vergleichen von PropertyInfo


1 / 17 | libreoffice-4.4.0.3/svx/source/sdr/contact/viewobjectcontactofsdrobj.cxx
// #i72429# / 2007-02-20 / frank.schoenheit (at) sun.com


6 / 185 | libreoffice-4.4.0.3/svx/source/sdr/contact/viewobjectcontactofunocontrol.cxx
// #i104181# / 2009-08-18 / frank.schoenheit@sun.com
// 2009-08-27 / #i104544# frank.schoenheit@sun.com
// #i74523# / 2007-02-15 / frank.schoenheit@sun.com
// #i82169# / 2007-11-14 / frank.schoenheit@sun.com
// #i82169# / 2007-11-14 / frank.schoenheit@sun.com
// #102090# / 2009-06-05 / frank.schoenheit@sun.com


1 / 26 | libreoffice-4.4.0.3/svx/source/sdr/animation/scheduler.cxx
// scheduler class


28 / 59 | libreoffice-4.4.0.3/svx/source/items/numfmtsh.cxx
/*
     * An dieser Stelle wird abhaengig davon, ob die
     * hinzugefuegten, benutzerdefinierten als gueltig
     * erklaert wurden (ValidateNewEntries()), die
     * Add-Liste wieder aus dem Zahlenformatierer entfernt.
     *
     * Loeschen von Formaten aus dem Formatierer passiert
     * aus Undo-Gruenden nur in der aufrufenden Instanz.
     */
// Hinzugefuegte Formate sind nicht gueltig:
// => wieder entfernen:
// bereits vorhanden?
// neues Format
// eingefuegt
// Doppelt einfuegen nicht moeglich
// oder doch?
// Vorbedingung: Zahlenformatierer gefunden
// Sonderbehandlung fuer undefiniertes Zahlenformat:
// Kategorie = Undefiniert
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
/* Erstellen einer aktuellen Liste von Format-Eintraegen.
     * Rueckgabewert ist die Listenposition des aktuellen Formates.
     * Ist die Liste leer oder gibt es kein aktuelles Format,
     * so wird SELPOS_NONE geliefert.
     */
// Konvertierungs-Routinen:
// Kategorie ::com::sun::star::form-Positionen abbilden (->Resource)
// Kategorie auf ::com::sun::star::form-Positionen abbilden (->Resource)
/*
 * Funktion:   Formatiert die Zahl nValue abhaengig von rFormatStr
 *             und speichert das Ergebnis in rPreviewStr.
 * Input:      FormatString, Farbe, zu formatierende Zahl
 * Output:     Ausgabestring rPreviewStr
 */
/*
 * Funktion:   Liefert den Kommentar fuer einen gegebenen
 *             Eintrag zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Kommentar-String
 */
/*
 * Funktion:   Liefert den Kommentar fuer einen gegebenen
 *             Eintrag zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Kommentar-String
 */
/*
 * Funktion:   Liefert die Kategorie- Nummer fuer einen gegebenen
 *             Eintrag zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Kategorie- Nummer
 */
/*
 * Funktion:   Liefert die Information, ob ein Eintrag
 *             benutzerspezifisch ist zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Benutzerspezifisch?
 */
/*
 * Funktion:   Liefert den Format- String fuer einen gegebenen
 *             Eintrag zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Format- String
 */
/*
 * Funktion:   Liefert die Listen- Nummer fuer einen gegebenen
 *             Formatindex zurueck.
 * Input:      Nummer des Eintrags
 * Output:     Kategorie- Nummer
 */


1 / 13 | libreoffice-4.4.0.3/svx/source/items/rotmodit.cxx
//  SvxRotateModeItem - Ausrichtung bei gedrehtem Text


2 / 15 | libreoffice-4.4.0.3/svx/source/items/algitem.cxx
// letzter Enum-Wert + 1
//  jetzt alles signed


2 / 22 | libreoffice-4.4.0.3/svx/source/items/pageitem.cxx
// Abfrage auf Gleichheit
//! die Konstanten sind nicht mehr in den IDLs ?!?


1 / 9 | libreoffice-4.4.0.3/svx/source/items/numinf.cxx
// Laden/Speichern wird nicht gebraucht!


1 / 10 | libreoffice-4.4.0.3/svx/source/items/e3ditem.cxx
// Werte eintragen


22 / 95 | libreoffice-4.4.0.3/svx/source/unodraw/unoshap2.cxx
// Zeiger auf innere sequences holen
// Neues Polygon vorbereiten
// Zeiger auf Arrays holen
// Neues Teilpolygon einfuegen
// Neues Polygon vorbereiten
// Zeiger auf Arrays holen
// Zeiger auf Arrays holen
// Zeiger auf aeussere Arrays holen
// Einzelpolygon holen
// Platz in Arrays schaffen
// Pointer auf arrays holen
// tools::PolyPolygon in eine struct tools::PolyPolygon packen
// tools::PolyPolygon in eine struct tools::PolyPolygon packen
// Einzelpolygon holen
// Pointer auf arrays holen
// tools::PolyPolygon in eine struct tools::PolyPolygon packen
// tools::PolyPolygon in eine struct tools::PolyPolygon packen
// Bitmap in das Objekt packen
// Bitmap einsetzen
// Objekt in eine Bitmap packen
// Polygon wenden und etwas schieben
// Polygon wenden und etwas schieben


1 / 100 | libreoffice-4.4.0.3/svx/source/unodraw/unoshtxt.cxx
// Text muss neu geholt werden


11 / 179 | libreoffice-4.4.0.3/svx/source/unodraw/unoshape.cxx
// Kreisabschnitt
// Aequivalenten Eintrag in pDst suchen
// Special ID im PropertySet, kann nur direkt am
// Objekt gesetzt werden+
// Position ist absolut, relativ zum Anker stellen
// SdrObject aus der Page loeschen
// Default aus ItemPool holen
// Default aus ItemPool holen
// Kreisabschnitt
// Hole Wert aus ItemSet
// Default aus ItemPool holen


21 / 69 | libreoffice-4.4.0.3/svx/source/unodraw/unoshap3.cxx
// Transformationsmatrix in das Objekt packen
// Objekt in eine homogene 4x4 Matrix packen
// Transformationsmatrix in das Objekt packen
// Position in das Objekt packen
// Groesse in das Objekt packen
// sal_Bool bPosIsCenter in das Objekt packen
// Transformation in eine homogene Matrix packen
// Transformationsmatrix in das Objekt packen
// Position in das Objekt packen
// Groesse in das Objekt packen
// Transformation in eine homogene Matrix packen
// Transformationsmatrix in das Objekt packen
// Polygondefinition in das Objekt packen
// Transformation in eine homogene Matrix packen
// Transformationsmatrix in das Objekt packen
// Polygondefinition in das Objekt packen
// Transformation in eine homogene Matrix packen
// Transformationsmatrix in das Objekt packen
// Polygondefinition in das Objekt packen
// Normalendefinition in das Objekt packen
// Texturdefinition in das Objekt packen


9 / 46 | libreoffice-4.4.0.3/svx/source/unodraw/unomod.cxx
//              case HINT_LAYERORDERCHG:        // Layerreihenfolge geaendert (Insert/Remove/ChangePos)
//              case HINT_LAYERSETORDERCHG:     // Layersetreihenfolge geaendert (Insert/Remove/ChangePos)
// Reihenfolge der Seiten (Zeichenseiten oder Masterpages) geaendert (Insert/Remove/ChangePos)
// Neues Zeichenobjekt eingefuegt
// Zeichenobjekt aus Liste entfernt
//                HINT_DEFAULTTABCHG,   // Default Tabulatorweite geaendert
// Erzeugt eine neue Seite mit Model an der angegebennen Position und gibt die
// dazugehoerige SdDrawPage zurueck.
// pPage von xPage besorgen und dann die Id (nPos )ermitteln


10 / 46 | libreoffice-4.4.0.3/svx/source/unodraw/unopage.cxx
// Erzeugen der (hidden) View
// ACHTUNG: _SelectObjectsInView selektiert die ::com::sun::star::drawing::Shapes nur in der angegebennen
//         SdrPageView. Dies muss nicht die sichtbare SdrPageView sein.
// ACHTUNG: _SelectObjectInView selektiert das Shape *nur* in der angegebennen
//         SdrPageView. Dies muss nicht die sichtbare SdrPageView sein.
// Szene initialisieren
// unbekanntes 3D-Objekt auf der Page
// unbekanntes 2D-Objekt auf der Page
// Unbekannter Inventor
// Kreisabschnitt


1 / 104 | libreoffice-4.4.0.3/svx/source/dialog/dlgctrl.cxx
// RectPoint ist dummy


2 / 131 | libreoffice-4.4.0.3/svx/source/dialog/docrecovery.cxx
/*DisableReschedule*/
/* TODO

        wenn die m_pCore noch ein Member m_nCurrentItem haette
        koennte man dort erkennen, wer gerade drann war, wer demnaechst
        dran ist ... Diese Info kann man dann in unserem Progress FixText anzeigen ...
    */


1 / 32 | libreoffice-4.4.0.3/svx/source/dialog/_bmpmask.cxx
//SfxBoolItem erwartet


1 / 85 | libreoffice-4.4.0.3/svx/source/dialog/dlgctl3d.cxx
// make mpLampBottomObject/mpLampShaftObject invisible


2 / 28 | libreoffice-4.4.0.3/svx/source/dialog/swframeexample.cxx
// Bereich, zu dem relativ positioniert wird, bestimmen
// Testabsatz zeichnen


1 / 40 | libreoffice-4.4.0.3/svx/source/dialog/srchdlg.cxx
// remember strings speichern


3 / 116 | libreoffice-4.4.0.3/svx/source/sidebar/nbdtmg.cxx
//sal_Unicode cSuffix = rtl::OUString(aFmt.GetSuffix())[0];
//sal_Unicode cSuffix = rtl::OUString(aFmt.GetSuffix())[0];
//sal_Unicode cSuffix = rtl::OUString(aFmt.GetSuffix())[0];


1 / 35 | libreoffice-4.4.0.3/winaccessibility/source/UAccCOM/AccHypertext.h
/**
 * CAccHypertext implements IAccessibleHypertext interface.
 */


1 / 119 | libreoffice-4.4.0.3/cppuhelper/test/testpropshlp.cxx
// muss sortiert sein


1 / 85 | libreoffice-4.4.0.3/cppuhelper/source/factory.cxx
// #i63511# / 2006-03-27 / frank.schoenheit@sun.com


1 / 71 | libreoffice-4.4.0.3/svl/source/undo/undo.cxx
// schedule notification


1 / 214 | libreoffice-4.4.0.3/svl/source/items/itemset.cxx
// pWhichPairTable == 0 ist f"ur das SfxAllEnumItemSet


1 / 152 | libreoffice-4.4.0.3/svl/source/items/poolio.cxx
// Version maps einlesen


2 / 435 | libreoffice-4.4.0.3/svl/source/numbers/zforlist.cxx
// Hard coded DIN (Deutsche Industrie Norm) and EN (European Norm) date formats
// -1:=Klammer 0:=links, 1:=mitte, 2:=rechts


34 / 44 | libreoffice-4.4.0.3/i18npool/source/search/levdis.hxx
/*
 maximal X Ersetzungen  (User: gefundenes darf X Zeichen anders sein)
 maximal Y Einfuegungen (User: gefundenes darf Y Zeichen kuerzer sein)
 maximal Z Loeschungen  (User: gefundenes darf Z Zeichen laenger sein)
 mathematische WLD oder SplitCount  (User: strikt oder relaxed)

 Joker ('?' und '*') fallen natuerlich nicht unter diese Bedingungen.
 Bei einem '?' wird eine Ersetzung nicht gezahlt, bei einem '*' darf
 der gefundene String an dieser Stelle beliebig viele Zeichen laenger sein.

 Strikt: entweder maximal X anders oder Y kuerzer oder Z laenger
 Relaxed: maximal X anders und/oder Y kuerzer und/oder Z laenger

 Wertebereich fuer X,Y,Z ist 0..33 um mit Limit sicher unter
 16-bit-signed-int-max zu bleiben, 31*32*33 gibt das Maximum
 LCM(31,32,33) == 32736
 */
// default nLimit, passt zu x=2, y=1, z=3,
// default nRepP0, Gewichtung Ersetzen
// default nInsQ0, Gewichtung Einfuegen
// default nDelR0, Gewichtung Loeschen
/*
 Berechnung von angegebenen Userwerten max Ersetzen, Kuerzer, Laenger mittels
 CalcLPQR(). Unschoen: wenn in WLD z.B. nLimit durch nDelR0 erreicht ist
 (String ist nZ laenger als Pattern), kann kein Zeichen mehr ersetzt werden.
 Dies kann durch Erhoehung von nX oder/und nZ vermieden werden, natuerlich
 mit den entsprechenden Seiteneffekten.. oder aber mit SplitCount (s.u.), was
 der Default bei CalcLPQR() ist.

 Achtung: Kuerzer = WLD.Insert, Laenger = WLD.Delete

 Gezaehlt wird von String nach Pattern (eine Loeschung bedeutet, dass aus
 String etwas geloescht werden muss, um auf Pattern zu kommen)

 Loeschungen zaehlen in diesem Beispiel am wenigsten, da meistens weniger
 bekannt ist, als gesucht wird. Ersetzungen erhalten mittlere Gewichtung
 wegen z.B. falscher Schreibweisen. Einfuegungen werden teuer.

 Oder z.B.: P0 = 1, Q0 = 4, R0 = 4, Limit = 3
 Erlaubt sind maximal 4 Ersetzungen, keine Einfuegung, keine Loeschung
 Entspricht den Userangaben X = 3, Y = 0, Z = 0

 bSplitCount: wenn TRUE, werden Rep/Ins/Del anders gezaehlt.  Der
 Rueckgabewert von WLD ist dann nicht mehr unbedingt die Levenshtein-Distanz,
 sondern kann negativ (-WLD) sein, wenn die WLD groesser als nLimit ist, aber
 die Einzelwerte jeweils innerhalb der Grenzen liegen.
 Bei den Default-Werten hiesse das z.B.: auch wenn der gefundene String 2
 Zeichen laenger ist (nLongerZ), koennen noch 3 Ersetzungen (nOtherX)
 erfolgen.  Zusatz-Gimmick:  Buchstabendreher zaehlen als eine Ersetzung.
 Mathematisch voellig unkorrekt, aber gut fuer den User ;-)

 Zur Erlaeuterung: bei der echten WLD schoepfen alle Aktionen aus einem
 gemeinsamen 100%-Pool, wenn einer alles hat, ist fuer die anderen nichts
 mehr da. Mit bSplitCount hat Replace sein eigenes Wildwasser..
 */
// "sichere" Speicheranforderung im cTor
// Verwaltung des Pattern Arrays
// Pointer auf Pattern Array
// Pointer auf bool Array, ob Pattern Wildcard ist
// Verwaltung des Distanz Arrays
// Pointer auf Distanz Array
// WLD Limit Ersetzungen/Einfuegungen/Loeschungen
// Ersetzen Gewichtung
// Einfuegen Gewichtung
// Loeschen Gewichtung
// Anzahl '*' Joker im Pattern
// wenn TRUE, werden Rep/Ins/Del getrennt gezaehlt
// inline wegen Schleife
// Groesster Gemeinsamer Teiler
// Kleinstes Gemeinsames Vielfaches
// CToren mit Userangaben, danach mit GetLimit() Limit holen
// interner Aufruf von CalcLPQR()
// die mathematisch unkorrekte Berechnung wird als Default genommen!
// Berechnung der Levenshtein-Distanz von String zu Pattern
// Berechnung der Gewichtung aus Userangaben, return nLimit
// Gewichtungen holen
// Limit setzen,
// Gewichtungen setzen,
// returnen bisherigen Wert
// SetSplit( TRUE ) macht nur mit Werten nach CalcLPQR() Sinn!
// Balance, aus Geschwindigkeitsgruenden ist dieses keine Funktion
// erst wird bis Fundstelle gesucht, wenn dort die Balance gleich ist, wird
// auch nach der Fundstelle verglichen


2 / 39 | libreoffice-4.4.0.3/registry/source/regimpl.cxx
// 4 Bytes (sal_uInt32) fuer die Groesse des strings in Bytes
// 4 Bytes (sal_uInt32) fuer die Groesse des strings in Bytes


4 / 34 | libreoffice-4.4.0.3/svtools/source/inc/svimpbox.hxx
// typisch kleiner 0
// Anzahl Zeilen im Control
// ist true bei SINGLE_SELECTION
// setzt Thumb auf FirstEntryToDraw


1 / 67 | libreoffice-4.4.0.3/svtools/source/config/colorcfg.cxx
//detect current scheme name


1 / 22 | libreoffice-4.4.0.3/svtools/source/config/extcolorcfg.cxx
//detect current scheme name


1 / 24 | libreoffice-4.4.0.3/svtools/source/uno/genericunodialog.cxx
// #i65958# / 2006-07-07 / frank.schoenheit@sun.com


2 / 58 | libreoffice-4.4.0.3/svtools/source/uno/unoiface.cxx
// 17.05.2001 - 86859 - frank.schoenheit@germany.sun.com
// nur noch void erlaubt


1 / 38 | libreoffice-4.4.0.3/svtools/source/uno/unoevent.cxx
// not found -> return zero


1 / 12 | libreoffice-4.4.0.3/svtools/source/dialogs/wizdlg.cxx
// View-Window-Groesse dazurechnen


1 / 22 | libreoffice-4.4.0.3/svtools/source/dialogs/mcvmath.cxx
// die folgenden Tabellen enthalten     sin(phi) * 2**14


1 / 9 | libreoffice-4.4.0.3/svtools/source/dialogs/prnsetup.cxx
// Anzahl Jobs


1 / 23 | libreoffice-4.4.0.3/svtools/source/dialogs/insdlg.cxx
// noch nicht eingetragen


1 / 221 | libreoffice-4.4.0.3/svtools/source/table/tablecontrol_impl.cxx
// schedule repaint


1 / 55 | libreoffice-4.4.0.3/svtools/source/misc/imap.cxx
// neue Objekte einlesen


1 / 17 | libreoffice-4.4.0.3/svtools/source/misc/unitconv.cxx
// ggf. aufrunden


3 / 156 | libreoffice-4.4.0.3/svtools/source/svhtml/parhtml.cxx
// Innerhalb von Tags kennzeichnen
// break, String zusammen
// einfach alles wegschmeissen


1 / 67 | libreoffice-4.4.0.3/svtools/source/svhtml/htmlout.cxx
// in einen Stream aus


6 / 221 | libreoffice-4.4.0.3/svtools/source/contnr/svimpbox.cxx
// neuen Origin berechnen
// #122359# / 2005-05-23 / frank.schoenheit@sun.com
//  (Focusrect+ ContextBitmap bei TreeListBox)
// 06.09.20001 - 83416 - frank.schoenheit@sun.com
// #i31275# / 2009-06-16 / frank.schoenheit@sun.com
// auskommentiert wg. deselectall


1 / 84 | libreoffice-4.4.0.3/svtools/source/contnr/treelist.cxx
// vorlaeufig


1 / 110 | libreoffice-4.4.0.3/svtools/source/contnr/fileview.cxx
// 91872 - 11.09.2001 - frank.schoenheit@sun.com


1 / 57 | libreoffice-4.4.0.3/svtools/source/svrtf/svparser.cxx
// gescanntes Token


2 / 61 | libreoffice-4.4.0.3/svtools/source/svrtf/parrtf.cxx
// default ist ANSI-CodeSet
// default ist ANSI-CodeSet


1 / 39 | libreoffice-4.4.0.3/svtools/source/control/headbar.cxx
// Alle Items loeschen


1 / 134 | libreoffice-4.4.0.3/svtools/source/control/tabbar.cxx
// Controls loeschen


1 / 108 | libreoffice-4.4.0.3/svtools/source/control/inettbc.cxx
// Einlesung der Historypickliste


1 / 142 | libreoffice-4.4.0.3/svtools/source/control/fmtfield.cxx
// Sonderbehandlung fuer leere Texte


1 / 19 | libreoffice-4.4.0.3/svtools/source/control/stdmenu.cxx
// Menueintrag checken


1 / 166 | libreoffice-4.4.0.3/svtools/source/control/ruler.cxx
// Variablen initialisieren


2 / 44 | libreoffice-4.4.0.3/svtools/source/control/calendar.cxx
// Sonstige Strings erzeugen
// Wochenanzeige beruecksichtigen


2 / 94 | libreoffice-4.4.0.3/svtools/source/control/ctrlbox.cxx
// Daten kopieren
// SourceUnit nach Twips


1 / 10 | libreoffice-4.4.0.3/connectivity/source/inc/FDatabaseMetaDataResultSetMetaData.hxx
// ein Konstruktor, der fuer das Returnen des Objektes benoetigt wird:


1 / 8 | libreoffice-4.4.0.3/connectivity/source/drivers/mysql/YCatalog.cxx
// during #73245# / 2007-10-26 / frank.schoenheit@sun.com


3 / 95 | libreoffice-4.4.0.3/connectivity/source/drivers/evoab2/NDatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/


1 / 16 | libreoffice-4.4.0.3/connectivity/source/drivers/ado/ADatabaseMetaData.cxx
/*schemaPattern*/


1 / 244 | libreoffice-4.4.0.3/connectivity/source/drivers/dbase/DTable.cxx
// length doesn't match buffer size.


2 / 8 | libreoffice-4.4.0.3/connectivity/source/drivers/dbase/DDatabaseMetaData.cxx
/*schemaPattern*/
/*schema*/


2 / 291 | libreoffice-4.4.0.3/connectivity/source/drivers/firebird/DatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/


1 / 5 | libreoffice-4.4.0.3/connectivity/source/drivers/flat/EDatabaseMetaData.cxx
/*schemaPattern*/


1 / 24 | libreoffice-4.4.0.3/connectivity/source/drivers/jdbc/Clob.cxx
// 2005-11-15 / #i57457# / frank.schoenheit@sun.com


1 / 22 | libreoffice-4.4.0.3/connectivity/source/drivers/odbc/ODatabaseMetaData.cxx
/*schemaPattern*/


2 / 23 | libreoffice-4.4.0.3/connectivity/source/drivers/calc/CDatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/


4 / 112 | libreoffice-4.4.0.3/connectivity/source/drivers/mork/MDatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/


4 / 108 | libreoffice-4.4.0.3/connectivity/source/drivers/mozab/MDatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/


1 / 12 | libreoffice-4.4.0.3/connectivity/source/drivers/mozab/mozillasrc/MTypeConverter.cxx
//const PRUnichar* uniMozString = (const PRUnichar*) mozString;


1 / 314 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_databasemetadata.cxx
// <b>TABLE_SCHEM</b> string =&amp;gt; schema name


3 / 55 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_statement.cxx
//             OUString schema;
//                         OUStringToOString( schema, RTL_TEXTENCODING_ASCII_US ).getStr(),
//         OStringBuffer buf( 128);


19 / 140 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_xkeycolumns.cxx
//     const OUString & schemaName,
// //         OUStringBuffer buf(128);
//     OUStringBuffer buf( 128 );
//         bufferQuoteQualifiedIdentifier( buf, schemaName, tableName );
//         bufferQuoteIdentifier( buf, futureColumnName );
//             bufferQuoteQualifiedIdentifier( buf, schemaName, tableName );
//             bufferQuoteIdentifier( buf, futureColumnName );
//         buf = OUStringBuffer( 128 );
//         bufferQuoteQualifiedIdentifier( buf, schemaName, tableName );
//         bufferQuoteIdentifier( buf, futureColumnName );
// //        bufferQuoteConstant( buf, defaultValue, encoding );
//         buf = OUStringBuffer( 128 );
//         bufferQuoteQualifiedIdentifier( buf, schemaName, tableName );
//         bufferQuoteIdentifier( buf, futureColumnName );
//         buf = OUStringBuffer( 128 );
//         bufferQuoteQualifiedIdentifier( buf, schemaName, tableName , futureColumnName );
//         bufferQuoteConstant( buf, futureComment,encoding);
//         OUStringBuffer buf( 128 );
//     bufferQuoteQualifiedIdentifier( update, m_schemaName, m_tableName );


4 / 50 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_xindexcolumns.cxx
//         OUStringBuffer buf( 128 );
//         buf.append( m_schemaName );
//         OUStringBuffer buf( 128 );
//     bufferQuoteQualifiedIdentifier( update, m_schemaName, m_tableName );


1 / 9 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_xindex.cxx
//              m_refMutex, m_conn, m_pSettings, m_schemaName,


4 / 71 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_tools.cxx
// (X/Open SQL CLI, March 1995, ISBN: 1-85912-081-4, X/Open Document Number: C451)
//                     OUStringBuffer buf;
//         printf( "found %d\n" , rtl_ustr_toInt32( &str.pData->buffer[start], 10 ));
//     printf( "found %d\n" , rtl_ustr_toInt32( &str.pData->buffer[start], 10 ));


10 / 175 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_xcolumns.cxx
//         const OUString & schema,
//         m_schema ( schema ),
//         OUStringBuffer buf( 128 );
//         bufferQuoteQualifiedIdentifier( buf, m_schema, m_table , m_column );
//         bufferQuoteConstant( buf, comment,m_pSettings->encoding);
//                     m_schemaName,
//         OUStringBuffer buf(128);
//        bufferQuoteConstant( buf, defaultValue, encoding );
//         OUStringBuffer buf( 128 );
//         buf.append( m_schemaName );


1 / 14 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_xcontainer.cxx
//         buf.append( m_schemaName );


1 / 30 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_resultsetmetadata.cxx
//     OUString schemaTableName;


2 / 46 | libreoffice-4.4.0.3/connectivity/source/drivers/postgresql/pq_updateableresultset.cxx
//             bufferQuoteConstant( buf, val ):
//     OStringBuffer buf( 20 );


4 / 41 | libreoffice-4.4.0.3/connectivity/source/drivers/file/FDatabaseMetaData.cxx
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/
/*schemaPattern*/


10 / 47 | libreoffice-4.4.0.3/connectivity/source/commontools/TDatabaseMetaDataBase.cxx
/*schema*/
/*schema*/
/*schema*/
/*schema*/
/*schema*/
/*schemaPattern*/
/*schemaPattern*/
/*schema*/
/*schema*/
/*schema*/


1 / 106 | libreoffice-4.4.0.3/connectivity/source/commontools/parameters.cxx
// #i63674# / 2006-03-28 / frank.schoenheit@sun.com


1 / 9 | libreoffice-4.4.0.3/connectivity/source/commontools/TSortIndex.cxx
// Sortierung:


2 / 161 | libreoffice-4.4.0.3/connectivity/source/parse/sqliterator.cxx
// #i77635# - 2007-07-23 / frank.schoenheit@sun.com
// SELECT column[,column] oder SELECT COUNT(*) ...


1 / 176 | libreoffice-4.4.0.3/connectivity/source/parse/sqlnode.cxx
// #i69227# / 2006-10-10 / frank.schoenheit@sun.com


3 / 31 | libreoffice-4.4.0.3/mysqlc/source/mysqlc_databasemetadata.cxx
/* schemaPattern */
/* schema */
/* schemaPattern */


2 / 215 | libreoffice-4.4.0.3/basegfx/source/polygon/b2dpolygonclipper.cxx
//const size_t nBufferSize = sizeof(vertex)*(nVertexCount*16);
//vertex *pVertices = (vertex*)alloca(nBufferSize);


1 / 37 | libreoffice-4.4.0.3/scripting/source/dlgprov/dlgevtatt.cxx
// Methode ansprechen


1 / 79 | libreoffice-4.4.0.3/comphelper/source/misc/syntaxhighlight.cxx
// Naechstes Zeichen holen


1 / 7 | libreoffice-4.4.0.3/comphelper/source/misc/types.cxx
// beides AnyWerte


1 / 17 | libreoffice-4.4.0.3/comphelper/source/misc/threadpool.cxx
//    http://www.cs.wustl.edu/~schmidt/win32-cv-1.html


1 / 55 | libreoffice-4.4.0.3/comphelper/source/property/opropertybag.cxx
// #i78593# / 2007-07-07 / frank.schoenheit@sun.com


2 / 8 | libreoffice-4.4.0.3/comphelper/source/property/property.cxx
// gefunden ?
// gefunden ?


1 / 6 | libreoffice-4.4.0.3/comphelper/source/streaming/basicio.cxx
// schreiben des Fontdescriptors


1 / 7 | libreoffice-4.4.0.3/comphelper/source/streaming/oslfile2streamwrap.cxx
// Wenn gelesene Zeichen < MaxLength, css::uno::Sequence anpassen


11 / 17 | libreoffice-4.4.0.3/sot/source/base/factory.cxx
/*************************************************************************
|*    SotData_Impl::SotData_Impl
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SOTDATA()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotFactory::SotFactory()
|*
|*    Beschreibung
*************************************************************************/
// muss nach hinten, wegen Reihenfolge beim zerstoeren
/*************************************************************************
|*    SotFactory::Find()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotFactory::PutSuperClass()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotFactory::IncSvObjectCount()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotFactory::DecSvObjectCount()
|*
|*    Beschreibung
*************************************************************************/
//keine internen und externen Referenzen mehr
/*************************************************************************
|*    SotFactory::CreateInstance()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotFactory::Is()
|*
|*    Beschreibung
*************************************************************************/


1 / 13 | libreoffice-4.4.0.3/sot/source/base/filelist.cxx
/*************************************************************************
|*
|*    FileList - Zuweisungsoperator
|*
\*************************************************************************/


7 / 23 | libreoffice-4.4.0.3/sot/source/base/formats.cxx
/*
    Fuer jedes Ziel existiert in der Tabelle genau ein SotDestinationEntry_Impl.
    Dieser Eintrag enthaelt u.a. fuer jedes vom Ziel auswertbare Format eine
    Default-Action. Die Default-Aktionen verweisen fuer jedes Format auf
    die auszuwertende Tabelle, d.h. sie enthalten nur EXCHG_IN_ACTION_MOVE,
    EXCHG_IN_ACTION_COPY oder EXCHG_IN_ACTION_LINK. Entsprechend dieser Aktion
    ist dann aMoveActions, aCopyActions oder aLinkActions auszuwerten.
    Die Aktionen sind nach Prioritaet sortiert, d.h. je "wichtiger" das
    Format ist, desto eher erscheint es in der Liste.
*/
/*
    Ueber diese Tabelle erfolgt die Zuordnung von Destination, vorhandenen
    Datenformaten sowie gewuenschter Aktion zu einer Aktion und dem in
    ihr zu benutzenden Datenformat. Die Tabelle ist nach den Exchange-Zielen
    (EXCHG_DEST_*) sortiert. Innerhalb des Zieleintrages befinden sich genau
    vier Tabellen fuer Default-, Move-, Copy- und Linkaktionen. Ueber
    die Default-Tabelle erfolgt das Mapping zwischen Default-Aktion
     (DropEvent::IsDefaultAction()) und daraus resultierender wirklicher
    Aktion. Diese Tabelle enthaelt deshalb nur die Aktionen
     EXCHG_IN_ACTION_COPY, EXCHG_IN_ACTION_MOVE und EXCHG_IN_ACTION_LINK,
    die auf die spezielle Tabelle verweisen. Die uebrigen Tabellen
    koennen beliebige Aktionen enthalten. Jede Tabelle ist nach der
    Format-Prioritaet sortiert. Eintrag Null hat die hoechste Prioritaet.
*/
// hier wird jetzt die oben definierte Tabelle "implementiert"
//Todo: Binaere Suche einbauen
/* Behandlung der Default-Action nach folgender Vorgehensweise:

       - Das Ziel wird nach der Default-Action gefragt
       - Unterstuetzt die Quelle diese Aktion so wird sie uebernommen
       - Anderenfalls wird aus den von der Quelle zur Verfuegung gestellten
         Aktionen eine ausgewaehlt, die zu einer moeglichst nicht leeren
          Ergebnisaktion fuehrt. Hierbei wird in dieser Reihenfolge
          vorgegangen: Copy -> Link -> Move
    */
// Unterstuetzt die Quelle die Aktion?
// Nein -> Alle Aktionen der Quelle checken


14 / 172 | libreoffice-4.4.0.3/sot/source/base/exchange.cxx
/*
    In diesen Tabellen stehen alle im Office verwendeten MimeTypes,
    Format-Bezeichner und Types.
    Die Tabelle ist nach den Formatstring-Ids sortiert und jede Id
    ist um genau 1 groesser als ihre Vorgaenger-Id, damit die Id als
    Tabellenindex benutzt werden kann.
*/
/*************************************************************************
|*
|*    SotExchange::RegisterFormatName()
|*
|*    Beschreibung      CLIP.SDW
*************************************************************************/
// teste zuerst die Standard - Name
// dann in der dynamischen Liste
// nMax ist der neue Platz
// teste zuerst die Standard - Name
// dann in der dynamischen Liste
// nMax ist der neue Platz
/*************************************************************************
|*
|*    SotExchange::RegisterFormatName()
|*
|*    Beschreibung      CLIP.SDW
*************************************************************************/
// dann in der dynamischen Liste
/*************************************************************************
|*
|*    SotExchange::GetFormatName()
|*
|*    Beschreibung      CLIP.SDW
*************************************************************************/
// teste zuerst die Standard - Name
// dann in der dynamischen Liste
/*************************************************************************
|*
|*    SotExchange::GetFormatName()
|*
|*    Beschreibung      CLIP.SDW
*************************************************************************/


3 / 9 | libreoffice-4.4.0.3/sot/source/base/object.cxx
/*************************************************************************
|*    SotObject::SotObject()
|*
|*    Beschreibung
*************************************************************************/
/*************************************************************************
|*    SotObject::GetInterface()
|*
|*    Beschreibung: Um so3 zu helfen
*************************************************************************/
/*  [Beschreibung]

    Wenn der OwnerLock auf Null dekrementiert, dann wird die Methode
    DoClose gerufen. Dies geschieht unabh"angig vom Lock. bzw. RefCount.
    Ist der OwnerLock-Z"ahler != Null, dann wird kein DoClose durch
    <SotObject::FuzzyLock> gerufen.
*/


4 / 19 | libreoffice-4.4.0.3/sot/source/sdstor/stgio.cxx
//Stream zu lang
//Stream zu kurz
// letzter Block bei Stream ohne Laenge
//  OSL_FAIL("Validiere nicht (kein FileStorage)");


1 / 342 | libreoffice-4.4.0.3/sot/source/sdstor/ucbstorage.cxx
// Wenn gelesene Zeichen < MaxLength, Sequence anpassen


1 / 54 | libreoffice-4.4.0.3/sot/source/sdstor/stgavl.cxx
// OS 22.09.95: Auf MD's Wunsch auskommentiert wg. Absturz


3 / 105 | libreoffice-4.4.0.3/sot/source/sdstor/stgdir.cxx
// Problem der Implementation: Keine Hierarchischen commits. Daher nur
// insgesamt transaktionsorientert oder direkt.
// (TLX:??? Zumindest pStgStrm muss deleted werden.)


12 / 42 | libreoffice-4.4.0.3/sot/source/sdstor/storage.cxx
// ??? wenn Init virtuell ist, entsprechen setzen
// ans Ende setzen
// alle Daten schreiben
// Wenn Ole2 oder nicht nur eigene StorageStreams
/************************************************************************
|*
|*    SotStorage::SotStorage()
|*
|*    Beschreibung      Es muss ein I... Objekt an SvObject uebergeben
|*                      werden, da es sonst selbst ein IUnknown anlegt und
|*                      festlegt, dass alle weiteren I... Objekte mit
|*                      delete zerstoert werden (Owner() == true).
|*                      Es werden aber nur IStorage Objekte benutzt und nicht
|*                      selbst implementiert, deshalb wird so getan, als ob
|*                      das IStorage Objekt von aussen kam und es wird mit
|*                      Release() freigegeben.
|*                      Die CreateStorage Methoden werden benoetigt, um
|*                      ein IStorage Objekt vor dem Aufruf von SvObject
|*                      zu erzeugen (Own, !Own automatik).
|*                      Hat CreateStorage ein Objekt erzeugt, dann wurde
|*                      der RefCounter schon um 1 erhoet.
|*                      Die Uebergabe erfolgt in pStorageCTor. Die Variable
|*                      ist NULL, wenn es nicht geklappt hat.
|*
*************************************************************************/
// Storage vorher freigeben
// volle Ole-Patches einschalten
// kein Fehler setzen
// kein Fehler setzen
// ein bisschen schneller
// ein bisschen schneller
// ein bisschen schneller


7 / 169 | libreoffice-4.4.0.3/sot/source/sdstor/stgstrms.cxx
// Anzahl der Masterpages, durch die wir iterieren muessen
// Offset in letzter Masterpage
// Verkettung herstellen
// Platz fuer Masterpage schaffen
// Selbst Platz schaffen
// Anzahl der Masterpages, durch die wir iterieren muessen
// Offset in letzter Masterpage


1 / 39 | libreoffice-4.4.0.3/sot/source/sdstor/stgcache.cxx
// SvStream "Feature" Write Open auch erfolgreich, wenns nicht klappt


1 / 13 | libreoffice-4.4.0.3/sot/source/sdstor/storinfo.cxx
// SV und Win stimmen ueberein (bis einschl. FORMAT_GDIMETAFILE)


1 / 28 | libreoffice-4.4.0.3/canvas/source/directx/dx_spritehelper.cxx
// background buffer.


1 / 113 | libreoffice-4.4.0.3/canvas/source/cairo/cairo_canvashelper.cxx
// longest line in gradient bound rect


1 / 75 | libreoffice-4.4.0.3/canvas/source/tools/canvastools.cxx
// longest line in gradient bound rect


1 / 6 | libreoffice-4.4.0.3/canvas/source/vcl/backbuffer.hxx
/// Background buffer abstraction


1 / 22 | libreoffice-4.4.0.3/configmgr/source/xcsparser.cxx
//TODO: ignoring component-schema import, component-schema uses, and


2 / 13 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/QueryDesignFieldUndoAct.hxx
// geloeschte Spaltenbeschreibung
// OTabFieldDelUndoAct - Undo-Klasse fuer Anlegen eines Feldes


2 / 142 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/SelectionBrowseBox.cxx
// Neuzeichnen
// * durch alias.* ersetzen


3 / 235 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/QueryDesignView.cxx
// Bedingung parsen
// ----------------- Kriterien aufbauen ----------------------
// --------------------- Limit Clause -------------------


1 / 116 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/QueryTableView.cxx
// OQueryTableConnectionData aufbauen


1 / 5 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/QueryMoveTabWinUndoAct.hxx
// OQueryMoveTabWinUndoAct - Undo-Klasse fuer Verschieben eines TabWins


2 / 6 | libreoffice-4.4.0.3/dbaccess/source/ui/querydesign/QueryAddTabConnUndoAction.hxx
// OQueryAddTabConnUndoAction - Undo-Klasse fuer Einfuegen einer Connection
// OQueryDelTabConnUndoAction - Undo-Klasse fuer Einfuegen einer Connection


2 / 7 | libreoffice-4.4.0.3/dbaccess/source/ui/inc/GeneralUndo.hxx
// SbaCommentUndoAction - Undo-Basisklasse fuer Aktionen, deren GetComment einen aus einer Sba-Resource
// geladenen String liefert


7 / 20 | libreoffice-4.4.0.3/dbaccess/source/ui/inc/browserids.hxx
// Spaltenformatierung
// Spaltenbreite
// Zeilenhoehe
// Funktionen anzeigen
// Tabellennamen anzeigen
// Aliasnamen anzeigen
// Distinct anzeigen


1 / 28 | libreoffice-4.4.0.3/dbaccess/source/ui/dlg/queryfilter.cxx
// e.g. <schema>.<table> becomes "<schema>"."<table>"


2 / 19 | libreoffice-4.4.0.3/dbaccess/source/ui/dlg/RelationDlg.cxx
//// wenn die ComboBoxen fuer die Tabellenauswahl enabled sind (Constructor mit bAllowTableSelect==sal_True), dann muss ich in die
//// Connection auch die Tabellennamen stecken


2 / 220 | libreoffice-4.4.0.3/dbaccess/source/ui/browser/brwctrlr.cxx
// das aktuelle Control committen lassen
// zunaechst das Control fragen ob es das IFace unterstuetzt


1 / 13 | libreoffice-4.4.0.3/dbaccess/source/ui/uno/ColumnModel.hxx
// UNO Anbindung


1 / 14 | libreoffice-4.4.0.3/dbaccess/source/ui/misc/WNameMatch.cxx
// urspr"unglichen zustand wiederherstellen


2 / 13 | libreoffice-4.4.0.3/dbaccess/source/ui/misc/DExport.cxx
// Text "uberschreibt alles
// Text "uberschreibt alles


1 / 117 | libreoffice-4.4.0.3/dbaccess/source/ui/tabledesign/TEditControl.cxx
// Maximum length in description field


6 / 18 | libreoffice-4.4.0.3/dbaccess/source/ui/tabledesign/TableDesignView.cxx
// Children erzeugen
// Splitter einrichten
// Abmessungen parent window
// Verschiebebereich Splitter mittleres Drittel des Outputs
// Splitter setzen
// Fenster setzen


1 / 6 | libreoffice-4.4.0.3/dbaccess/source/ui/tabledesign/TableDesignHelpBar.cxx
// Abmessungen parent window


2 / 14 | libreoffice-4.4.0.3/dbaccess/source/ui/control/TableGrantCtrl.cxx
// Spalten einfuegen
// Browser Mode setzen


2 / 33 | libreoffice-4.4.0.3/dbaccess/source/ui/control/tabletree.cxx
//   +- schema
//   schema


1 / 5 | libreoffice-4.4.0.3/dbaccess/source/ui/relationdesign/RTableConnection.hxx
// wichtiger Kommentar zum CopyConstructor siehe OTableConnection(const OTableConnection&)


2 / 114 | libreoffice-4.4.0.3/basic/source/inc/filefmt.hxx
//  sal_uInt16 1. Zeile (Sub XXX)
//  sal_uInt16 2. Zeile (End Sub)


2 / 107 | libreoffice-4.4.0.3/basic/source/inc/opcodes.hxx
// Verzweigungen
// Verwaltung


1 / 23 | libreoffice-4.4.0.3/basic/source/runtime/dllmgr-x86.cxx
// For DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)


1 / 170 | libreoffice-4.4.0.3/basic/source/runtime/methods1.cxx
// Dienstag, 21. December 2004


2 / 557 | libreoffice-4.4.0.3/basic/source/runtime/runtime.cxx
// Verzweigen
// Verwaltung


1 / 26 | libreoffice-4.4.0.3/basic/source/runtime/dllmgr-x64.cxx
// For DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)


1 / 203 | libreoffice-4.4.0.3/basic/source/classes/sbxmod.cxx
// RefCount vom Modul hochzaehlen


1 / 66 | libreoffice-4.4.0.3/basic/source/comp/basiccharclass.cxx
// Ã , SMALL LETTER SHARP S


1 / 40 | libreoffice-4.4.0.3/basic/source/comp/codegen.cxx
// Die Entrypoints:


6 / 308 | libreoffice-4.4.0.3/scaddins/source/analysis/analysishelper.cxx
// Anschaffungskosten - Restwert - Summe aller Abschreibungen
// Fahrenheit
// Fahrenheit also
// *** austr. Schooner
// *** austr. Middy
// *** austr. Glass


1 / 14 | libreoffice-4.4.0.3/reportdesign/inc/RptObject.hxx
// Clone() soll eine komplette Kopie des Objektes erzeugen.


1 / 4 | libreoffice-4.4.0.3/reportdesign/source/core/sdr/ReportDrawPage.cxx
/**************************************************
                * Das leere OLE-Objekt bekommt ein neues IPObj
                **************************************************/


1 / 66 | libreoffice-4.4.0.3/reportdesign/source/core/sdr/RptObject.cxx
// Clone() soll eine komplette Kopie des Objektes erzeugen.


2 / 31 | libreoffice-4.4.0.3/reportdesign/source/core/sdr/UndoEnv.cxx
// neues Object zum lauschen
// am Container horchen


1 / 6 | libreoffice-4.4.0.3/reportdesign/source/ui/inc/dlgpage.hxx
/*************************************************************************
|*
|* Seite einrichten-Tab-Dialog
|*
\************************************************************************/


7 / 27 | libreoffice-4.4.0.3/reportdesign/source/ui/dlg/Navigator.cxx
// die Position, an der der DropTimer angeschaltet wurde
// die Stelle, an der geklickt wurde
// auf dem ersten Eintrag ?
// neu anfangen zu zaehlen
// die Pos merken, da ich auch AcceptDrops bekomme, wenn sich die Maus gar nicht bewegt hat
// und den Timer los
// gibt es den Timer schon ?


1 / 5 | libreoffice-4.4.0.3/reportdesign/source/ui/dlg/dlgpage.cxx
/*************************************************************************
|*
|* Konstruktor des Tab-Dialogs: Fuegt die Seiten zum Dialog hinzu
|*
\************************************************************************/


1 / 33 | libreoffice-4.4.0.3/reportdesign/source/ui/dlg/AddField.cxx
// ListBox loeschen


2 / 17 | libreoffice-4.4.0.3/reportdesign/source/ui/dlg/Formula.cxx
//      Initialisierung / gemeinsame Funktionen  fuer Dialog
//                          Funktionen fuer rechte Seite


2 / 39 | libreoffice-4.4.0.3/reportdesign/source/ui/dlg/GroupsSorting.cxx
// Font fuer die Ueberschriften auf Light setzen
// die Basisklasse braucht den Aufruf, da sie sich dort merkt, welche Zeile gepainted wird


1 / 105 | libreoffice-4.4.0.3/reportdesign/source/ui/report/ReportController.cxx
// Anhand des FormatKeys wird festgestellt, welches Feld benoetigt wird


1 / 17 | libreoffice-4.4.0.3/reportdesign/source/ui/report/DesignView.cxx
// Splitter einrichten


1 / 18 | libreoffice-4.4.0.3/reportdesign/source/ui/report/ReportControllerObserver.cxx
// neues Object zum lauschen


1 / 34 | libreoffice-4.4.0.3/reportdesign/source/ui/report/ViewsWindow.cxx
// einzelnes Obj an der Seite ausrichten


1 / 4 | libreoffice-4.4.0.3/reportdesign/source/ui/report/StartMarker.cxx
// Hilfe anzeigen


3 / 14 | libreoffice-4.4.0.3/reportdesign/source/ui/inspection/metadata.cxx
// Vergleichen von PropertyInfo
// intialisierung
// intialisierung


1 / 31 | libreoffice-4.4.0.3/sdext/source/minimizer/optimizerdialog.cxx
// generating default file name


1 / 18 | libreoffice-4.4.0.3/sdext/source/pdfimport/filterdet.cxx
// search document checksum entry


1 / 19 | libreoffice-4.4.0.3/xmlhelp/source/cxxhelp/provider/provider.cxx
// Wrong URL-scheme


1 / 70 | libreoffice-4.4.0.3/xmlhelp/source/cxxhelp/provider/databases.cxx
// Check language scheme


1 / 81 | libreoffice-4.4.0.3/fpicker/source/win32/folderpicker/MtaFop.cxx
/*
        Flag                Available
        --------------------------------
        BIF_EDITBOX         Version 4.71
        BIF_NEWDIALOGSTYLE  Version 5.0
        BIF_SHAREABLE       Version 5.0
        BIF_VALIDATE        Version 4.71

        Version 4.71 - Internet Explorer 4.0
        Version 5.0  - Internet Explorer 5.0
                       Windows 2000
    */


1 / 63 | libreoffice-4.4.0.3/svgio/inc/svgio/svgreader/svgstyleattributes.hxx
/// StrokeMiterLimit content


1 / 164 | libreoffice-4.4.0.3/linguistic/source/gciterator.cxx
// mark found errors...


1 / 16 | libreoffice-4.4.0.3/ucb/source/ucp/ext/ucpext_provider.cxx
// Check URL scheme...


1 / 16 | libreoffice-4.4.0.3/ucb/source/ucp/tdoc/tdoc_uri.cxx
// Remember normalized scheme string.


1 / 72 | libreoffice-4.4.0.3/ucb/source/ucp/tdoc/tdoc_docmgr.cxx
// 2011-02-23 / frank.schoenheit@sun.com


6 / 91 | libreoffice-4.4.0.3/ucb/source/ucp/gvfs/gvfs_content.cxx
// <scheme>://              -> ""
// <scheme>://foo           -> ""
// <scheme>://foo/          -> ""
// <scheme>://foo/bar       -> <scheme>://foo/
// <scheme>://foo/bar/      -> <scheme>://foo/
// <scheme>://foo/bar/abc   -> <scheme>://foo/bar/


6 / 371 | libreoffice-4.4.0.3/ucb/source/ucp/webdav/webdavcontent.cxx
// <scheme>://              -> ""
// <scheme>://foo           -> ""
// <scheme>://foo/          -> ""
// <scheme>://foo/bar       -> <scheme>://foo/
// <scheme>://foo/bar/      -> <scheme>://foo/
// <scheme>://foo/bar/abc   -> <scheme>://foo/bar/


1 / 17 | libreoffice-4.4.0.3/ucb/source/ucp/webdav/webdavprovider.cxx
// Check URL scheme...


6 / 338 | libreoffice-4.4.0.3/ucb/source/ucp/webdav-neon/webdavcontent.cxx
// <scheme>://              -> ""
// <scheme>://foo           -> ""
// <scheme>://foo/          -> ""
// <scheme>://foo/bar       -> <scheme>://foo/
// <scheme>://foo/bar/      -> <scheme>://foo/
// <scheme>://foo/bar/abc   -> <scheme>://foo/bar/


1 / 18 | libreoffice-4.4.0.3/ucb/source/ucp/webdav-neon/webdavprovider.cxx
// Check URL scheme...


1 / 7 | libreoffice-4.4.0.3/forms/source/richtext/richtextunowrapper.cxx
// Propertymap fuer einen Outliner Text


1 / 56 | libreoffice-4.4.0.3/forms/source/xforms/model.hxx
/// xforms:model/@schema attribute


3 / 38 | libreoffice-4.4.0.3/forms/source/component/ListBox.hxx
// UNO Anbindung
// UNO Anbindung
// UNO Anbindung


2 / 72 | libreoffice-4.4.0.3/forms/source/component/DatabaseForm.hxx
//  <overwritten_properties>
//  </overwritten_properties>


2 / 28 | libreoffice-4.4.0.3/forms/source/component/ImageControl.hxx
// UNO Anbindung
// UNO Anbindung


1 / 21 | libreoffice-4.4.0.3/forms/source/component/EventThread.hxx
// UNO Anbindung


8 / 93 | libreoffice-4.4.0.3/stoc/test/testintrosp.cxx
// Das 2^6-Bit steht fuer "den Rest"
// Wieviele Methoden sollten es sein
// Methoden-Array ausgeben
// Methode ansprechen
// Methode ausgeben
// Naechste Passende Methode in der Liste suchen
// Checken, ob alle Methoden auch einzeln gefunden werden
// Methode ansprechen


1 / 131 | libreoffice-4.4.0.3/stoc/source/servicemanager/servicemanager.cxx
// merken, es wird nur einmal gesucht


183 / 351 | libreoffice-4.4.0.3/stoc/source/inspect/introspection.cxx
// Handelt es sich bei dem uebergebenen Objekt ueberhaupt um was passendes?
// Haben wir ein FastPropertySet und ein gueltiges Handle?
// ACHTUNG: An dieser Stelle wird ausgenutzt, dass das PropertySet
// zu Beginn des Introspection-Vorgangs abgefragt wird.
// sonst eben das normale nehmen
// get-Methode gibt es nicht
// Hilfs-Methoden zur Groessen-Anpassung der Sequences
// Neue Groesse mit ARRAY_SIZE_STEP abgleichen
// Neue Impl-Klasse im Rahmen der Introspection-Umstellung auf Instanz-gebundene
// Introspection mit Property-Zugriff ueber XPropertySet. Die alte Klasse
// Untersuchtes Objekt
// Statische Daten der Introspection
// Letzte Sequence, die bei getProperties geliefert wurde (Optimierung)
// Letzte Sequence, die bei getMethods geliefert wurde (Optimierung)
// Methoden von XIntrospectionAccess
// Methoden von XMaterialHolder
// Methoden von XExactName
// Objekt als Interface merken, wenn moeglich
// Neue Impl-Klasse im Rahmen der Introspection-Umstellung auf Instanz-gebundene
// Introspection mit Property-Zugriff ueber XPropertySet. Die alte Klasse
// Untersuchtes Objekt
// Statische Daten der Introspection
// Methoden von XInterface
// Methoden von XPropertySet
// Methoden von XFastPropertySet
// Methoden von XPropertySetInfo
// Methoden von XElementAccess
// Methoden von XNameAccess
// Methoden von XNameContainer
// Methoden von XIndexAccess
// Methoden von XIndexContainer
// Methoden von XEnumerationAccess
// Methoden von XIdlArray
// Methoden von XInterface
// Wrapper fuer die Objekt-Interfaces
//*** Implementation von ImplIntrospectionAdapter ***
// Methoden von XPropertySet
// Methoden von XFastPropertySet
// Methoden von XPropertySetInfo
// Methoden von XElementAccess
// Methoden von XNameAccess
// Methoden von XNameContainer
// Methoden von XIndexAccess
// Methoden von XIndexContainer
// Methoden von XEnumerationAccess
// Methoden von XIdlArray
//*** Implementation von ImplIntrospectionAccess ***
// Methoden von XIntrospectionAccess
// Wenn alle unterstuetzten Konzepte gefordert werden, Sequence einfach durchreichen
// Gleiche Sequence wie beim vorigen mal?
// Anzahl der zu liefernden Properties
// Es gibt zur Zeit keine DANGEROUS-Properties
// Sequence entsprechend der geforderten Anzahl reallocieren
// const umgehen
// Alle Properties durchgehen und entsprechend der Concepte uebernehmen
// Zusammengebastelte Sequence liefern
// const umgehen
// Wenn alle unterstuetzten Konzepte gefordert werden, Sequence einfach durchreichen
// Gleiche Sequence wie beim vorigen mal?
// Sequence entsprechend der geforderten Anzahl reallocieren
// Anders als bei den Properties kann die Anzahl nicht durch
// Zaehler in inspect() vorher ermittelt werden, da Methoden
// mehreren Konzepten angehoeren koennen
// Alle Methods durchgehen und entsprechend der Concepte uebernehmen
// Methode mit Concepts ausgeben
// Auf die richtige Laenge bringen
// Zusammengebastelte Sequence liefern
// Gibt es schon einen Adapter?
// Methoden von XMaterialHolder
// Hilfs-Funktion zur LowerCase-Wandlung eines OUString
// Methoden von XExactName
// Objekt untersuchen
// Interface aus dem Any besorgen
// Pointer auf ggf. noetige neue IntrospectionAccess-Instanz
// Pruefen: Ist schon ein passendes Access-Objekt gecached?
// Jetzt versuchen, das PropertySetInfo zu bekommen
// Kein Access gecached -> neu anlegen
// Referenzen auf wichtige Daten von pAccess
// Schon mal Pointer auf das eigene Property-Feld holen
//*** Analyse vornehmen ***
// Zunaechst nach speziellen Interfaces suchen, die fuer
// die Introspection von besonderer Bedeutung sind.
// XPropertySet vorhanden?
// Gibt es auch ein FastPropertySet?
// Bei FastPropertySet muessen wir uns die Original-Handles merken
// Property in eigene Liste uebernehmen
// PropCount als Handle fuer das eigene FastPropertySet eintragen
// Namen in Hashtable eintragen, wenn nicht schon bekannt
// Haben wir den Namen schon?
// Neuer Eintrag in die Hashtable
// Indizes in die Export-Tabellen
// Flag, ob XInterface-Methoden erfasst werden sollen
// (das darf nur einmal erfolgen, initial zulassen)
// Flag, ob die XInterface-Methoden schon erfasst wurden. Wenn sal_True,
// wird bXInterfaceIsInvalid am Ende der Iface-Schleife aktiviert und
// XInterface-Methoden werden danach abgeklemmt.
// In eigenes Property-Array eintragen
// Namen in Hashtable eintragen
// Haben wir den Namen schon?
// Neuer Eintrag in die Hashtable
// Zaehler fuer die gefundenen Listener
// Alle Methoden holen und merken
// 3. a) get/set- und Listener-Methoden suchen
// Feld fuer Infos ueber die Methoden anlegen, damit spaeter leicht die Methoden
// gefunden werden koennen, die nicht im Zusammenhang mit Properties oder Listenern
// stehen. NEU: auch MethodConceptArray initialisieren
// normale Methode, kein Bezug zu Properties oder Listenern
// gehoert zu einer get/set-Property
// add-Methode einer Listener-Schnittstelle
// remove-Methode einer Listener-Schnittstelle
// Methode, deren Klasse nicht beruecksichtigt wird, z.B. XPropertySet
// Methode ansprechen
// Methoden katalogisieren
// Alle (?) Methoden von XInterface filtern, damit z.B. nicht
// vom Scripting aus acquire oder release gerufen werden kann
// Wenn der Name zu kurz ist, wird's sowieso nichts
// Ist es eine get-Methode?
// get-Methode darf keinen Parameter haben
// Haben wir den Namen schon?
// Eine readonly-Property ist es jetzt mindestens schon
// In eigenes Property-Array eintragen
// Neuer Eintrag in die Hashtable
// Passende set-Methode suchen
// Methode ansprechen
// Nur Methoden nehmen, die nicht schon zugeordnet sind
// Name holen und auswerten
// ACHTUNG: Wegen SDL-Bug NICHT != bei OUString verwenden !!!
// Ist es denn der gleiche Name?
// ACHTUNG: Wegen SDL-Bug NICHT != bei OUString verwenden !!!
// set-Methode darf nur einen Parameter haben
// Jetzt muss nur noch der return-Typ dem Parameter-Typ entsprechen
// ReadOnly-Flag wieder loschen
// Ist es eine addListener-Methode?
// Endet das Teil auf Listener?
// ACHTUNG: Wegen SDL-Bug NICHT != bei OUString verwenden !!!
// TODO: Hier koennten noch genauere Pruefungen vorgenommen werden
// - Anzahl und Art der Parameter
// Passende remove-Methode suchen, sonst gilt's nicht
// Methode ansprechen
// Nur Methoden nehmen, die nicht schon zugeordnet sind
// Name holen und auswerten
// ACHTUNG: Wegen SDL-Bug NICHT != bei OUString verwenden !!!
// Ist es denn der gleiche Listener?
// ACHTUNG: Wegen SDL-Bug NICHT != bei OUString verwenden !!!
// TODO: Hier koennten noch genauere Pruefungen vorgenommen werden
// - Anzahl und Art der Parameter
// Methoden sind als Listener-Schnittstelle erkannt
// Jetzt koennen noch SET-Methoden ohne zugehoerige GET-Methode existieren,
// diese muessen zu Write-Only-Properties gemachte werden.
// Methode ansprechen
// Nur Methoden nehmen, die nicht schon zugeordnet sind
// Wenn der Name zu kurz ist, wird's sowieso nichts
// Ist es eine set-Methode ohne zugehoerige get-Methode?
// set-Methode darf nur einen Parameter haben
// Haben wir den Namen schon?
// Alles klar, es ist eine Write-Only-Property
// In eigenes Property-Array eintragen
// Neuer Eintrag in die Hashtable
// 4. Methoden in die Gesamt-Sequence uebernehmen
// Sequences im Access-Objekt entsprechend aufbohren
// Methoden reinschreiben
// Methode ansprechen
// Namen in Hashtable eintragen, wenn nicht schon bekannt
// Eintragen
// Wenn kein Concept gesetzt wurde, ist die Methode "normal"
// void als Default-Klasse eintragen
// 1. Moeglichkeit: Parameter nach einer Listener-Klasse durchsuchen
// Nachteil: Superklassen muessen rekursiv durchsucht werden
// Sind wir von einem Listener abgeleitet?
// 2. Moeglichkeit: Namen der Methode auswerden
// Nachteil: geht nicht bei Test-Listenern, die es nicht gibt
// Wenn in diesem Durchlauf XInterface-Methoden
// dabei waren, diese zukuenftig ignorieren
// Super-Klasse(n) vorhanden? Dann dort fortsetzen
// Zur Zeit wird nur von einer Superklasse ausgegangen
// Anzahl der exportierten Methoden uebernehmen und Sequences anpassen
// (kann abweichen, weil doppelte Methoden erst nach der Ermittlung
//  von nExportedMethodCount herausgeworfen werden)
// Bei structs Fields als Properties registrieren
// Ist es ein Interface oder eine struct?
// In eigenes Property-Array eintragen
// Namen in Hashtable eintragen
// Property-Sequence auf die richtige Laenge bringen


9 / 92 | libreoffice-4.4.0.3/stoc/source/invocation/invocation.cxx
// TODO: Zentral implementieren
// Methoden von XMaterialHolder
// AB, 12.2.1999  Sicherstellen, dass das Material wenn moeglich
// aus der direkten Invocation bzw. von der Introspection geholt
// wird, da sonst Structs nicht korrekt behandelt werden
// Ersteinmal alles ausserhalb des guards machen
// Invocation ueber die Introspection machen
// bei Vorhandensein ersetzen, ansonsten einfuegen
// optionalen Parameter Index hinzufuegen


1 / 58 | libreoffice-4.4.0.3/editeng/qa/unit/core-test.cxx
// being empty.


1 / 100 | libreoffice-4.4.0.3/editeng/source/uno/unotext.cxx
// '\r' geht auf'm Mac nicht


2 / 242 | libreoffice-4.4.0.3/editeng/source/misc/svxacorr.cxx
// also Attribut setzen:
// Absatz Anfang und kein Blank !


1 / 205 | libreoffice-4.4.0.3/editeng/source/misc/acorrcfg.cxx
//                  case  12: rSwFlags.bChgToEnEmDash = *(sal_Bool*)pValues[nProp].getValue(); break; // "Format/Option/ChangeDash",


2 / 117 | libreoffice-4.4.0.3/editeng/source/editeng/impedit.cxx
// Das Move um den allignten Wert ergibt nicht unbedingt ein
// alligntes Rechteck...


2 / 467 | libreoffice-4.4.0.3/editeng/source/editeng/impedit3.cxx
// "Schiffahrtsbrennesseln" -> "Schifffahrtsbrennnesseln"
// etwas mehr, falls abgerundet!


1 / 286 | libreoffice-4.4.0.3/editeng/source/editeng/impedit4.cxx
// Optimize: No getPos undFindParaportion, instead calculate index!


1 / 130 | libreoffice-4.4.0.3/editeng/source/rtf/rtfitem.cxx
/* setze am akt. auf dem AttrStack stehenden Style die
                       I sit on akt. which is on the immediate style AttrStack */


2 / 114 | libreoffice-4.4.0.3/editeng/source/rtf/svxrtf.cxx
// hier gibts keine Swg-Defines
// hier gibts keine Swg-Defines


1 / 37 | libreoffice-4.4.0.3/toolkit/source/helper/unowrapper.cxx
// System-Windows suchen...


3 / 8 | libreoffice-4.4.0.3/toolkit/source/helper/unopropertyarrayhelper.cxx
// Sortiert nach Namen...
// Einzelproperties...
// koennen jetzt mehr sein


1 / 19 | libreoffice-4.4.0.3/toolkit/source/helper/vclunohelper.cxx
// Kein DONTKNOW


1 / 164 | libreoffice-4.4.0.3/toolkit/source/awt/vclxwindows.cxx
// #i92690# / 2008-08-12 / frank.schoenheit@sun.com


5 / 83 | libreoffice-4.4.0.3/toolkit/source/awt/vclxtoolkit.cxx
// css::awt::XReschedule:
// Wenn die Component einen Parent braucht, dann NULL zurueckgeben,
// Modal/Modeless nur durch Show/Execute
// 07.08.2001 - #87254# - frank.schoenheit@sun.com
// css::awt::XReschedule:


1 / 10 | libreoffice-4.4.0.3/toolkit/source/awt/vclxmenu.cxx
// Selbst eine Ref halten!


2 / 93 | libreoffice-4.4.0.3/toolkit/source/awt/vclxwindow.cxx
// COMMAND_CONTEXTMENU als mousePressed mit PopupTrigger = sal_True versenden...
// #i40647# / 2005-01-18 / frank.schoenheit@sun.com


3 / 209 | libreoffice-4.4.0.3/toolkit/source/controls/unocontrols.cxx
// Items vor der Einfuege-Position
// Rest der alten Items
// Items vor der Entfern-Position


1 / 121 | libreoffice-4.4.0.3/toolkit/source/controls/unocontrol.cxx
// kein TopWindow


3 / 140 | libreoffice-4.4.0.3/tools/source/stream/stream.cxx
// **** Verschluesseln *****
// Buffering in der Basisklasse initialisieren
// Muessen wir Konvertieren


2 / 84 | libreoffice-4.4.0.3/tools/source/rc/resmgr.cxx
// Anfang der Strings suchen
//ans Ende setzen


2 / 345 | libreoffice-4.4.0.3/tools/source/fsys/urlobj.cxx
// Parse <scheme>:
// SMB scheme.


1 / 123 | libreoffice-4.4.0.3/tools/source/generic/poly.cxx
// ggf. FlagArray beruecksichtigen


1 / 10 | libreoffice-4.4.0.3/tools/source/string/tenccvt.cxx
// Latin-15 - Latin 1 mit Euro-Sign


3 / 168 | libreoffice-4.4.0.3/tools/source/inet/inetstrm.cxx
// Soft line break (=<CR><LF>). Emit buffer now.
// Emit buffer.
// if (pWBuf == pData) bDone = false;


1 / 42 | libreoffice-4.4.0.3/soltools/cpp/_macro.c
// Leerzeichen um ## herum entfernen:


1 / 4 | libreoffice-4.4.0.3/soltools/cpp/_nlist.c
/*
    ER: Tabelle extra gross gemacht, da es anscheinend ein Problem mit der
    der Verkettung gibt, irgendwann irgendwo wird mal ein nlist->next
    ueberschrieben, was in eineme SIGSEGV resultiert.
    Den GDB mit watchpoint hab ich aber nach 2 Tagen abgebrochen..
    so loeppt's jedenfalls erstmal..
 */


1 / 21 | libreoffice-4.4.0.3/lotuswordpro/source/filter/utbenvs.cxx
/*BenError Err = */


1 / 25 | libreoffice-4.4.0.3/lotuswordpro/source/filter/bencont.cxx
// String definitions


1 / 15 | libreoffice-4.4.0.3/lotuswordpro/source/filter/xfilter/xfdrawlinestyle.hxx
/**
     * @descr   Set space between dash dot.
     */


1 / 20 | libreoffice-4.4.0.3/external/libpng/configs/pnglibconf.h
/* Copyright (c) 1998-2013 Glenn Randers-Pehrson */


3 / 155 | libreoffice-4.4.0.3/external/redland/raptor/raptor2.h
/**
 * raptor_rdf_schema_namespace_uri:
 *
 * RDF Schema (rdfs:) Namespace URI string.
 */
/**
 * raptor_stringbuffer:
 *
 * Raptor string buffer class
 */
/**
 * raptor_unichar:
 *
 * raptor Unicode codepoint
 */


2 / 110 | libreoffice-4.4.0.3/external/Mesa/inc/GL/gl.h
/* Vertex Arrays */
/*
 * Vertex Arrays  (1.1)
 */


1 / 58 | libreoffice-4.4.0.3/sc/inc/unonames.hxx
//  search descriptor


1 / 11 | libreoffice-4.4.0.3/sc/inc/scdll.hxx
// muss vor LibExit gerufen werden


1 / 169 | libreoffice-4.4.0.3/sc/inc/document.hxx
// FormelRPN im Formelbaum


5 / 20 | libreoffice-4.4.0.3/sc/inc/helpids.h
// Hilfe IDs fuer Dokumentfenster --------------------------------------------
// Hilfe IDs fuer einzelne Controls (max.30) ---------------------------------
//  Eintraege im Navigator
//  Bereich ist voll!
// Hilfe IDs fuer Objekt- und Werkzeugleisten (max.10) -----------------------


1 / 14 | libreoffice-4.4.0.3/sc/inc/autoform.hxx
/*************************************************************************
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Die akt. Struktur der Autoformatierung darf nicht mehr veraendert werden.
    Diese wird durch unterschiedlichen Code vom StartWriter und vom StarCalc
    eingelesen/geschrieben.
    Sollte sich doch mal eine Aenderung nicht vermeiden lassen, dann auf
    jedenfall in beiden Applikationen aendern.

    The structure of table auto formatting should not changed. It is used
    by different code of Writer and Calc. If a change is necessary, the
    source code of both applications must be changed!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
**************************************************************************/


1 / 49 | libreoffice-4.4.0.3/sc/inc/linkuno.hxx
// aus get/setPropertyValue gerufen:


1 / 123 | libreoffice-4.4.0.3/sc/qa/unit/filters-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 533 | libreoffice-4.4.0.3/sc/qa/unit/ucalc_formula.cxx
// Then generate RPN tokens.


1 / 378 | libreoffice-4.4.0.3/sc/qa/unit/opencl-test.cxx
// Verify Ceiling Function


4 / 159 | libreoffice-4.4.0.3/sc/qa/unit/subsequent_export-test.cxx
// dash dot dot
// dash dot
// medium dash dot dot
// medium dash dot


22 / 103 | libreoffice-4.4.0.3/sc/workben/test.cxx
//! das muss als Konstante in irgendeine idl-Datei!!!!
// Calc-Doc suchen
//! temporaer zum Testen !!!!!!!!!
// PropertySet kann fehlen
// zweiter Absatz
// letzte 5 Zeichen im 1. Absatz
// nicht zwischendurch painten
//  Wert der Zelle um 1 hochzaehlen
//  XText ist drin, wenn's ne einzelne Zelle ist
// XIndexAccess gibts nur wenn's mehrere sind (??!??!)
//  Mehrfachoperation auf Tabelle2
// nicht benutzt
// nicht benutzt
//  1.Feld umkehren
// neue Sequence, 1. Spalte aufsteigend
// sollte 2 sein
// sollte 0 sein
// geht nicht:
//  letztes Feld loeschen
// letztes
// nicht zwischendurch painten
// nicht zwischendurch painten


3 / 9 | libreoffice-4.4.0.3/sc/source/core/inc/refupdat.hxx
// keine Anpassungen
// Anpassungen erfolgt
// Referenz wurde ungueltig


1 / 42 | libreoffice-4.4.0.3/sc/source/core/data/funcdesc.cxx
//  ??? OpCode vergeben


1 / 62 | libreoffice-4.4.0.3/sc/source/core/data/dpcache.cxx
// Object being deleted.


1 / 248 | libreoffice-4.4.0.3/sc/source/core/data/dptabsrc.cxx
// XNameAccess implementation using getCount/getByIndex


1 / 73 | libreoffice-4.4.0.3/sc/source/core/data/documen2.cxx
// noch nicht bei CopyToTable/Insert


1 / 15 | libreoffice-4.4.0.3/sc/source/core/data/global2.cxx
//! nQuerySh und pConnection sind gleich ?


22 / 172 | libreoffice-4.4.0.3/sc/source/core/data/drwlayer.cxx
// nur einmal benutzen
//  URL-Buttons haben keinen Handler mehr, machen alles selber
// Undo-Action wird Owner der Page
// nur austragen, nicht loeschen
// einfach weg damit
// Detektivlinien umsetzen (an neue Hoehen/Breiten anpassen)
//  auch wenn Groesse gleich geblieben ist
//  (einzelne Zeilen/Spalten koennen geaendert sein)
//  Berechnung und Werte wie in detfunc.cxx
//! nicht mehrere Undos fuer ein Objekt erzeugen (hinteres kann dann weggelassen werden)
// Grenzen ausrechnen
//! Flags (ausgeblendet?) testen
//! bei Start anfangen
// Anfang beim Verkleinern
//  Rechteck um die ganze Selektion
//  Objekte loeschen (rueckwaerts)
// einfaches Grafik-Objekt
// Drehung rueckgaengig
// Spiegelung rueckgaengig
// hat alles geklappt, dann HitTest ausfuehren
// relativen Mauspunkt berechnen
//  Layer fuer Export von Form-Controls in Versionen vor 5.0 - immer SC_LAYER_FRONT


19 / 42 | libreoffice-4.4.0.3/sc/source/core/data/stlsheet.cxx
// Seitenvorlagen sollen nicht ableitbar sein,
// deshalb werden an dieser Stelle geeignete
// Werte eingestellt. (==Standard-Seitenvorlage)
//  Wenn gerade geladen wird, wird auch der Set hinterher aus der Datei
//  gefuellt, es brauchen also keine Defaults gesetzt zu werden.
//  GetPrinter wuerde dann auch einen neuen Printer anlegen, weil der
//  gespeicherte Printer noch nicht geladen ist!
// Setzen von sinnvollen Default-Werten:
// Rand auf Null setzen
// nicht ueberschreiben!
//  schmutzige Tricks, um die Standard-Vorlage immer als "Standard" zu speichern,
//  obwohl der fuer den Benutzer sichtbare Name uebersetzt ist:
//  Verhindern, dass ein Style "Standard" angelegt wird, wenn das nicht der
//  Standard-Name ist, weil sonst beim Speichern zwei Styles denselben Namen haetten
//  (Beim Laden wird der Style direkt per Make mit dem Namen erzeugt, so dass diese
//  Abfrage dann nicht gilt)
//! Wenn irgendwann aus dem Laden SetName aufgerufen wird, muss fuer das Laden ein
//! Flag gesetzt und abgefragt werden.
//! Die ganze Abfrage muss raus, wenn fuer eine neue Datei-Version die Namens-Umsetzung wegfaellt.


42 / 102 | libreoffice-4.4.0.3/sc/source/core/data/fillinfo.cxx
//  aehnlich wie in output.cxx
// fuer Blockmarken von zusammengefassten Zellen mit
// versteckter erster Zeile / Spalte
//  zuerst nur die Eintraege fuer die ganze Spalte
// ungueltig
// wird unten belegt
// Bereich anpassen
// zusaetzliche Zeile verdeckt ?
//  rotierter Text...
//  Attribut im Dokument ueberhaupt verwendet?
//! Conditionals auch bei HASATTR_ROTATE abfragen ????
//  FindMaxRotCol setzt nRotMaxCol
//  Zell-Infos erst nach dem Test auf gedrehte allozieren
// vom Aufrufer zu loeschen !
// Zell-Infos vorbelegen
// ungueltig
// restliche Breiten eintragen
//! dies sollte reichen
// Spalten-Daten
// einzelne Zeile
// oben 1 mehr
// Ende des Bereichs
// Ende des Bereichs
// Spalten-HG == Standard ?
//  nWidth wird nicht mehr einzeln gesetzt
// einzelne Zeile
// Ende des Bereichs
// Ende des Bereichs
// vordere Spalten
//! oder nur 0 abfragen ??
// STD_COL_WIDTH ganz links und rechts wird fuer DrawExtraShadow gebraucht
//  bedingte Formatierung auswerten
// links und rechts einer mehr
//  Umrandung
//  bedingte Formatierung Ende
//      Daten von zusammengefassten Zellen anpassen
// links und rechts einer mehr
// Hintergrund kopieren (oder in output.cxx)
// Blockmarken - wieder mit Original-Merge-Werten
// Schatten verteilen
// links und rechts einer mehr
//  oder Test auf != eLoc


55 / 316 | libreoffice-4.4.0.3/sc/source/core/data/document.cxx
// durch Restaurierung von Referenzen auf geloeschte Bereiche ist
// ein neues Listening faellig, bisherige Listener wurden in
// durch Restaurierung von Referenzen auf geloeschte Bereiche ist
// ein neues Listening faellig, bisherige Listener wurden in
//  fuer Area-Links: Zellen einuegen/loeschen, wenn sich der Bereich veraendert
//  wenn es mehr Zeilen werden, werden Spalten auf der alten Hoehe eingefuegt/geloescht
//  Spalten
// Spalten einfuegen
// Spalten loeschen
//  Zeilen
// Zeilen einfuegen
// Zeilen loeschen
// Zellen am Rand ?
// Zellen am Rand ?
// Spalten zuerst einfuegen
// Zeilen zuerst loeschen
//  Referenzen um eingefuegte Zeilen erweitern
//  initialisieren
//  -> pTransClip muss vor dem Original-Dokument geloescht werden!
//  Bereiche uebernehmen
//  Dies passiert erst beim Einfuegen...
//! DB-Bereiche Pivot-Bereiche auch !!!
// kein Broadcast/Listener aufbauen bei Insert
// Listener aufbauen nachdem alles inserted wurde
// kein Broadcast/Listener aufbauen bei Insert
// Listener aufbauen nachdem alles inserted wurde
// nachdem alle Listener aufgebaut wurden, kann gebroadcastet werden
// immer alle Inhalte oder keine loeschen!
// immer alle Inhalte oder keine loeschen!
//  true, wenn String- oder Editzellen im Bereich
// keine Mehrfachberechnung
//  Charts werden zwar auch ohne AutoCalc im Tracking auf Dirty gesetzt,
//  wenn alle Formeln dirty sind, werden die Charts aber nicht mehr erwischt
//  (#45205#) - darum alle Charts nochmal explizit
// keine Mehrfachberechnung
// Excel-Dateien werden aus dem Clipboard in ein Clip-Doc geladen
// dann wird erst beim Einfuegen in das richtige Doc berechnet
// noch keine wirklichen Aenderungen
//  Spaltenbreiten / Zeilenhoehen   --------------------------------------
//  Spalten-/Zeilen-Flags   ----------------------------------------------
// unterschiedliche
// unterschiedliche
//  Don't care Status auswerten
//  Attribut im Dokument ueberhaupt verwendet?
//  (wie in fillinfo)
//! Seitengrenzen fuer Druck beruecksichtigen !!!!!
//!     weiterreichen ?
//  Bereich genau dann auf zusammengefasste Zellen erweitern, wenn
//  dadurch keine neuen nicht-ueberdeckten Zellen getroffen werden
//      Autofilter loeschen
//  Die Seitennummern-Zaehlung faengt bei einer Tabelle neu an, wenn eine
//  andere Vorlage als bei der vorherigen gesetzt ist (nur Namen vergleichen)
//  und eine Seitennummer angegeben ist (nicht 0)
// Seitennummer in neuer Vorlage angegeben
// sonst nicht


10 / 62 | libreoffice-4.4.0.3/sc/source/core/data/table6.cxx
// Matrix nicht zerreissen, nur Matrixformel ersetzen
// kein UndoDoc => Matrix nicht wiederherstellbar => nicht ersetzen
//  wenn der gefundene Text leer ist, nicht weitersuchen,
//  sonst wuerde man nie mehr aufhoeren (#35410#)
//  weitersuchen ?
// Matrix nicht zerreissen
// {} raus, erst hier damit auch "{=" durch "{=..." ersetzt werden kann
// zeilenweise
// spaltenweise
//!     einzelnes Pattern fuer Undo zurueckgeben


1 / 407 | libreoffice-4.4.0.3/sc/source/core/data/dptabres.cxx
// passend zum enum ScSubTotalFunc


8 / 28 | libreoffice-4.4.0.3/sc/source/core/data/markdata.cxx
//  Zeilen werden nur aus MarkArray genommen
//! hier auf negative Markierung testen ?
//  bMarkIsNeg inzwischen auch fuer Spaltenkoepfe
//! GetMarkColumnRanges fuer komplett markierte Spalten
//  bMarkIsNeg inzwischen auch fuer Zeilenkoepfe
//! GetMarkRowRanges fuer komplett markierte Zeilen
//!     bei mehreren selektierten Tabellen mehrere Ranges eintragen !!!
//! oder die vorhandenen unten weglassen


43 / 243 | libreoffice-4.4.0.3/sc/source/core/data/table3.cxx
// nur Strings untereinander als String vergleichen!
// Zahl vorne
// Zahl vorne
// Zahlen untereinander
// wird veraendert
//  harte Zahlenformate loeschen (fuer Ergebnisformeln)
//      neue Zwischenergebnisse
//      rParam.nRow2 wird veraendert !
// wird veraendert
//  Leerzeilen am Ende weglassen,
//  damit alle Ueberlaeufe (MAXROW) bei InsertRow gefunden werden (#35180#)
//  Wenn sortiert wurde, sind alle Leerzeilen am Ende.
// Anzahl Gruppierungen
// nichts tun
// Spalten nach denen
// gruppiert wird
//  Durch (leer) als eigene Kategorie muss immer auf
//  Teilergebniszeilen aus den anderen Spalten getestet werden
//  (frueher nur, wenn eine Spalte mehrfach vorkam)
// Pointer wegen Compiler-Problemen
// Erfolg beim Einfuegen?
// incl. Gesamtergebnis
// sonst nur sortieren
// aSubString bleibt auf dem letzten stehen
// Gruppe eingeblendet?
//  wenn sortiert, ist "leer" eine eigene Gruppe
//  sonst sind leere Zellen unten erlaubt
// "Gesamtergebnis"
// " Ergebnis"
//  Zahlformat loeschen
//!     je nach Einstellung Zwischensummen-Zeilen nach oben verschieben ?
//!     Outlines direkt erzeugen?
// neues Ende
// keine Note-/Leerzellen zaehlen, sind ans Ende sortiert
// keine Strings zaehlen, sind zwischen Value und Leer
// dat wird nix
// Filterergebnis
// Subtotals stehenlassen
// Erste Zeile muessen Spaltenkoepfe sein
// Erste Spalte UND/ODER
// Zweite Spalte FeldName
// Vierte Spalte Wert
//  bQueryByString muss gesetzt sein


1 / 4 | libreoffice-4.4.0.3/sc/source/core/data/subtotalparam.cxx
// 0 wird als 1 aufgefasst, sonst zum Array-Index dekrementieren


21 / 58 | libreoffice-4.4.0.3/sc/source/core/data/documen9.cxx
// angelegt wird die Page schon im ScTable ctor
//  Gibt es Objekte auf dem Hintergrund-Layer, die (teilweise) von rMMRect
//  betroffen sind?
//  (fuer Drawing-Optimierung, vor dem Hintergrund braucht dann nicht geloescht
//   zu werden)
//  Gibt es ueberhaupt Objekte, die (teilweise) von rMMRect
//  betroffen sind?
//  (um leere Seiten beim Drucken zu erkennen)
//  fuer Drag&Drop auf Zeichenobjekt
//  Intern interessiert gar nicht
//  Objekt vom Back-Layer nur, wenn kein Objekt von anderem Layer getroffen
//  weitersuchen -> letztes (oberstes) getroffenes Objekt nehmen
//  aehnlich wie in ScPrintFunc::AdjustPrintArea
//! ExtendPrintArea erst ab Start-Spalte des Druckbereichs
// kein Refresh, incl. Attrs
// wichtig fuer GetNeededSize
//  In alten Versionen (bis incl. 4.0 ohne SP) wurden beim Austausch zwischen
//  Systemen die CharSets in den Font-Attributen nicht angepasst.
//  Das muss fuer Dokumente bis incl SP2 nun nachgeholt werden:
//  Alles, was nicht SYMBOL ist, wird auf den System-CharSet umgesetzt.
//  Bei neuen Dokumenten (Version SC_FONTCHARSET) sollte der CharSet stimmen.


4 / 10 | libreoffice-4.4.0.3/sc/source/core/data/sortparam.cxx
// Anzahl der Sorts gleich?
//  zuerst die Gruppen aus den Teilergebnissen
//  dann dahinter die alten Einstellungen
// ein Feld nicht zweimal eintragen


5 / 57 | libreoffice-4.4.0.3/sc/source/core/data/table5.cxx
//  bei mehreren Bereichen nichts anzeigen:
//  Anfang: Breaks loeschen
//  Mittelteil: Breaks verteilen
//  Ende: Breaks loeschen
// auch ohne den alten (fuer UpdateStdNames)


24 / 77 | libreoffice-4.4.0.3/sc/source/core/data/patattr.cxx
// wenn Style geloescht ist/war
//  Items auslesen
//  auswerten
//  Items auslesen
// alles direkt aus Pattern
// kompatibel zu LogicToLogic rechnen, also 2540/1440 = 127/72, und runden
// EditEngine Default ist bei dem GetAttribs() ItemSet
// immer gesetzt!
// ob links oder rechts entscheiden wir selbst bei Text/Zahl
//  in GetFromEditItemSet schon dabei, in FillEditItemSet aber nicht
//  Hor. Ausrichtung Standard wird immer als "links" umgesetzt
// ggF. abgeleitete Styles erzeugen, wenn nicht vorhanden:
// wenn Vorlage im DestDoc vorhanden, dieses benutzen, sonst Style
// mit Parent-Vorlagen kopieren/ggF. erzeugen und dem DestDoc hinzufuegen
//  Gueltigkeit ins neue Dokument kopieren
//  Zahlformate nach Exchange-Liste
//!     auch hier nur wirklich sichtbare Werte testen !!!
//  wenn Style nicht gefunden, Standard nehmen,
//  damit keine leere Anzeige im Toolbox-Controller
//! es wird vorausgesetzt, dass "Standard" immer der erste Eintrag ist!
// Style wurde geloescht, Namen merken:
// es bleibt wie es ist
//  dasselbe, wenn bedingte Formatierung im Spiel ist:
//  GetRotateVal testet vorher ATTR_ORIENTATION


2 / 138 | libreoffice-4.4.0.3/sc/source/core/data/table4.cxx
// kein Datum passt auch nicht
//! Zahlformat je nach Index holen?


32 / 136 | libreoffice-4.4.0.3/sc/source/core/data/table1.cxx
//  zuerst einmal ueber den ganzen Bereich
//  (mit der letzten Spalte in der Hoffnung, dass die am ehesten noch auf
//   Standard formatiert ist)
//  daraus Standardhoehe suchen, die im unteren Bereich gilt
// nochmal denselben Status muss auch nicht sein
//  nicht im dtor die Pages in der falschen Reihenfolge loeschen
//  (nTab stimmt dann als Page-Number nicht!)
//  In ScDocument::Clear wird hinterher per Clear am Draw Layer alles geloescht.
// zusammengefasste mitzaehlen
// keine einzelnen
//! auch sonst ???
//  ausgeblendete muessen uebersprungen werden, weil der Cursor sonst
//  auf der naechsten Zelle landet, auch wenn die geschuetzt/nicht markiert ist.
//! per Extra-Parameter steuern, nur fuer Cursor-Bewegung ???
// Tabelle ueberhaupt geschuetzt?
//  ausgeblendete ueberspringen (s.o.)
//  ausgeblendete ueberspringen (s.o.)
// initiales Weiterzaehlen wrappen:
// bei gleichen den linken
// ungueltigen Wert behalten
// alles ganz von vorne
// bei gleichen den rechten
// ungueltigen Wert behalten
// alles ganz von vorne
//  ungueltige Werte kommen z.b. bei Tab heraus,
//  wenn nicht markiert und nicht geschuetzt ist (linker / rechter Rand),
//  dann Werte unveraendert lassen
// naechste Zelle ist gesucht
// naechsten markierten Bereich suchen
// naechste Spalte testen
// alle Spalten durch
// Breite bereits im Idle-Handler berechnet?


11 / 52 | libreoffice-4.4.0.3/sc/source/core/data/stlpool.cxx
//                      Standard-Vorlagen
//  neue Eintraege auch bei CopyStdStylesFrom eintragen
// 2. Ergebnis
// 3. Ergebnis1
// 4. Ueberschrift
// 5. Ueberschrift1
// Seitenformat-Vorlagen:
// Abstand der Kopf-/Fusszeilen von der Tabelle
// Kopfzeile:
// Hintergrund und Umrandung
// Kopfzeile:


1 / 209 | libreoffice-4.4.0.3/sc/source/core/data/column.cxx
// random(), jetzt() etc.


1 / 393 | libreoffice-4.4.0.3/sc/source/core/data/formulacell.cxx
// OnLoadOnce nur zum Dirty setzen nach Filter-Import


13 / 81 | libreoffice-4.4.0.3/sc/source/core/data/documen8.cxx
// setzt pPrinter
// Bedeutung der Items in rChanges:
//  Item gesetzt    - Aenderung uebernehmen
//  Default         - keine Aenderung
// ("keine Aenderung" geht nicht mit PutExtended, darum Schleife)
// bei Default nichts
// Berechnungen
// true = demnaechst wieder versuchen
// wichtig fuer GetNeededSize
//  bei 4.0-Export alle mit Modus != DEFAULT weglassen
//  erstmal zaehlen...
//  Links speichern
// aus Stream erzeugen


55 / 179 | libreoffice-4.4.0.3/sc/source/core/data/table2.cxx
// Zellschutz auf geschuetzter Tabelle nicht setzen
// Zellschutz auf geschuetzter Tabelle nicht setzen
//  ggf. Formeln durch Werte ersetzen
// Zellschutz auf geschuetzter Tabelle nicht setzen
//  Markierung von diesem Dokument
//  Referenzen drehen
//  bei Cut werden Referenzen spaeter per UpdateTranspose angepasst
// Spaltenbreiten/Zeilenhoehen/Flags
//  Charts muessen beim Ein-/Ausblenden angepasst werden
//! Aenderungen zusammenfassen?
// alle Bits gesetzt?
// Mehrfachberechnungen vermeiden
// Mehrfachberechnungen vermeiden
// Mehrfachberechnungen vermeiden
//  Rueckgabe = neues nArrY
//! begrenzen !!!
//! zusaetzlich Faktor fuer unterschiedliche PPT X/Y !!!
//  bei SC_ROTDIR_LEFT kommt immer ein negativer Wert heraus,
//  wenn der Modus beruecksichtigt wird
// reicht die gedrehte Zelle bis in den sichtbaren Bereich?
//  nRotMaxCol ist auf SC_ROTMAX_NONE initialisiert, nRowNo ist schon gesetzt
//  alle Formate durchgehen, damit die Zellen nicht einzeln
//  angeschaut werden muessen
//  nArrY nicht veraendern
// linke und rechte Spalte
// nicht (4 und 16) oder 1 oder 32
// linke oder rechte Kante fehlt oder offen
// nicht 4 oder 1 oder 32
// nicht 16 oder 1 oder 32
// rechte Kante fehlt oder offen
// obere und untere Zeile
// obere oder untere Kante fehlt
// linke Kante oeffnet, weitersehen
// es gibt was, was nicht geoeffnet wurde
// rechte Kante schliesst
// es geht noch weiter
// erst obere Zeile, dann untere Zeile
// in oberere Zeile keine obere Kante bzw.
// in unterer Zeile keine untere Kante
// linke Kante oeffnet, weitersehen
// es gibt was, was nicht geoeffnet wurde
// rechte Kante schliesst
// es geht noch weiter
// unterschiedliche
// unterschiedliche
//  Spaltenbreiten / Zeilenhoehen
// immer die eingestellte
//  Spalten-/Zeilen-Flags
//!     ShowRows / DBShowRows zusammenfassen
//  Filter-Flag immer setzen, auch wenn Hidden unveraendert
// Zeilen
//  CopyData - fuer Query in anderen Bereich
//!     wenn fuer mehrere Zeilen benutzt, nach Spalten optimieren!
// irgendwie anders
// Berechnen der Groesse der Tabelle und setzen der Groesse an der DrawPage


24 / 53 | libreoffice-4.4.0.3/sc/source/core/data/documen7.cxx
//  Repaint fuer bedingte Formate mit relativen Referenzen:
//  Repaint fuer bedingte Formate mit relativen Referenzen:
// kein Ende, kein Anfang..
// wenn die Zelle die erste oder sonstwo ist
// gibt Vorlaeufer
// ist erste Zelle
// gibt Nachfolger
// ist letzte Zelle
//! _nicht_ SetAutoCalc( true ) weil das evtl. CalcFormulaTree( true )
//! aufruft, wenn vorher disabled war und bHasForcedFormulas gesetzt ist
// falls pNext==0 und neue abhaengige hinten angehaengt
// wurden, so macht das nichts, da die alle bDirty sind
// Interpret setzt bDirty zurueck und callt Remove, auch der referierten!
// bei RECALCMODE_ALWAYS bleibt die Zelle
// (IsInFormulaTree(pCell)) kein Remove gewesen => next
// Zelle kann nicht in beiden Listen gleichzeitig sein
// kein Ende, kein Anfang..
// wenn die Zelle die erste oder sonstwo ist
// gibt Vorlaeufer
// ist erste Zelle
// gibt Nachfolger
// ist letzte Zelle
/*
    Der erste wird gebroadcastet,
    die dadurch entstehenden werden durch das Notify an den Track gehaengt.
    Der nachfolgende broadcastet wieder usw.
    View stoesst Interpret an.
 */
//  Repaint fuer bedingte Formate mit relativen Referenzen:


1 / 13 | libreoffice-4.4.0.3/sc/source/core/tool/queryparam.cxx
// Anzahl der Queries gleich?


2 / 203 | libreoffice-4.4.0.3/sc/source/core/tool/interpr4.cxx
// im Fehlerfall (sonst ist i==0) Parameter wegpoppen
//  Parameter-Array zusammenbauen


12 / 370 | libreoffice-4.4.0.3/sc/source/core/tool/interpr1.cxx
// Wertzeile
// nur in der ersten Zeile suchen
// nur in der ersten Spalte suchen
// mit Tausenderpunkt
// nicht rot
// Nachkommastellen
// 1 Vorkommanull
// Param TRUE: keine Tausenderpunkte
// mit Tausenderpunkt
// nicht rot
// Nachkommastellen
// 1 Vorkommanull


40 / 103 | libreoffice-4.4.0.3/sc/source/core/tool/detfunc.cxx
// Return-Werte beim Einfuegen in einen Level
//! einzeln ?
//  Standard-Linienenden (wie aus XLineEndList::Create) selber zusammenbasteln,
//  um von den konfigurierten Linienenden unabhaengig zu sein
// Bereich
// einzelne Referenz
// Bereich
// einzelne Referenz
//  DrawEntry:      Formel auf dieser Tabelle,
//                  Referenz auf dieser oder anderer
//  DrawAlienEntry: Formel auf anderer Tabelle,
//                  Referenz auf dieser
//      return FALSE: da war schon ein Pfeil
//      Box um Referenz loeschen
// nach SetRunning geht's nicht mehr!
//  neuer Pfeil eingetragen
//  weiterverfolgen
//  nMaxLevel erreicht
//  nDeleteLevel != 0   -> loeschen
// nach SetRunning geht's nicht mehr!
// Pfeile, die hierher zeigen
// Rahmen loeschen ?
// weitersuchen
// nach SetRunning geht's nicht mehr!
//  und weiterverfolgen
// praktisch immer
// nach SetRunning geht's nicht mehr!
//  neuer Pfeil eingetragen
//  weiterverfolgen
//  nMaxLevel erreicht
// nach SetRunning geht's nicht mehr!
// Pfeile, die hier anfangen
// loeschen
// loeschen
// Detektiv, aus Menue
// auch Kreise
// Kreise, wenn neue erzeugt werden
// nur die Kreise
//  Stellen suchen, wo Gueltigkeit definiert ist
//  Zellen in dem Bereich durchgehen


1 / 297 | libreoffice-4.4.0.3/sc/source/core/tool/chgtrack.cxx
// Overwritten Contents


28 / 248 | libreoffice-4.4.0.3/sc/source/core/tool/rangelst.cxx
// falls das jemand vergessen sollte
// alle Bits setzen
// Default Tab wenn nicht angegeben
// alle gemeinsamen Bits bleiben erhalten
// SCA_VALID gesetzt wenn alle ok
// derselbe, weiter mit dem naechsten
// Range r in Range p enthalten oder identisch
// weg mit Range r
// nicht anhaengen
// Range p in Range r enthalten, r zum neuen Range machen
// innerhalb der Liste Range loeschen
// Seek richtig aufsetzen
// auch andere Reihenfolge ist ungleich
// gleiche Tabs
// gleiche Cols
// erste Ecke gleich, zweite Ecke
// gleiche Tabs
// gleiche Cols
// derselbe, weiter mit dem naechsten
// nur wenn Range2 gleich ist
// RangePair r in RangePair p enthalten oder identisch
// weg mit RangePair r
// nicht anhaengen
// RangePair p in RangePair r enthalten, r zum neuen RangePair machen
// 2D, Range2 muss genauso nebeneinander liegen wie Range1
// innerhalb der Liste RangePair loeschen
// Seek richtig aufsetzen
// ScRangePair Pointer aufruecken


3 / 8 | libreoffice-4.4.0.3/sc/source/core/tool/callform.cxx
// Module in die Collection aufnehmen
// Schnittstelle initialisieren
// nicht per Reference versauen lassen..


15 / 242 | libreoffice-4.4.0.3/sc/source/core/tool/interpr3.cxx
// Allgemeine Funktionen
// Horner scheme
// 0 oder 1
// Dichte
// Verteilung
// 0 oder 1
// Dichte
// Verteilung
// Mittelwert
// Achtung: T, F und Chi
// sind monoton fallend,
// deshalb 1-Dist als Funktion
//  GetTDist wird mit GetBetaDist berechnet und kommt auch mit nicht ganzzahligen
//  Freiheitsgraden klar. Dann stimmt das Ergebnis auch mit Excel ueberein (#52406#):
//  laut Bronstein-Semendjajew


9 / 196 | libreoffice-4.4.0.3/sc/source/core/tool/interpr2.cxx
// Datumsanteil weg
// Datumsanteil weg
// Datumsanteil weg
// damit default Land/Spr.
// damit default Land/Spr.
// range_of_values ; rate_invest ; rate_reinvest
// fuer kapz auch bei fZr == 1
// erster ?
// und ::rtl::math::approxSub( fVal, fMult ) == 0


21 / 35 | libreoffice-4.4.0.3/sc/source/core/tool/consoli.cxx
//  Reihenfolge wie bei enum ScSubTotalFunc
// erst nach ppRefs !!!
// sonst stimmt maColHeaders nicht
//  CornerText: einzelner String
//  Daten auf gleiche Laenge bringen
//  Positionen eintragen
// rCount < 0 <=> Fehler aufgetreten
//      Titel suchen
//  vorher testen, wieviele Zeilen eingefuegt werden (fuer Undo)
//  fertige Daten ins Dokument schreiben
//! optimieren nach Spalten?
// Werte direkt einfuegen
// Referenzen einfuegen
//! unterscheiden, ob nach Kategorien aufgeteilt
// Daten fuer Referenz-Formelzellen
// Daten fuer Summen-Zellen
//  Referenz einfuegen (absolut, 3d)
//  Summe einfuegen (relativ, nicht 3d)
// ausgewaehlte Funktion
//  Gliederung einfuegen
//  Zwischentitel


4 / 48 | libreoffice-4.4.0.3/sc/source/core/tool/interpr6.cxx
// damit default Land/Spr.
// Bei Summen etc. macht ein bool-Ergebnis keinen Sinn
// und Anzahl ist immer Number (#38345#)
// damit default Land/Spr.


1 / 139 | libreoffice-4.4.0.3/sc/source/core/tool/address.cxx
// keine Tokens aus halben Sachen


11 / 56 | libreoffice-4.4.0.3/sc/source/core/tool/editutil.cxx
//  Delimiters zusaetzlich zu EditEngine-Default:
//!!! einstellbar an App???
// Space ist Default der Editengine
//  vertikale Position auf die in der Tabelle anpassen
// zu gross -> oben anfangen
//  -1 -> Gitter nicht ueberschreiben
//  Feldbefehle enthalten?
// wir haben keine StyleSheets fuer Text
//      Feldbefehle fuer Kopf- und Fusszeilen
//      Zahlen aus \sw\source\core\doc\numbers.cxx
//      case ARABIC:    ist jetzt default


1 / 28 | libreoffice-4.4.0.3/sc/source/core/tool/docoptio.cxx
//      ScTpCalcItem - Daten fuer die CalcOptions-TabPage


21 / 37 | libreoffice-4.4.0.3/sc/source/core/tool/ddelink.cxx
// Verbindung aufheben
// neu in 388b und der 364w (RealTime-Client) Version
// nicht bei 4.0 Export
// seit 388b
//  Links mit Mode != SC_DDE_DEFAULT werden bei 4.0 Export komplett weggelassen
//  wir koennen nur Strings...
//  wenn String mit Zeilenende aufhoert, streichen:
// Leerstring -> eine leere Zelle
// keine Daten
// Daten aufteilen
//  Matrix immer neu anlegen, damit bIsString nicht durcheinanderkommt
//  nMode bestimmt, wie der Text interpretiert wird (#44455#/#49783#):
//  SC_DDE_DEFAULT - Zahlformat aus Zellvorlage "Standard"
//  SC_DDE_TEXT    - ohne NumberFormatter direkt als String
// enthaelt Standard-Vorlage
//  Es hat sich was getan...
//  TrackFormulas zusaetzlich nochmal sofort, damit nicht z.B. durch IdleCalc
//  eine Formel berechnet wird, die noch im FormulaTrack steht (#61676#)
// Remove() kann Reschedule ausloesen??!?
// letzten geloescht ?
// kann jetzt nicht ausgefuehrt werden


18 / 579 | libreoffice-4.4.0.3/sc/source/core/tool/compiler.cxx
// Zerlegt die Formel in einzelne Symbole fuer die weitere
// Verarbeitung (Turing-Maschine).
// Ausgangs Zustand = GetChar
// Alter Zustand | gelesenes Zeichen | Aktion                | Neuer Zustand
// GetChar       | ;()+-*/^=&        | Symbol=Zeichen        | Stop
//               | <>                | Symbol=Zeichen        | GetBool
//               | $ Buchstabe       | Symbol=Zeichen        | GetWord
//               | Ziffer            | Symbol=Zeichen        | GetValue
//               | "                 | Keine                 | GetString
//               | Sonst             | Keine                 | GetChar
// GetBool       | =>                | Symbol=Symbol+Zeichen | Stop
//               | Leerzeichen       | Dec(CharPos)          | Stop
//               | Buchstabe,Ziffer  | Symbol=Symbol+Zeichen | GetWord
//               | Leerzeichen       | Dec(CharPos)          | Stop
//               | Ziffer E+-%,.     | Symbol=Symbol+Zeichen | GetValue
// GetString     | "                 | Keine                 | Stop
//               | Sonst             | Symbol=Symbol+Zeichen | GetString
// Column 'DM' ("Deutsche Mark", German currency) couldn't be


1 / 9 | libreoffice-4.4.0.3/sc/source/core/tool/unitconv.cxx
// Delimiter zwischen From und To


19 / 31 | libreoffice-4.4.0.3/sc/source/core/tool/refupdat.cxx
//! begrenzen ???
//! begrenzen ???
// nach hinten schieben
// nachruecken
// nach vorne schieben
// nachruecken
//! vor normalem Move...
// mindestens zwei Cols/Rows/Tabs in Ref
// n1 innerhalb des Insert
// n2 direkt vor Insert
// n1 < nStart <= n2 wird sowieso expanded!
//! nach normalem Move..., nur wenn IsExpand vorher true war!
//! erst das Ende
// Referenzen koennen auch ausserhalb des Dokuments liegen!
// Ganze Spalten/Zeilen (nInt32Min..nInt32Max) bleiben immer solche!
//  UpdateGrow - erweitert Referenzen, die genau auf den Bereich zeigen
//  kommt ohne Dokument aus
//  in Y-Richtung darf die Ref auch eine Zeile weiter unten anfangen,
//  falls ein Bereich Spaltenkoepfe enthaelt


2 / 30 | libreoffice-4.4.0.3/sc/source/core/tool/reffind.cxx
// die drei Abs-Flags
// weiterzaehlen


1 / 32 | libreoffice-4.4.0.3/sc/source/core/tool/appoptio.cxx
// sinnvoll vorbelegen


14 / 46 | libreoffice-4.4.0.3/sc/source/core/tool/dbdata.cxx
//  Daten, die nicht in den Params sind
// hat nur eine Tabelle
//  anpassen wie die aktuelle Tabelle bei ScTablesHint (tabvwsh5.cxx)
// verschobene Tabelle
// nach hinten verschoben
// nachrueckender Bereich
// nach vorne verschoben
// nachrueckender Bereich
//  MoveTo ist nicht noetig, wenn nur die Tabelle geaendert ist
//!     Testen, ob mitten aus dem Bereich geloescht/eingefuegt wurde !!!
// ersten angrenzenden Bereich merken
// nicht "unbenannt" und Cursor steht wirklich drin
// angrenzender, wenn nichts direkt getroffen
// "unbenannt" nur zurueck, wenn sonst nichts gefunden


1 / 31 | libreoffice-4.4.0.3/sc/source/core/tool/doubleref.cxx
//  bQueryByString muss gesetzt sein


1 / 7 | libreoffice-4.4.0.3/sc/source/core/tool/queryentry.cxx
//! pSearchParam und pSearchText nicht vergleichen


3 / 77 | libreoffice-4.4.0.3/sc/source/core/tool/stringutil.cxx
// (nur) auf englisches Zahlformat testen
//  das (englische) Zahlformat wird nicht gesetzt
//! passendes lokales Format suchen und setzen???


2 / 42 | libreoffice-4.4.0.3/sc/source/core/tool/rangeutl.cxx
// erst Bereichsnamen
// dann DB-Bereiche


1 / 6 | libreoffice-4.4.0.3/sc/source/core/tool/prnsave.cxx
//      Daten fuer das ganze Dokument


3 / 48 | libreoffice-4.4.0.3/sc/source/core/tool/viewopti.cxx
//  Raster-Defaults sind jetzt zwischen den Apps unterschiedlich
//  darum hier selber eintragen (alles in 1/100mm)
//      ScTpViewItem - Daten fuer die ViewOptions-TabPage


5 / 22 | libreoffice-4.4.0.3/sc/source/core/tool/cellform.cxx
//  GetString an der EditCell macht Leerzeichen aus Umbruechen,
//  hier werden die Umbrueche aber gebraucht
//  Edit-Zellen auch nicht per NumberFormatter formatieren
//  (passend zur Ausgabe)
//  wie in GetString am Dokument (column)


2 / 6 | libreoffice-4.4.0.3/sc/source/core/tool/zforauto.cxx
// sonst passt "Standard" nicht
// sonst passt "Standard" nicht


1 / 5 | libreoffice-4.4.0.3/sc/source/filter/inc/lotfntbf.hxx
// < 0 -> undefiniert


4 / 20 | libreoffice-4.4.0.3/sc/source/filter/inc/eeparser.hxx
// wird von WriteToDocument uebernommen
// 1==hori, 2==verti, 3==beides
// Grafiken in dieser Zelle
// relativ zum Beginn des Parse


4 / 15 | libreoffice-4.4.0.3/sc/source/filter/inc/root.hxx
// -> Inkarnation jeweils im ImportExcel-Objekt!
// feine Differenzierung
// Col/Row-Einstellungen 1 Tabelle
// Erweiterungen fuer Export


2 / 6 | libreoffice-4.4.0.3/sc/source/filter/inc/exp_op.hxx
// Ausgabe-Stream
// Ziel-Zeichensatz


1 / 22 | libreoffice-4.4.0.3/sc/source/filter/inc/htmlexp.hxx
// Defaults aus StyleSheet


3 / 30 | libreoffice-4.4.0.3/sc/source/filter/inc/lotimpop.hxx
// z.Zt. bearbeitete Tabelle
// fuer Addresses/Ranges im Format Row(16)/Tab(8)/Col(8)
// 0-terminierten String einlesen


1 / 101 | libreoffice-4.4.0.3/sc/source/filter/inc/xeescher.hxx
/// Escher object ID (BIFF8).


1 / 336 | libreoffice-4.4.0.3/sc/source/filter/inc/stylesbuffer.hxx
/// Major/minor scheme font.


4 / 67 | libreoffice-4.4.0.3/sc/source/filter/inc/ftools.hxx
// eFormat == EIF_AUTO  -> passender Filter wird automatisch verwendet
// eFormat == EIF_BIFF5 -> nur Biff5-Stream fuehrt zum Erfolg (auch wenn in einem Excel97-Doc)
// eFormat == EIF_BIFF8 -> nur Biff8-Stream fuehrt zum Erfolg (nur in Excel97-Docs)
// eFormat == EIF_BIFF_LE4 -> nur Nicht-Storage-Dateien _koennen_ zum Erfolg fuehren


2 / 5 | libreoffice-4.4.0.3/sc/source/filter/inc/lotattr.hxx
// !! ohne Center-Bit!!
// 0 und 7 fehlen!


2 / 152 | libreoffice-4.4.0.3/sc/source/filter/inc/htmlpars.hxx
// erste Col je Table
// je Table, ob in erster Zeile


1 / 5 | libreoffice-4.4.0.3/sc/source/filter/inc/rtfparse.hxx
// rechter Rand der Zelle


8 / 19 | libreoffice-4.4.0.3/sc/source/filter/inc/tool.h
// Dezimalstellen fuer Standard-Zellen
// Bit 0...3  = Bit 0...3 von Stellenzahl
// Bit 4...10 = Bit 0...6 von Formatbyte
// zugehoeriges Attribut
//gepufferte Formate
// zum Vergleichen
// POST:    return = zu nFormat und nSt passendes SC-Format
// neues Attribut anlegen


3 / 21 | libreoffice-4.4.0.3/sc/source/filter/inc/xcl97esc.hxx
// --- class XclEscherHostAppData ------------------------------------
// --- class XclEscherClientData -------------------------------------
// --- class XclEscherClientTextbox ----------------------------------


1 / 46 | libreoffice-4.4.0.3/sc/source/filter/inc/xcl97rec.hxx
// overwritten for writing MSODRAWING record


1 / 53 | libreoffice-4.4.0.3/sc/source/filter/dif/difimp.cxx
// FIXME: Add proper Warnung!


1 / 225 | libreoffice-4.4.0.3/sc/source/filter/excel/xestyle.cxx
// OOXTODO: XML_scheme; //scheme/@val values: "major", "minor", "none"


1 / 236 | libreoffice-4.4.0.3/sc/source/filter/excel/xetable.cxx
// XF identifier representing default cell XF


1 / 269 | libreoffice-4.4.0.3/sc/source/filter/excel/excform.cxx
// von extern


1 / 77 | libreoffice-4.4.0.3/sc/source/filter/excel/xltools.cxx
// MS Windows Korean (Wansung)


1 / 7 | libreoffice-4.4.0.3/sc/source/filter/excel/expop2.cxx
// wechstreamen


2 / 251 | libreoffice-4.4.0.3/sc/source/filter/excel/read.cxx
// und zurueck an alte Position
// und zurueck an alte Position


1 / 9 | libreoffice-4.4.0.3/sc/source/filter/lotus/lotfilter.hxx
// -> in memory.cxx initialisiert


1 / 15 | libreoffice-4.4.0.3/sc/source/filter/lotus/filter.cxx
//  Discover WKS, WK1 und WK3; s.a op.cpp


10 / 1329 | libreoffice-4.4.0.3/sc/source/filter/lotus/lotform.cxx
// zusaetzlich: 1. -> 3., 3. -> 2., 2. -> 1.
// eventuellen Rest/Ueberlauf korrigieren
//    2 Bereich
//   19 Potenzierung
//   37 Natuerlicher Logarithmus
//   72 String()    ocFixed ersatzweise + Spezialfall
//  166 D360 (US-Version, ersatzweise wie ander D360-function)
//    2 Bereich
//   19 Potenzierung
//   37 Natuerlicher Logarithmus


2 / 6 | libreoffice-4.4.0.3/sc/source/filter/lotus/lotus.cxx
// WK1 /WKS erzwingen
// versuchen *.FM3-File zu laden


1 / 208 | libreoffice-4.4.0.3/sc/source/filter/lotus/optab.cxx
// Bearbeitungsfunktion sal_Char *X( sal_Char * )


2 / 59 | libreoffice-4.4.0.3/sc/source/filter/xcl97/xcl97esc.cxx
// --- class XclEscherClientData -------------------------------------
// --- class XclEscherClientTextbox -------------------------------------


4 / 392 | libreoffice-4.4.0.3/sc/source/filter/oox/numberformatsbuffer.cxx
/** German, Liechtenstein. */
/** Malay, Brunei Darussalam. */
// German, Liechtenstein
// Malay, Brunei Darussalam


1 / 77 | libreoffice-4.4.0.3/sc/source/filter/html/htmlexp.cxx
/*eNach*/


1 / 52 | libreoffice-4.4.0.3/sc/source/filter/rtf/rtfparse.cxx
// davor war kein \intbl, bad behavior


1 / 12 | libreoffice-4.4.0.3/sc/source/filter/rtf/rtfexp.cxx
/*eNach*/


2 / 144 | libreoffice-4.4.0.3/sc/source/ui/undo/undoblk.cxx
// Zeichnen
//! eigener String?


2 / 83 | libreoffice-4.4.0.3/sc/source/ui/undo/undoblk3.cxx
//! eigener Text ??
// neue Werte im Link


1 / 12 | libreoffice-4.4.0.3/sc/source/ui/inc/undobase.hxx
// mit Referenzen


1 / 22 | libreoffice-4.4.0.3/sc/source/ui/inc/tabvwsh.hxx
// Benachrichtigung


1 / 50 | libreoffice-4.4.0.3/sc/source/ui/inc/output.hxx
// beim Gitter bChanged auswerten


1 / 38 | libreoffice-4.4.0.3/sc/source/ui/inc/tabview.hxx
// Zeichnen


1 / 11 | libreoffice-4.4.0.3/sc/source/ui/inc/docfunc.hxx
// FillAuto: rRange wird von Source-Range auf Dest-Range angepasst


27 / 46 | libreoffice-4.4.0.3/sc/source/ui/formdlg/dwfunctr.cxx
/*************************************************************************
#*  Member:     ScFunctionChildWindow
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionChildWindow
#*
#*  Funktion:   Konstruktor der Klasse ScFunctionChildWindow
#*              Ableitung vom SfxChildWindow als "Behaelter" fuer
#*              Funktions- Fenster in Clac
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     ScFunctionDockWin
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Konstruktor der Klasse ScFunctionDockWin
#*
#*  Input:      Sfx- Verknuepfungen, Fenster, Resource
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     UpdateFunctionList
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Aktualisiert die Liste der Funktionen ab-
#*              haengig von der eingestellten Kategorie.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     UpdateFunctionList
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Aktualisiert die Liste der zuletzt verwendeten Funktionen.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetSize
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Groesse fuer die einzelnen Controls einzustellen.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetLeftRightSize
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Groesse fuer die einzelnen Controls einstellen,
#*              wenn Links oder Rechts angedockt wird.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetTopBottonSize
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Groesse fuer die einzelnen Controls einzustellen.
#*              wenn oben oder unten angedockt wird.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetMyWidthLeRi
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Breite fuer die einzelnen Controls und
#*              das Fenster einstellen,wenn Li oder Re
#*
#*  Input:      neue Fenstergroesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetHeight
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Hoehe fuer die einzelnen Controls und
#*              das Fenster einstellen bei Li oder Re
#*
#*  Input:      neue Fenstergroesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetMyWidthToBo
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Breite fuer die einzelnen Controls und
#*              das Fenster einstellen, wenn oben oder
#*              unten angedockt werden soll.
#*
#*  Input:      neue Fenstergroesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetHeight
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Hoehe fuer die einzelnen Controls und
#*              das Fenster einstellen, wenn oben oder
#*              unten angedockt werden soll.
#*
#*  Input:      neue Fenstergroesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetDescription
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Erklaerungstext fuer die Funktion einstellen.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     Resizing
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Ueberladene Funktion um die Groesse der
#*              einzelnen Controls einzustellen.
#*
#*  Input:      neue Groesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     Close
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Schliessen des Fensters
#*
#*  Input:      ---
#*
#*  Output:     TRUE
#*
#************************************************************************/
/*************************************************************************
#*  Member:     CheckAlignment
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Ueberprueft den Andockmodus und stellt die
#*              Groessen dementsprechend ein.
#*
#*  Input:      Das neue Alignment
#*
#*  Output:     Das uebergebene Alignment
#*
#************************************************************************/
/*************************************************************************
#*  Member:     Close
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Aenderungen erkennen
#*
#*  Input:      ---
#*
#*  Output:     TRUE
#*
#************************************************************************/
/*************************************************************************
#*  Member:     Resize
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Ueberladene Funktion um die Groesse der
#*              einzelnen Controls einzustellen.
#*
#*  Input:      neue Groesse
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     UpdateFunctionList
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Aktualisiert die Liste der Funktionen ab-
#*              haengig von der eingestellten Kategorie.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     DoEnter
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Eingabe ins Dokument uebernehmen. Wird aufgerufen
#*              nach betaetigen der Uebernehmen- Schaltflaeche
#*              oder einem Doppelklick in die Funktionsliste.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
// @ Wegen Absturz bei Namen festlegen
/*************************************************************************
#*  Handle:     SelHdl
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Bei einer Aenderung der Kategorie wird die
#*              die Liste der Funktionen aktualisiert.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Handle:     SelHdl
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Bei einer Aenderung der Kategorie wird die
#*              die Liste der Funktionen aktualisiert.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
// Uebernimmt die Eingabe
/*************************************************************************
#*  Handle:     SetSplitHdl
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScFunctionDockWin
#*
#*  Funktion:   Bei einer Aenderung des Split- Controls werden die
#*              einzelnen Controls an die neue Groesse angepasst.
#*
#*  Input:      Zeiger auf Control
#*
#*  Output:     ---
#*
#************************************************************************/
// Versuche, den Alignment-String "ALIGN:(...)" einzulesen; wenn
// er nicht vorhanden ist, liegt eine "altere Version vor
// Alignment-String herausschneiden


34 / 68 | libreoffice-4.4.0.3/sc/source/ui/formdlg/formula.cxx
//      Initialisierung / gemeinsame Funktionen  fuer Dialog
//Nun wird es Zeit den Inputhandler festzulegen
//  Formel vorhanden? Dann editieren
// hinter dem "="
//  Daten schon vorhanden -> Zustand wiederherstellen (nach Umschalten)
//  pDoc und aCursorPos nicht neu initialisieren
//DocShell hat keinen InputHandler mehr,
//hat der Anwender halt Pech gehabt.
// Jetzt nochmals zurueckschalten, da evtl. neues Doc geoeffnet wurde!
// wird nicht ueber Close zerstoert;
//Referenz Inputhandler zuruecksetzen
// if (pData) // wird nicht ueber Close zerstoert;
//  gehoert der InputHandler zu irgendeiner ViewShell ?
//                          Funktionen fuer rechte Seite
// HACK! um bei ColRowNames kein #REF! zu bekommen,
// wenn ein Name eigentlich als Bereich in die Gesamt-Formel
// eingefuegt wird, bei der Einzeldarstellung aber als
// single-Zellbezug interpretiert wird
// ColRowName im RPN-Code?
// ==1: einzelner ist als Parameter immer Bereich
// ==0: es waere vielleicht einer, wenn..
// Bereich
//  virtuelle Methoden von ScAnyRefDlg:
//  Referenz auf anderes Dokument - wie inputhdl.cxx
// per Default kann bei Referenzeingabe auch die Tabelle umgeschaltet werden
// Wenn durch Dokument-Umschalterei die Eingabezeile weg war/ist,
// ist der String leer. Dann nicht die alte Formel loeschen.
// Modal-Modus ausschalten
// pData wird ungueltig!
//Referenz Inputhandler zuruecksetzen
// Enable() der Eingabezeile erzwingen:
// auf das Dokument zurueckschalten
// (noetig, weil ein fremdes oben sein kann - #34222#)
// aktuelle Tabelle ggF. restaurieren (wg. Maus-RefInput)


7 / 11 | libreoffice-4.4.0.3/sc/source/ui/formdlg/privsplt.cxx
/*************************************************************************
#*  Member:     MouseButtonDown
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Reagiert auf einen einzelnen Mouse-Event. Nach Aufruf
#*              werden alle Mauseingaben an dieses Control weitergeleitet.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     MouseButtonUp
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Ende einer Benutzeraktion mit der Maus. Es werden
#*              die aktuelle Maus- Koordinaten ermittelt und fuer
#*              die Verschiebung des Fensters verwendet.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     MouseMove
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Reagiert kontinuierlich auf Mausbewegungen. Es werden
#*              die aktuelle Maus- Koordinaten ermittelt und fuer
#*              die Verschiebung des Fensters verwendet.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     SetYRange
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Setzt den Range fuer die Y- Verschiebung
#*
#*  Input:      neuer Bereich
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     GetDeltaY
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Liefert die relative x-Verschiebung zurueck
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     GetDeltaY
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Liefert die relative y-Verschiebung zurueck
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/
/*************************************************************************
#*  Member:     CtrModified
#*------------------------------------------------------------------------
#*
#*  Klasse:     ScPrivatSplit
#*
#*  Funktion:   Teilt einem installierten Handler mit, dass
#*              eine Veraenderung eingetreten ist.
#*
#*  Input:      ---
#*
#*  Output:     ---
#*
#************************************************************************/


1 / 5 | libreoffice-4.4.0.3/sc/source/ui/styleui/styledlg.cxx
// Seitenvorlagen


1 / 78 | libreoffice-4.4.0.3/sc/source/ui/app/transobj.cxx
//  CopyStyleFrom kopiert SetItems mit richtigem Pool


1 / 389 | libreoffice-4.4.0.3/sc/source/ui/app/inputhdl.cxx
//  Text zwischen Trennern


50 / 96 | libreoffice-4.4.0.3/sc/source/ui/navipi/navipi.cxx
//  Timeout, um Notizen zu suchen
//  Toleranz, wieviel ueber der eingeklappten Groesse noch klein ist
//! Eingabeueberpruefung (nur Zahlen oder nur Buchstaben, max 2 bzw 3 Stellen)
//! war vor VCL per nicht weitergeleitetem KeyInput
//! dafuer was neues ausdenken!!!
// LoseFocus wird bei VCL nicht gerufen
//  nKeyGroup wird bei VCL mangels KeyInput nicht mehr gesetzt
// setzt nCol
//  Modus umschalten ?
// auf Szenario
// ein/aus
//  Das Popupmenue fuer den Dropmodus muss im Click (Button Down)
//  statt im Select (Button Up) aufgerufen werden.
// vor SetDropMode (SetDropMode ruft SetItemImage)
//  den gehighlighteten Button aufheben
//  Umschalten-Button:
//  Einstellungen muessen anderswo gemerkt werden,
//  pInfo geht uns (ausser der Groesse) nichts mehr an
// von aussen vorgegebene Groesse
//  Die Groesse kann in einem anderen Modul geaendert worden sein,
//  deshalb muessen in Abhaengigkeit von der momentanen Groesse die
//  Inhalte eingeblendet werden oder nicht
//  wenn Szenario aktiv war, wieder einschalten
//  Die Groesse des Floats nicht neu setzen (sal_False bei SetListMode), damit der
//  Navigator nicht aufgeklappt wird, wenn er minimiert war (#38872#).
// FALSE: Groesse des Float nicht setzen
//  eListMode wird von aussen gesetzt, Root weiter unten
// bei NAV_LMODE_NONE gibts die nicht
//  war eine Kategorie als Root ausgewaehlt?
//  bei angedocktem Navigator wird das Fenster evtl. erst klein erzeugt,
//  dann kommt ein Resize auf die wirkliche Groesse -> dann Inhalte einschalten
//  Inhalte laut Config wieder einschalten
// FALSE: Groesse des Float nicht setzen
//  auch wenn die Inhalte nicht sichtbar sind, die Groessen anpassen,
//  damit die Breite stimmt
//  Tabellen hier nicht mehr
//  SFX_HINT_DOCCHANGED kommt nicht nur bei Dokument-Wechsel
// Notizen nicht sofort suchen
//! Eintraege selektieren ???
// SID_CURRENTCELL == Item #0 Cache leeren, damit das Setzen der
// aktuellen Zelle auch in zusammengefassten Bereichen funktioniert.
// ggf. Selektion aufheben
//  Tabelle fuer Basic ist 1-basiert
// dann nicht nochmal
// nicht mehr automatisch umschalten
// kompletter Eintrag zum Selektieren
//  pMarkArea auswerten ???
//  pMarkArea auswerten ???
//! kein Andocken, wenn Listbox nicht da ???
// nicht erlaubt


49 / 109 | libreoffice-4.4.0.3/sc/source/ui/navipi/content.cxx
//  Reihenfolge der Kategorien im Navigator -------------------------------------
// ROOT (0) muss vorne stehen
//  Current nur, wenn keine manuell eingestellt ist
//  (damit erkannt wird, wenn das Dokument nicht mehr existiert)
// invers zum suchen
// ausgeblendet ?
// wieder an die richtige Position:
// nicht, wenn ohne Children schon da
// mit allen Children
// ggf. neu eintragen
//  Wenn gleiche Bereichs- und DB-Namen existieren, wird
//  bei SID_CURRENTCELL der Bereichsname genommen.
//  DB-Bereiche darum direkt ueber die Adresse anspringen.
//  Aus dem ExecuteDrag heraus kann der Navigator geloescht werden
//  (beim Umschalten auf einen anderen Dokument-Typ), das wuerde aber
//  den StarView MouseMove-Handler, der Command() aufruft, umbringen.
//  angezeigtes Dokument
//  ausfuehren
//  angezeigtes Dokument
// Source-Datei als Help-Text
// anderes Dokument angezeigt
// anderes Dokument angezeigt
//  wenn sich nichts geaendert hat, gleich abbrechen (gegen Geflacker)
// ausgeblendet ?
// ausgeblendet ?
// ausgeblendet ?
// ausgeblendet ?
// ausgeblendet ?
//  in der Liste die Namen der Quellbereiche
// ausgeblendet ?
// kommt noch was
// Drop nur in dieses Dokument
//  in ExecuteDrag kann der Navigator geloescht worden sein
//  -> nicht mehr auf Member zugreifen !!!
// falls Dokument zum Draggen geladen wurde
//  als Link, damit asynchron ohne ImpMouseMoveMsg auf dem Stack auch der
//  Navigator geloescht werden darf
// nur der Name, ohne #...
// Inhalte aus geladenem Dokument holen
//  Dokument wird im dtor von ScDocumentLoader wieder geschlossen
// nach Selektion
// Inhalte nur wenn automatisch
//  eingestelltes Dokument existiert nicht mehr
// wieder automatisch
// sollte jetzt aktives sein
// rName wie im Menue/Listbox angezeigt
//  "aktiv" oder "inaktiv" weglassen
// ist es ein normal geladenes Doc ?
// verstecktes ausgewaehlt


2 / 8 | libreoffice-4.4.0.3/sc/source/ui/navipi/navcitem.cxx
//  Tabelle fuer Basic ist 1-basiert
//  gar nix mehr, wird ueber SFX_HINT_DOCCHANGED erledigt


15 / 61 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drtxtob.cxx
// abschalten der nicht erwuenschten Acceleratoren:
//  UndoManager wird beim Umschalten in den Edit-Modus umgesetzt...
// auf ganze Objekte
//  SetAttribs an der View selektiert ein Wort, wenn nichts selektiert ist
//  neues Feld einfuegen
//  InsertURL an der ViewShell schaltet bei "Text" die DrawShell ab !!!
//  Unterstreichung
//  Unterstreichung
// Harte Textattributierung loeschen
// bereits hier passiert
// Controller nicht angezeigt
//  Ausrichtung
//  Zeilenabstand
//  hoch-/tiefgestellt
//  Unterstreichung


15 / 99 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fudraw.cxx
/*************************************************************************
|*
|* Basisklasse fuer alle Drawmodul-spezifischen Funktionen
|*
\************************************************************************/
/*************************************************************************
|*
|* Modifier-Tasten auswerten
|*
\************************************************************************/
//  Alt     = zentrisch
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/
// in normale Draw-Shell, wenn Objekt selektiert, sonst Zeichnen aus
//  Beim Bezier-Editieren ist jetzt wieder das Objekt selektiert
// Scroll nach oben
// Scroll nach unten
// Scroll nach links
// Scroll nach rechts
/*************************************************************************
|*
|* Maus-Pointer umschalten
|*
\************************************************************************/
// kann nicht sein ?
//  kann mit ALT unterdrueckt werden
//  kann mit ALT unterdrueckt werden
//! muss da noch irgendwas gesetzt werden ????


12 / 76 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuins2.cxx
//! hier DLL's initalisieren, damit die Factories existieren?
// Starcalc nicht anzeigen
// damit DrawShell eingeschaltet wird (Objekt aktivieren ist unnoetig):
//  SvInsertObjectDialog (alles in einem Dialog) wird nicht mehr benutzt
// Rechteck mit ausgewogenem Kantenverhaeltnis
//  Chart initialisieren ?
// XXX Activate aus Makro ist toedlich !!! ???
// Objekt ist selektiert, also Draw-Shell aktivieren
//  in der idl fuer Basic steht FN_PARAM_4 als SfxBoolItem
//  -> wenn gesetzt, neue Tabelle, sonst aktuelle Tabelle
// auf neue Tabelle ausgeben?
//! erst hinterher ???


3 / 29 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/futext3.cxx
//  Editieren von Notiz-Legendenobjekten muss immer ueber StopEditMode beendet werden,
//  damit die Aenderungen ins Dokument uebernommen werden!
//  (Fontwork-Execute in drawsh und drtxtob passiert nicht fuer Legendenobjekte)


1 / 13 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drtxtob2.cxx
//  wenn kein Text editiert wird, Funktionen wie in drawsh


1 / 20 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconuno.cxx
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


2 / 12 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drawsh.cxx
// abschalten der nicht erwuenschten Acceleratoren:
// Harte Textattributierung loeschen


1 / 23 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconarc.cxx
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


8 / 38 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drawsh2.cxx
// Zustaende / Toggles
// Funktionen disablen
// nichts oder nur ein Objekt selektiert
//  Ausrichtung
// keine Ausrichtung an der Seite
// nichts selektiert
//  Anordnung
//  Clipboard / loeschen


2 / 28 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconrec.cxx
// wie stellt man den Font ein, mit dem geschrieben wird
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


9 / 34 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconstr.cxx
//  Maximal erlaubte Mausbewegung um noch Drag&Drop zu starten
//! fusel,fuconstr,futext - zusammenfassen!
//      Doppelklick auf Textobjekt? (->fusel)
//  bei Uno-Controls nicht in Textmodus
// jetzt den erzeugten FuText holen und in den EditModus setzen
// hat keine RTTI
//      SimpleMouseButtonUp - ohne Test auf Doppelklick
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/
// Zeichenmodus beenden


3 / 21 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconpol.cxx
// Texteingabe hier nicht zulassen
// Doppelklick nicht weiterreichen
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


2 / 7 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/futext2.cxx
//  Die EditEngine benutzt beim RTF Export (Clipboard / Drag&Drop)
//  den MapMode des RefDevices, um die Fontgroesse zu setzen


21 / 80 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fusel.cxx
//  Maximal erlaubte Mausbewegung um noch Drag&Drop zu starten
//! fusel,fuconstr,futext - zusammenfassen!
//  irgendwo muss es ja zurueckgesetzt werden (#50033#)
//Objekt verschieben
// Objekt am Rand getroffen
//      nichts getroffen
//Objekt selektieren
// VC rufen selber CaptureMouse
// Ein VCControl ist aktiv
// Event an den Manager weiterleiten
/******************************************************************
            * Objekt wurde verschoben
            ******************************************************************/
/**************************************************************************
    * Ggf. OLE-Objekt beruecksichtigen
    **************************************************************************/
//  aktivieren nur, wenn die Maus auch (noch) ueber dem
//  selektierten Objekt steht
// jetzt den erzeugten FuText holen und in den EditModus setzen
// hat keine RTTI
// Ein VCControl ist aktiv
// Event an den Manager weiterleiten
//  Command-Handler fuer Kontext-Menue kommt erst nach MouseButtonUp,
//  darum hier die harte IsLeft-Abfrage
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


20 / 80 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/futext.cxx
//  Maximal erlaubte Mausbewegung um noch Drag&Drop zu starten
//! fusel,fuconstr,futext - zusammenfassen!
// Event von der SdrView ausgewertet
// Danebengeklickt, Ende mit Edit
//!??   ohne uebergebenen Outliner stimmen die Defaults nicht ???!?
//  Notizen editieren -> keine neuen Textobjekte erzeugen,
/**********************************************************
                    * Objekt erzeugen
                    **********************************************************/
// Event von der SdrView ausgewertet
// Event von der SdrView ausgewertet
//  Lauftext-Objekt erzeugen?
// die fuer das Scrollen benoetigten Attribute setzen
//  Modus verlassen bei einzelnem Klick
/*************************************************************************
|*
|* Maus-Pointer umschalten
|*
\************************************************************************/
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/
//  Sofort in den Edit Mode setzen
/**********************************************************************
        * Kein Textobjekt im EditMode, daher CreateMode setzen
        **********************************************************************/
/*************************************************************************
|*
|* Selektion hat sich geaendert
|*
\************************************************************************/
/**********************************************************************
        * Kein Textobjekt im EditMode, daher CreateMode setzen
        **********************************************************************/
/*************************************************************************
|*
|* Objekt in Edit-Mode setzen
|*
\************************************************************************/
//!??   ohne uebergebenen Outliner stimmen die Defaults nicht ???!?


4 / 32 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drawsh5.cxx
// Darf man eine URL an dem Objekt setzen?
//  InsertURL an der ViewShell schaltet bei "Text" die DrawShell ab !!!
//          Funktionen auf Drawing-Objekten
// wer weiss, wie lange das funktioniert? (->vom Abreisscontrol funktioniert es)


13 / 39 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fupoor.cxx
/*************************************************************************
|*
|* Scrollen bei Erreichen des Fensterrandes; wird von
|* MouseMove aufgerufen
|*
\************************************************************************/
/*************************************************************************
|*
|* Timer-Handler fuer Fensterscrolling
|*
\************************************************************************/
/*************************************************************************
|*
|* String in Applikations-Statuszeile ausgeben
|*
\************************************************************************/
//  WriteStatus gibt's nicht mehr
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/
//!!! sollte Joe eigentlich machen:
// nur, wenn im Outliner was selektiert ist, darf
// Command sal_True zurueckliefern:
//  ExecuteDrag (und das damit verbundene Reschedule) direkt aus dem Timer
//  aufzurufen, bringt die VCL-Timer-Verwaltung durcheinander, wenn dabei
//  (z.B. im Drop) wieder ein Timer gestartet wird (z.B. ComeBack-Timer der
//  dann um die Dauer des Drag&Drop zu spaet ab.
//  Darum Drag&Drop aus eigenem Event:


2 / 8 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/drtxtob1.cxx
// Die Werte sind erst einmal uebernommen worden, um den Dialog anzuzeigen.
// Muss natuerlich noch geaendert werden


1 / 26 | libreoffice-4.4.0.3/sc/source/ui/drawfunc/fuconcustomshape.cxx
/*************************************************************************
|*
|* Tastaturereignisse bearbeiten
|*
|* Wird ein KeyEvent bearbeitet, so ist der Return-Wert sal_True, andernfalls
|* FALSE.
|*
\************************************************************************/


3 / 12 | libreoffice-4.4.0.3/sc/source/ui/optdlg/tpusrlst.cxx
// Benutzerdefinierte Listen:
// Modifikationen noch nicht uebernommen?
// -> Click auf Add-Button simulieren


1 / 13 | libreoffice-4.4.0.3/sc/source/ui/optdlg/tpview.cxx
// nur diese Metriken benutzen


1 / 6 | libreoffice-4.4.0.3/sc/source/ui/optdlg/tpcalc.cxx
// alle weiteren Optionen werden in den Handlern aktualisiert


2 / 7 | libreoffice-4.4.0.3/sc/source/ui/optdlg/opredlin.cxx
//  Repaint (wenn alles ueber Items laufen wuerde, wie es sich gehoert,
//  waere das nicht noetig...)


1 / 20 | libreoffice-4.4.0.3/sc/source/ui/attrdlg/tabpages.cxx
// Zellschutz-Tabpage:


2 / 19 | libreoffice-4.4.0.3/sc/source/ui/dbgui/imoptdlg.cxx
//  Der Options-String darf kein Semikolon mehr enthalten (wegen Pickliste)
//  darum ab Version 336 Komma stattdessen


11 / 22 | libreoffice-4.4.0.3/sc/source/ui/dbgui/sfiltdlg.cxx
// may be overwritten below
// Optionen initialisieren lassen:
//  Spezialfilter braucht immer Spaltenkoepfe
// Modal-Modus einschalten
//@BugID 54702 Enablen/Disablen nur noch in Basisklasse
//SFX_APPWINDOW->Disable(false);        //! allgemeine Methode im ScAnyRefDlg
// Uebergabe eines mit der Maus selektierten Tabellenbereiches, der dann als
// neue Selektion im Referenz-Edit angezeigt wird.
// Nur moeglich, wenn im Referenz-Editmodus
/*
             * Alle Edit-Felder enthalten gueltige Bereiche.
             * Nun wird versucht aus dem Filterbereich
             * ein ScQueryParam zu erzeugen:
             */
// alle 50ms nachschauen, ob RefInputMode noch stimmt


11 / 18 | libreoffice-4.4.0.3/sc/source/ui/dbgui/pfiltdlg.cxx
// ist nicht im QueryParam
// fuer leichteren Zugriff:
/*
         * Ueberpruefen, ob es sich bei dem uebergebenen
         * Bereich um einen Datenbankbereich handelt:
         */
// Feldlisten einlesen und Eintraege selektieren:
// "keiner" selektieren
/*
             * Dialog liefert die ausgezeichneten Feldwerte "leer"/"nicht leer"
             * als Konstanten in nVal in Verbindung mit dem Schalter
             * bQueryByString auf FALSE.
             */
// Woher kommen diese Werte?
/*
     * Behandlung der Enable/Disable-Logik,
     * abhaengig davon, welche ListBox angefasst wurde:
     */
//  bei Gross-/Kleinschreibung die Werte-Listen aktualisieren
// wenn einer der Sonderwerte leer/nicht-leer
// gewaehlt wird, so macht nur der =-Operator Sinn:


2 / 8 | libreoffice-4.4.0.3/sc/source/ui/dbgui/scendlg.cxx
//  CopyAll nicht
//! beim Editieren testen, ob eine andere Tabelle den Namen hat!


3 / 19 | libreoffice-4.4.0.3/sc/source/ui/dbgui/tpsubt.cxx
// auslesen, wenn schon teilweise gefuellt
// Anzahl der Array-Elemente
// auslesen, wenn schon teilweise gefuellt


19 / 33 | libreoffice-4.4.0.3/sc/source/ui/dbgui/dbnamdlg.cxx
//  damit die Strings in der Resource bei den FixedTexten bleiben koennen:
// Default: mit Spaltenkoepfen
// Feststellen, ob definierter DB-Bereich markiert wurde:
// Uebergabe eines mit der Maus selektierten Tabellenbereiches, der dann als
//  neue Selektion im Referenz-Fenster angezeigt wird.
//  kein NameModifyHdl, weil sonst Bereiche nicht geaendert werden koennen
//  (nach dem Aufziehen der Referenz wuerde der alte Inhalt wieder angezeigt)
//  (der ausgewaehlte DB-Name hat sich auch nicht veraendert)
// Der View die Aenderungen und die Remove-Liste uebergeben:
// beide werden nur als Referenz uebergeben, so dass an dieser
// Stelle keine Speicherleichen entstehen koennen:
//  weil jetzt editiert werden kann, muss erst geparst werden
//  Bereich veraendern
//  neuen Bereich einfuegen
// Default: mit Spaltenkoepfen
// Default: mit Spaltenkoepfen
//@BugID 54702 Enablen/Disablen nur noch in Basisklasse
//SFX_APPWINDOW->Disable(sal_False);        //! allgemeine Methode im ScAnyRefDlg
//@BugID 54702 Enablen/Disablen nur noch in Basisklasse


2 / 11 | libreoffice-4.4.0.3/sc/source/ui/dbgui/scuiimoptdlg.cxx
// im Ctor-Initializer nicht moeglich (MSC kann das nicht):
// kein Trennzeichen


3 / 10 | libreoffice-4.4.0.3/sc/source/ui/dbgui/foptmgr.cxx
// Zielbereichsliste fuellen
// beim Aufruf immer an
/*
         * Ueberpruefen, ob es sich bei dem uebergebenen
         * Bereich um einen Datenbankbereich handelt:
         */


21 / 219 | libreoffice-4.4.0.3/sc/source/ui/view/viewdata.cxx
//  bei IdleFormat wird manchmal ein Cursor gemalt, wenn die View schon weg ist (23576)
// Papersize -> kein H-Scrolling
// sichtbarer Ausschnitt
//  Margin ist schon bei der urspruenglichen Breite beruecksichtigt
//! nicht immer noetig!
// Faktor ist Drucker zu Bildschirm
//  nZoom (bis 364v) oder nZoom/nPageZoom/bPageMode (ab 364w)
//  Tab-ControlBreite
//  PosX[links]/PosX[rechts]/PosY[oben]/PosY[unten]
//  wenn Zeilen groesser 8192, "+" statt "/"
// Numerierung darf auf keinen Fall durcheinanderkommen
// Leerer String kommt bei "neu Laden"
//  beim Reload in der Seitenansicht sind evtl. die Preview-UserData
//  stehengelassen worden. Den Zoom von der Preview will man hier nicht...
// nicht pro Tabelle:
//  Tabelle kann ungueltig geworden sein (z.B. letzte Version):
// wenn vorhanden, TabBar-Breite holen:
// '+' ist nur erlaubt, wenn wir mit Zeilen > 8192 umgehen koennen
//  Test, ob der aktive Teil laut SplitMode ueberhaupt existiert
//  dann wieder auf Default (unten links)
// RecalcPixPos oder so - auch nMPos - auch bei ReadUserData ??!?!


9 / 26 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshe.cxx
// Range auf eine Datenzeile begrenzen
// (nur wenn der Aufruf aus einem Format-Dialog kommt)
//  Tab/CR durch Space ersetzen, wenn fuer Dialog oder per Basic/SelectionTextExt,
//  oder wenn es eine einzelne Zeile ist.
//  Sonst mehrzeilig mit Tabs beibehalten (z.B. Mail oder Basic/SelectionText).
//  Fuer Mail werden die Tabs dann spaeter in (mehrere) Spaces gewandelt.
// Default ist jetzt Text
//  Request ausfuehren (dabei wird das SearchItem gespeichert)
//  nochmal mit ScGlobal::GetSearchItem()


1 / 61 | libreoffice-4.4.0.3/sc/source/ui/view/preview.cxx
//  die angezeigte Page der DrawView umzustellen (s.u.) funktioniert nicht ?!?


18 / 155 | libreoffice-4.4.0.3/sc/source/ui/view/output.cxx
//! um den einen Pixel sieht das Metafile (oder die Druck-Ausgabe) anders aus
//! als die Bildschirmdarstellung, aber wenigstens passen Druck und Metafile zusammen
//  Seitenumbrueche auch in ausgeblendeten suchen
//  ohne Pen wird bei DrawPolygon rechts und unten
//  ein Pixel weggelassen...
//  ohne Pen wird bei DrawPolygon rechts und unten
//  ein Pixel weggelassen...
// Attribute in FillInfo nicht gesetzt
//! Seitengrenzen fuer Druck beruecksichtigen !!!!!
//  erst hinterher im zweiten Schritt die Linien fuer normale Ausgabe loeschen
// sichtbarer Teil +- 1
//  horizontal: angrenzende Linie verlaengern
//  (nur, wenn die gedrehte Zelle eine Umrandung hat)
// nix da oder abgeschaltet
//  Clipping passiert von aussen
//! ohne Clipping, nur betroffene Zeilen painten ??!??!?
// auch noch von der naechsten Zelle, weil die Markierung
// in die jeweils vorhergehende Zelle hineinragt


104 / 257 | libreoffice-4.4.0.3/sc/source/ui/view/tabview3.cxx
// StarCalc kennt nur Absatz- bzw. Zellformat-Vorlagen
//      SetCursor - Cursor setzen, zeichnen, InputWin updaten
//                  oder Referenz verschicken
//      ohne Optimierung wegen BugId 29307
//  DeactivateIP nur noch bei MarkListHasChanged
// 23259 oder so
// Eingabezeile / Menues updaten
// -> Fehlermeldungen anzeigen
//  Funktionen, die evtl disabled werden muessen
//  nur wegen Zellschutz:
// Abfrage, damit RefMode bei Tabellenwechsel funktioniert
//  Broadcast, damit andere Views des Dokuments auch umschalten
//  UpdateInputHandler jetzt in CellContentChanged
//! Abfrage, ob an gleicher Stelle !!!!
//  Cursor sichtbar?
// HintWindow anlegen, bestimmt seine Groesse selbst
//! auch Spelling ??? (dann beim Aufruf Membervariable setzen)
//  Suchen & Ersetzen
//  Aenderungen uebernehmen
//  Bildschirm an Cursorposition anpassen
//  aktiven Teil umschalten jetzt hier
//  eigentliches Align
//  falls z.B. Suchen-Dialog offen ist, Cursor nicht hinter den Dialog stellen
//  wenn moeglich, die Zeile mit dem Cursor oberhalb oder unterhalb des Dialogs
//! nicht, wenn schon komplett sichtbar
//  ueberdeckt der Dialog das GridWin?
// es wird sowieso gescrollt
//  Cursor ist auf dem Bildschirm
// Zelle vom Dialog ueberdeckt
// unter der letzten betroffenen Zelle
// Pos. kann nicht negativ werden
//  nochmal aktiven Teil umschalten
//  MoveCursor - mit Anpassung des Bildausschnitts
//  aktiven Teil umschalten jetzt in AlignToCursor
//!     auf OS/2: SC_FOLLOW_JUMP statt SC_FOLLOW_LINE, um Nachlaufen zu verhindern ???
// Markierung stehenlassen
//  Wenn der Cursor nicht bewegt wurde, muss das SelectionChanged fuer das
//  Aufheben der Selektion hier einzeln passieren:
// letzter benutzter Bereich
//  nach Tab und Enter wieder zur Ausgangsspalte
// naechste/vorherige nicht geschuetzte Zelle
// auf diese Spalte zurueck bei Enter
//  in MoveCursorRel wird die TabCol zurueckgesetzt...
// Wenn Cursor gesetzt wird, immer auch alignen
//  SetTabNo    - angezeigte Tabelle
//  Die FormShell moechte vor dem Umschalten benachrichtigt werden
//! Fehlermeldung? oder macht das die FormShell selber?
//! Fehler-Flag zurueckgeben und Aktionen abbrechen
// Die FormShell sagt, es kann nicht umgeschaltet werden
//  nicht InputEnterHandler wegen Referenzeingabe !
// naechste sichtbare suchen
// Abfrage, damit RefMode bei Tabellenwechsel funktioniert
//  UpdateShow noch vor SetCursor, damit UpdateAutoFillMark die richtigen
//  Fenster findet (wird aus SetCursor gerufen)
// falls das aktive Fenster anders ist
//  Fixierungen
//  Form-Layer muss den sichtbaren Ausschnitt der neuen Tabelle kennen
//  dafuer muss hier schon der MapMode stimmen
// Gestalter
// Gestalter
//  Paint-Funktionen - nur fuer diese View
// Col wird sowieso bis zum Ende gezeichnet
//  GrabFocus immer dann, wenn diese View aktiv ist und
//  die Eingabezeile den Focus hat
//      So soll es gemacht werden, damit der Sfx es mitbekommt, klappt aber nicht:
//      deshalb erstmal so:
//  Cursor-Abfrage erst nach GrabFocus
//  PaintArea -Block neu zeichnen
// ALL oder MARKS
//  dazu muesste ScColumn::IsEmptyBlock optimiert werden
//  (auf Search() umstellen)
// Justify fuer die Abfragen unten
//  wegnehmen -> Repaint
//  SC_UPDATE_MARKS: Invalidate, nicht bis zum Zeilenende
//  nur an den Raendern entlang
//  fuer Chart-Daten-Markierung
//  PaintGrid - Datenbereiche neu zeichnen
//  PaintTop - obere Kontrollelemente neu zeichnen
//  Fixierung anpassen (UpdateFixX setzt HSplitPos neu)
//  zeichnen
//! allgemeiner ?
//  PaintLeft - linke Kontrollelemente neu zeichnen
//  Pixel-Position der oberen Kante
//  Fixierung anpassen (UpdateFixY setzt VSplitPos neu)
//  zeichnen
//  keine Assertion mehr - kommt vor, wenn vorher im Drag&Drop
//  auf ein anderes Dokument umgeschaltet wurde
// wird nur bei MDI-(De)Activate gerufen
// aViewData.Activate hinten wegen Cursor-Show bei KillEditView
//  Markierung nicht mehr loeschen - wenn an der ViewData Activate(false) gesetzt ist,
//  wird die Markierung nicht ausgegeben
//  Referenzeingabe nicht abbrechen, um Referenzen auf
//  andere Dokumente zuzulassen
// Repaint, Markierung je nach Active-Status
//  hier nicht mehr selber GrabFocus rufen!
//  Wenn das Doc bearbeitet wird, ruft der Sfx selber GrabFocus am Fenster der Shell.
//  Wenn es z.B. ein Mailbody ist, darf es den Focus nicht bekommen (Bug #43638#)
//  Tracking statt CaptureMouse, damit sauber abgebrochen werden kann
//  (SelectionEngine ruft CaptureMouse beim SetWindow)
//! Irgendwann sollte die SelectionEngine selber StartTracking rufen!?!
//  GrabFocus nur, wenn vorher das andere GridWindow den Focus hatte
//  (z.B. wegen Suchen & Ersetzen)
//  GetGridWidth - Breite eines Ausgabebereichs (fuer ViewData)
//  GetGridHeight - Hoehe eines Ausgabebereichs (fuer ViewData)


5 / 18 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshh.cxx
//  Objekte aktivieren/deaktivieren immer auf der sichtbaren View
//  in beiden Faellen erstmal auf der sichtbaren View selektieren
//! von irgendwas in 1/100mm umrechnen ??????
//! Member von ScDrawView?
//! von 1/100mm in irgendwas umrechnen ??????


4 / 12 | libreoffice-4.4.0.3/sc/source/ui/view/olkact.cxx
//  VC's und den Browser dazu gibts nicht mehr...
//  GetSbxForm gibt's nicht mehr, muss auch nichts mehr angemeldet werden
//  VC's und den Browser dazu gibts nicht mehr...
//  GetSbxForm gibt's nicht mehr, muss auch nichts mehr angemeldet werden


53 / 185 | libreoffice-4.4.0.3/sc/source/ui/view/formatsh.cxx
// Die Abfrage, ob markiert ist, war hier immer falsch,
// darum jetzt gar nicht mehr, und einfach vom Cursor.
// Wenn Attribute aus der Selektion genommen werden sollen,
// muss noch darauf geachtet werden, Items aus Vorlagen nicht
// zu uebernehmen (GetSelectionPattern sammelt auch Items aus
// Vorlagen zusammen) (#44748#)
//  bedingte Formatierung und Gueltigkeit nicht uebernehmen,
//  weil sie in der Vorlage nicht editiert werden koennen
// wenn neuer Style vorhanden und in der Selektion
// verwendet wird, so darf der Parent nicht uebernommen
// wenn bereits vorhanden, erstmal entfernen...
// Style-Pointer zu Namen vor Erase,
// weil Zellen sonst ungueltige Pointer
// enthalten.
//!!! bei Gelenheit mal eine Methode, die
//    das fuer einen bestimmten Style macht
// ...und neu anlegen
// wenn ein Style vorhanden ist, so wird dieser
// Parent der neuen Vorlage:
// Namen zu Style-Pointer
// Attribute uebernehmen und Style anwenden
// wenn bereits vorhanden, erstmal entfernen...
// ...und neu anlegen
// Attribute uebernehmen
// wenn in Verwendung -> Update
// Neu anlegen oder bearbeiten ueber Dialog:
// alte Items aus der Vorlage merken
// NumberFormat Value aus Value und Language
// erzeugen und eintueten
// auch in aOldSet fuer Vergleich nach dem Dialog,
// sonst geht evtl. eine Aenderung der Sprache verloren
//  auf jeden Fall ein SvxBoxInfoItem mit Table = sal_False im Set:
//  (wenn gar kein Item da ist, loescht der Dialog auch das
//   BORDER_OUTER SvxBoxItem aus dem Vorlagen-Set)
// keine inneren Linien
//  Attribut-Vergleiche (frueher in ModifyStyleSheet)
//  jetzt hier mit den alten Werten (Style ist schon veraendert)
//! auch fuer Seitenvorlagen die Abfragen hier
//  falls zwischendurch etwas mit dem temporaer geaenderten
//  ItemSet gepainted wurde:
// Eingabe beenden
/*
         * "Selbstgemachte" RadioButton-Funktionalitaet
         * Beim Toggle gibt es den Standard-State, d.h. kein
         * Button ist gedrueckt
         */
// ohne Parameter als Toggle
// Default-Linie aktualisieren
// Default-Linie aktualisieren
// Border-Items vom Controller auswerten:
// ATTR_BACKGROUND (=SID_ATTR_BRUSH) muss ueber zwei IDs
// gesetzt werden:
// ItemStates mitkopieren
// eigene Kontrolle ueber RadioButton-Funktionalitaet:
// Unterstreichung
// horizontale Ausrichtung
// vertikale Ausrichtung


2 / 47 | libreoffice-4.4.0.3/sc/source/ui/view/drawvie4.cxx
//  Korrektur fuer 100% berechnen, unabhaengig von momentanen Einstellungen
//  Pixel-Korrektur beruecksichtigen, damit Bitmap auf dem Bildschirm stimmt


2 / 178 | libreoffice-4.4.0.3/sc/source/ui/view/viewfun2.cxx
//  Suchen & Ersetzen
// Pages auf dem Drawing-Layer


12 / 42 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshb.cxx
//  wird aus dem Paint gerufen
//  wenn schon connected ist, nicht nochmal SetObjArea/SetSizeScale
// kompatibel zum SdrOle2Obj
// sichtbarer Ausschnitt wird nur inplace veraendert!
// Gueltigkeits-Hinweisfenster nicht ueber dem Objekt stehenlassen
// kompatibel zum SdrOle2Obj
// sichtbarer Ausschnitt wird nur inplace veraendert!
// SfxViewShell::DoVerb zeigt seine Fehlermeldungen selber an
//! SetDocumentName sollte schon im Sfx passieren ???
// soll nicht sein
//  Rahmen fuer Chart einfuegen wird abgebrochen:
//          Der Server moechte die Clientgrosse verandern


13 / 50 | libreoffice-4.4.0.3/sc/source/ui/view/gridwin5.cxx
// der letzte gewinnt
// Content gewinnt
// Move gewinnt
//  bei geloeschten Spalten: Pfeil auf die linke Seite der Zelle
//  Notiz nur, wenn sie nicht schon auf dem Drawing-Layer angezeigt wird:
// schon eine Notiz angezeigt
// dieselbe
// dann stehenlassen
// alte Tip/Balloon ausschalten
// nur ohne gedrueckten Button
// URL fuer IMapObject unter Pointer ist Hilfetext
//  Bei ImageMaps die Description anzeigen, wenn vorhanden
//  Wenn QuickHelp fuer AutoFill angezeigt wird, nicht wieder wegnehmen lassen


33 / 77 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh3.cxx
// der kommt beim MouseButtonUp
// Einfuege-Position
// ausfuehren
// OK aus Dialog
// Menue oder Basic
// aus Selektion
// 100%, nicht auf Seiten
// Zellen sollen nicht markiert werden
// Ist es benahmster Bereich (erst Namen dann DBBereiche) ?
//  1-basierte Zeilennummer
// wir haben was gefunden
// ist derselbe Bereich schon markiert?
// und Cursor setzen
// zusammengefasste Zellen beruecksichtigen:
//  Navigator-Aufrufe sind nicht API!!!
// sonst wenigstens aufzeichnen
// kein gueltiger Bereich
//  wenn es ein Tabellenname ist, umschalten (fuer Navigator/URL's)
//  Grafik-Objekte probieren (nur bei URL's)
//  Tabelle fuer Basic ist 1-basiert
// zu aktivierenden ViewFrame suchen
//XXX wird von SFX erledigt
// nicht bei OLE
//  SID_TABLE_ACTIVATE und SID_MARKAREA werden von Basic aus an der versteckten
//  View aufgerufen, um auf der sichtbaren View zu markieren/umzuschalten:
// Y wird angezeigt
// aufheben
// erzeugen
// aufheben
// erzeugen oder fixieren
//  wird von den Forms gerufen, wenn die DrawView mit allem Zubehoer
//  angelegt werden muss
// damit sofort wieder eingegeben werden kann


11 / 64 | libreoffice-4.4.0.3/sc/source/ui/view/editsh.cxx
// hat Eingabezeile den Focus?
// Insert-Taste, weil als Acc definiert
//  SetAttribs an der View selektiert ein Wort, wenn nichts selektiert ist
//  Referenz wird selektiert -> beim Tippen nicht ueberschreiben
//  neues Feld einfuegen
//  jetzt doch auch Felder in der Top-View
//  InsertURL an der ViewShell schaltet bei "Button"
//  die EditShell ab, darum sofort return
//  Unterstreichung
//! Testen, ob Klammer-Hervorhebung aktiv ist !!!!
// hervorgehobene Klammern hier nicht


3 / 18 | libreoffice-4.4.0.3/sc/source/ui/view/drawvie3.cxx
// Verankerung setzen
// Grafik vom Objekt besorgen
// aus imapwrap


28 / 60 | libreoffice-4.4.0.3/sc/source/ui/view/tabview5.cxx
//  Hier noch nichts anzeigen (Show), weil noch falsch angeordnet ist
//  Show kommt dann aus UpdateShow beim ersten Resize
//  UpdateShow kommt beim Resize, oder bei Kopie einer bestehenden View aus dem ctor
//  DrawView darf nicht im TabView - ctor angelegt werden,
//  wenn die ViewShell noch nicht konstruiert ist...
//  Das gilt auch fuer ViewOptionsHasChanged()
// solange GridWin's noch existieren
// wegen Invalidate im DrawView ctor (ShowPage),
// damit gleich gezeichnet werden kann
// beendet auch Text-Edit-Modus
// PageSize ist pro Page unterschiedlich
// fuer neue Page
//  Es gibt keine einfache Moeglichkeit, alle Slots der FormShell zu invalidieren
//  (fuer disablete Slots auf geschuetzten Tabellen), darum hier einfach alles...
//  DrawView erzeugen, wenn Gitter angezeigt werden soll
// Helper-Funktion gegen das Include des Drawing Layers
//  Animierte GIFs muessen wieder gestartet werden:
// rechts raus
// rechter Rand sichtbar
// links sichtbar (falls zu gross)
// unten raus
// unterer Rand sichtbar
// oben sichtbar (falls zu gross)
// linker Rand sichtbar
// oben raus
// oberer Rand sichtbar
// Spalten/Zeilen - um mindestens nScrollX/Y scrollen
// ausfuehren


80 / 561 | libreoffice-4.4.0.3/sc/source/ui/view/output2.cxx
//! Autofilter-Breite mit column.cxx zusammenfassen
// Verbindung
// aus bedingter Formatierung
// aus Attributen erzeugt
//  SetPatternSimple: ohne Font
//  pPattern auswerten
//  Orientierung
//  Wenn auf dem Drucker das Leading 0 ist, gibt es Probleme
//  -> Metric vom Bildschirm nehmen (wie EditEngine!)
//  Zahlenformat
//  zumindest die Text-Groesse muss neu geholt werden
//! unterscheiden, und den Text nicht neu vom Numberformatter holen?
//  wird gerufen, wenn sich die Font-Variablen nicht aendern (!StringDiffer)
//  Zahlenformat
// immer neu formatieren
// nur fuer Ausgabe
// naechstes Mal wieder hierherkommen
//  sonst String/Groesse behalten
// derselbe Text kann in der naechsten Zelle wieder passen
//  kein vertikales Clipping beim Drucken von Zellen mit
//  optimaler Hoehe, ausser bei Groesse in bedingter Formatierung
//  nur die betroffene Dimension clippen,
//  damit bei nicht-proportionalem Resize nicht alle
//  rechtsbuendigen Zahlen abgeschnitten werden:
//  in Metafiles immer DrawTextArray, damit die Positionen mit
//  aufgezeichnet werden (fuer nicht-proportionales Resize):
// Text und Attribute
//  keine Para-Attribute uebrigbehalten...
//! Flag setzen, um die Zelle in DrawRotated wiederzufinden ?
//! (oder Flag schon bei DrawBackground, dann hier keine Abfrage)
// gedreht wird getrennt ausgegeben
// bei bSimClip nur aClipRect initialisieren
//  kein hartes Clipping, aber nur die betroffenen
//  Zeilen ausgeben
// bei bSimClip nur aClipRect initialisieren
// bei bSimClip nur aClipRect initialisieren
//  kein hartes Clipping, aber nur die betroffenen
//  Zeilen ausgeben
//! Flag setzen, um die Zelle in DrawRotated wiederzufinden ?
//! (oder Flag schon bei DrawBackground, dann hier keine Abfrage)
// gedreht wird getrennt ausgegeben
// bei bSimClip nur aClipRect initialisieren
// 0 fuer Reste von zusammengefassten
// vorher wird einzeln berechnet
// wegen Ueberhaengen
//! von aussen rufen ?
//! nRotMax speichern
// 0 fuer Reste von zusammengefassten
// vorher wird einzeln berechnet
//! Rest von zusammengefasster Zelle weiter oben funktioniert nicht!
//  Ersatzdarstellung fuer zu kleinen Text weggelassen
// Zusammengefasst
// Syntax-Modus wird hier ignoriert...
// Ausrichtung fuer EditEngine
// Adjustment fuer bBreak ist hier weggelassen
//!     Position und Papersize auf EditUtil umstellen !!!
// ohne Rand abzuziehen
//  Rotation schon hier, um bei Umbruch auch PaperSize anzupassen
// keinen Ueberlauf
// zum Zentrieren
//! richtige PaperSize fuer Umbruch haengt von der Zeilenzahl
//! ab, solange die Zeilen nicht einzeln versetzt ausgegeben
//! werden koennen -> darum unbegrenzt, also kein Umbruch.
//! Mit versetzten Zeilen waere das folgende richtig:
// Scale ist immer 1
//  Daten aus Zelle lesen
// Scale ist immer 1
//  wenn gedreht, Groesse anpassen
//! begrenzen !!!
//  hier nur gedrehter Text
//! vorher abfragen !!!
//! weglassen, was nicht hereinragt
//  weiterschreiben
// nur Rest ausgeben!
//  gedrehten, ausgerichteten Text nur an den
//  Seitengrenzen clippen
//  horizontale Ausrichtung
//  bei gedrehtem Text ist Standard zentriert
//! begrenzen !!!
//! begrenzen !!!


42 / 217 | libreoffice-4.4.0.3/sc/source/ui/view/dbfunc3.cxx
//  Outline-Gruppierung erzeugen
//  Outline-Gruppierung loeschen
//  Menue-Status: Outlines loeschen
//  Spalten
// nicht wenn ganze Zeilen markiert
//  Zeilen
// nicht wenn ganze Spalten markiert
// ganze Tabelle, wenn nichts markiert
//  Outline-Ebene auswaehlen
//  einzelne Outline-Gruppe einblenden
//  einzelne Outline-Gruppe ausblenden
//  Menue-Status: markierten Bereich ein-/ausblenden
//  Spalten
//  Zeilen
//  markierten Bereich einblenden
//  markierten Bereich ausblenden
//          Teilergebnisse
// sal_False = nur loeschen
// nicht in zusammengefasste einfuegen
// "StarCalc" "Daten loeschen?"
// Bereichsende wird veraendert
// alte Daten sichern
// Zeilen/Spaltenstatus
//  Datenbereich sichern - incl. Filter-Ergebnis
//  alle Formeln wegen Referenzen
//  DB- und andere Bereiche
//  Teilergebnis-Felder vor die Sortierung setzen
//  (doppelte werden weggelassen, kann darum auch wieder aufgerufen werden)
// "Kann keine Zeilen einfuegen"
//          DB-Operationen (Sortieren, Filtern, Teilergebnisse) wiederholen
//!     Undo nur benoetigte Daten ?
// Zeilen/Spaltenstatus
//  Datenbereich sichern - incl. Filter-Ergebnis
//  alle Formeln wegen Referenzen
//  DB- und andere Bereiche
//  Sortieren ohne SubTotals
// wird unten wieder zurueckgesetzt
// Bereich kann sich geaendert haben
// Bereich kann sich geaendert haben
//  bei nicht-inplace kann die Tabelle umgestellt worden sein
// Bereich kann sich geaendert haben
// "Keine Operationen auszufuehren"


10 / 59 | libreoffice-4.4.0.3/sc/source/ui/view/tabcont.cxx
// Appear und SetViewFrame
// darf jetzt nicht umgeschaltet werden ?
//  den alten Zustand des TabControls wiederherstellen:
// kann vorkommen, wenn bei Excel-Import alles versteckt ist
//  InputEnterHandler nur wenn nicht Referenzeingabe
//  Tabelle fuer Basic ist 1-basiert
//  SetReference nur wenn der Konsolidieren-Dialog offen ist
//  (fuer Referenzen ueber mehrere Tabellen)
//  bei anderen gibt das nur unnoetiges Gezappel
// ViewFrame erstmal aktivieren (Bug 19493):


2 / 51 | libreoffice-4.4.0.3/sc/source/ui/view/prevwsh.cxx
//! Basic etc. -> auslagern in eigene Datei (s. tabvwsh4)
// InputHdl ist jetzt meistens Null, keine Assertion mehr!


6 / 12 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh8.cxx
//  Text enthalten: Anzahl2 >= 1
//  Move an der ViewShell soll eigentlich vom Sfx gerufen werden, wenn sich
//  das Frame-Window wegen unterschiedlicher Toolboxen o.ae. verschiebt
//  (um nicht aus Versehen z.B. Zeichenobjekte zu verschieben, #56515#).
//  Dieser Mechanismus funktioniert aber momentan nicht, darum hier der Aufruf
//  per Hand (im Move wird verglichen, ob die Position wirklich geaendert ist).


34 / 46 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh5.cxx
// ohne Parameter
//  AnchorFlag, damit gleich mit Control angehaengt werden kann
//  beim "Save as" kann ein vorher schreibgeschuetztes Dokument
//  bearbeitbar werden, deshalb die Layer-Locks neu (#39884#)
//  (Invalidate etc. passiert schon vom Sfx her)
//  bei SID_EDITDOC kommt kein SFX_HINT_TITLECHANGED, darum
//  der eigene Hint aus DoSaveCompleted
//  Design-Modus bei jedem Speichern anzupassen, waere zuviel
//  (beim Speichern unter gleichem Namen soll er unveraendert bleiben)
//  Darum nur bei SFX_HINT_MODECHANGED (vom ViewFrame)
//  Da man sich nicht mehr darauf verlassen kann, woher
//  dieser Hint kommt, den Design-Modus immer dann umschalten, wenn der
//  ReadOnly-Status sich wirklich geaendert hat:
// neu zeichnen
// zuerst, falls Tabelle weg ist !!!
//  ScEditViewHint kommt nur an aktiver View an
// sollte nicht gesetzt sein
//  MakeEditView geht schief, wenn der Cursor ausserhalb des
//  Bildschirms steht. GetEditView gibt dann eine nicht aktive
//  View zurueck, darum die Abfrage HasEditView.
// ist nicht 0
// Tabelle eingefuegt / geloescht
//  aktuelle Tabelle zuerst holen (kann bei DeleteTab an ViewData geaendert werden)
//  hier keine Abfrage auf IsActive() mehr, weil die Aktion von Basic ausgehen
//  kann und dann auch die aktive View umgeschaltet werden muss.
// vorher eingefuegt
// vorher geloescht
// verschobene Tabelle
// nach hinten verschoben
// nachrueckender Bereich
// nach vorne verschoben
// nachrueckender Bereich
// vorher eingefuegt
// aktuelle ausgeblendet


61 / 156 | libreoffice-4.4.0.3/sc/source/ui/view/tabview.cxx
// Appear und SetViewFrame
// wird getrennt abgefragt
// wird bei Resize neu gesetzt
// Scrollbars horizontal oder vertikal
// Ecke ueberdecken
// unterer Scrollbar
//  SetDragRectPixel auch ohne Scrollbars etc., wenn schon gesplittet ist
// Spalten/Zeilen-Header
//      Splitter auswerten
//  Fixier-Splitter nicht mit Scrollbar/TabBar ueberlappen lassen
// Spalten/Zeilen-Header
// Scrollbars nicht beim Scrollen neu setzen
// neu positionieren
//! Border muss neu gesetzt werden ???
// Scrollbars horizontal oder vertikal
// Spalten/Zeilen-Header
// Groessen hier wie in DoResize
// Spalten/Zeilen-Header
//  Scroll-Position anzeigen
//  (nur QuickHelp, in der Statuszeile gibt es keinen Eintrag dafuer)
//  nur in die richtige Richtung scrollen, nicht um ausgeblendete
//  Bereiche herumzittern
// bei Drag die Ranges nicht aendern
//  Fixierung
// links immer stehenlassen
//  Mit VCL wirkt Update() im Moment immer auf alle Fenster, beim Update
//  nach dem Scrollen des GridWindow's wuerde darum der Col-/RowBar evtl.
//  mit schon geaenderter Pos. gepainted werden -
//  darum vorher einmal Update am Col-/RowBar
// MapMode muss schon gesetzt sein
//  Fixierung
// oben immer stehenlassen
//  Zeilenkoepfe anpassen vor dem eigentlichen Scrolling, damit nicht
//  PosY darf dann auch noch nicht umgesetzt sein, neuen Wert uebergeben
// Zeilenkoepfe anpassen
// MapMode muss schon gesetzt sein
//  wenn am Dokumentende viele Zeilen ausgeblendet sind (welcher Trottel macht sowas?),
//  soll dadurch nicht auf breite Zeilenkoepfe geschaltet werden
// auf VCL gibt's Update ohne Ende (jedes Update gilt fuer alle Fenster)
//aCornerButton.Update();       // der bekommt sonst nie ein Update
//  Windows anzeigen
// immer angelegt
// ab hier dynamisch angelegte
//! neue Gridwindows eintragen
// vor ActivatePart !!
//  Form-Layer muss den sichtbaren Ausschnitt aller Fenster kennen
//  dafuer muss hier schon der MapMode stimmen
// vor ActivatePart !!
//  Form-Layer muss den sichtbaren Ausschnitt aller Fenster kennen
//  dafuer muss hier schon der MapMode stimmen
//  SPLIT_HANDLE_SIZE draufaddieren, damit das Einrasten genau
//  auf dem Splitter nicht aussetzt
//  bNextIfLarge=FALSE: nicht auf naechste Zelle, wenn ausserhalb des Fensters
// Fixierung aufheben
//  Form-Layer muss den sichtbaren Ausschnitt aller Fenster kennen
//  dafuer muss hier schon der MapMode stimmen
//  Pixel ist auf die ganze View bezogen, nicht auf das erste GridWin
//  fuer die Controls muss bei VisAreaChanged der Draw-MapMode eingestellt sein
//  (auch wenn ansonsten der Edit-MapMode gesetzt ist)
// kein Window uebergeben -> alle Fenster
// ab hier dynamisch angelegte


16 / 77 | libreoffice-4.4.0.3/sc/source/ui/view/drawview.cxx
// auf dieser View - von der 505f Umstellung nicht betroffen
//! Zoom uebergeben ???
//  beim ViewShell::Activate aus dem Reset2Open nicht die Handles anzeigen
//  Image-Ole wieder durch Grafik ersetzen passiert jetzt in ScClient::UIActivate
//  Ole-Objekt selektiert?
// Verhindern, das beim Anlegen
// eines TextObjekts auf die
// DrawShell umgeschaltet wird.
// jetzt UNO-Controls
//  Verben anpassen
// nach dem IMap-Editor Update
// Tabelle umschalten
// Tabelle umschalten
//  Markierung nicht aendern, wenn Ole-Objekt aktiv
//  (bei Drop aus Ole-Objekt wuerde sonst mitten im ExecuteDrag deaktiviert!)
//! rWin richtig auswerten


11 / 22 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshc.cxx
//  Dialog nur aufmachen, wenn ueber ScModule::SetRefDialog gerufen, damit
//  z.B. nach einem Absturz offene Ref-Dialoge nicht wiederkommen (#42341#).
//  wenn auf einem bestehenden Bereich aufgerufen, den markieren
// aktuelle Tabelle merken (wg. RefInput im Dialog)
// aktuelle Tabelle merken (wg. RefInput im Dialog)
//  Dialog schaut selber, was in der Zelle steht
//  Dialog schaut selber, was in der Zelle steht
//  Dialog schaut selber, was in der Zelle steht
//  Die Dialoge gehen immer mit eingeklapptem Zusaetze-Button auf,
//  darum muss die Groesse ueber das Initialize gerettet werden
//  (oder den Zusaetze-Status mit speichern !!!)


7 / 32 | libreoffice-4.4.0.3/sc/source/ui/view/gridwin3.cxx
//  auf Detektiv-Pfeilen gar nichts (Doppelklick wird bei ButtonUp ausgewertet)
//  bei rechter Taste Draw-Aktion abbrechen
//  ReleaseMouse beim Aufruf
// MouseButtonUp wird verschluckt...
// nichts geloescht
// immer, damit das Verhalten mit/ohne DrawingLayer gleich ist
// ist beim Scrollen weggekommen


57 / 160 | libreoffice-4.4.0.3/sc/source/ui/view/gridwin4.cxx
// auch wenn das inner-Rectangle nicht sichtbar ist, muss evtl.
// die Titelzeile gezeichnet werden, darum kein Rueckgabewert mehr.
// Wenn's weit daneben liegt, wird lcl_DrawOneFrame erst gar nicht gerufen.
//  pButtonViewData wird nur benutzt, um die Button-Groesse zu setzen,
//  darf ansonsten NULL sein!
//  links, oben, rechts, unten
// Hack: Titelzeile beruehrt zwei Zellen
// Hack: Titelzeile beruehrt zwei Zellen
//  Szenario-Rahmen immer dann auf zusammengefasste Zellen erweitern, wenn
//  dadurch keine neuen nicht-ueberdeckten Zellen mit umrandet werden
//! -> Repaint beim Zusammenfassen erweitern !!!
//! eigener Text "(keins)" statt "(leer)" ???
// aufheben
// neues Rechteck merken
//  via Reschedule, interpretierende Zellen nicht nochmal anstossen
//  hier kein Invalidate, sonst kommt z.B. eine Error-Box nie an die Reihe
//  (Bug 36381). Durch bNeedsRepaint wird spaeter alles nochmal gemalt.
//! Rechtecke zusammenfassen?
// nur betroffenen Bereich
// nicht weiterzeichnen
// unsichtbar
// zum Weiterzeichnen
//  ab hier kein return mehr
// merken, dass gemalt wird (wichtig beim Invertieren)
//  links und oben ist nicht betroffen
//! AutoFill-Anfasser alleine (ohne Cursor) zeichnen ???
// nach FindChanged
// SetPagebreakMode initialisiert auch bPrinted Flags
// Notiz-Anzeiger
//  Szenario / ChangeTracking muss auf jeden Fall nach DrawGrid sein, auch bei !bGridFirst
//! Test, ob ChangeTrack-Anzeige aktiv ist
//! Szenario-Rahmen per View-Optionen abschaltbar?
//! SetChangedClip() mit DrawMarks() zusammenfassen?? (anderer MapMode!)
// Drawing Vordergrund
// Drawing Markierungen
// ueber den Cursor, im Drawing-MapMode
//  Wenn waehrend des Paint etwas invertiert wurde (Selektion geaendert aus Basic-Macro),
//  ist das jetzt durcheinandergekommen und es muss neu gemalt werden
//  3 Pixel Rahmen um den Druckbereich
//  (mittlerer Pixel auf den Gitterlinien)
//  Ueberlaeufe verhindern:
//  Seitenumbrueche
//! anders darstellen (gestrichelt ????)
//! hidden suchen
//! hidden suchen
//  Seitenzahlen
//  pQueryParam kann nur MAXQUERY Eintraege enthalten
//  hier nicht auf EQUAL beschraenken
//  (auch bei ">1" soll der Spaltenkopf blau werden)
//  aQueryParam kann nur MAXQUERY Eintraege enthalten
// unsichtbar
// unsichtbar
// versteckte nachholen ?
// auf versteckte zusammengefasste testen
// letzte Zeile aus Block
// Rest von zusammengefasst
// nur Rest von zusammengefasster zu sehen ?


4 / 275 | libreoffice-4.4.0.3/sc/source/ui/view/printfun.cxx
// wird nur zur Initialisierung gebraucht
//  Rahmen wird nach innen gezeichnet
//!     direkte Ausgabe aus SvxBoxItem !!!
// nichts zu tun


14 / 47 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh2.cxx
// GetScDrawView ist nicht-const
//  Pseudo-Slots von Draw-Toolbox auswerten
//! wird das ueberhaupt noch gebraucht ?????
//  SID_FM_CREATE_CONTROL mit nNewFormId==0 (ohne Parameter) kommt beim Deaktivieren
//  aus FuConstruct::SimpleMouseButtonUp
//  Execute fuer die Form-Shell, um im Controller zu deselektieren
//! was fuer einen Slot braucht der komische Controller wirklich, um das anzuzeigen????
//  Wechsel von Control- zu Zeichenfunktion -> im Control-Controller deselektieren
//! was fuer einen Slot braucht der komische Controller wirklich, um das anzuzeigen????
// Chart nicht mit DrawShell
// Nicht immer zurueckschalten
//  SID_OBJECT_SELECT nur, wenn "harter" Selektionsmodus
// nur die Images, die auch auf dem Controller liegen
// wichtig fuer den ollen Control-Controller


9 / 97 | libreoffice-4.4.0.3/sc/source/ui/view/hdrcont.cxx
// sonst Probleme auf OS/2 !?!?!
//! cachen?
//  fuer VCL ist es wichtig, wenig Aufrufe zu haben, darum werden die aeusseren
//  Linien zusammengefasst
//  aeussere Linien komplett durchzeichnen
//  Zuerst Ende der letzten Zelle finden
//  bei Selektion der ganzen Zeile/Spalte:
//  Tracking statt CaptureMouse, damit sauber abgebrochen werden kann
//! Irgendwann sollte die SelectionEngine selber StartTracking rufen!?!


19 / 43 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshf.cxx
// ausblenden
// einblenden
// von Basic
//  Tabellennr. von Basic: 1-basiert
//! sonst Fehler setzen
//  FID_TAB_MENU_RENAME - "umbenennen" im Menu
//  Execute ist gleich, aber im GetState wird MENU_RENAME evtl. disabled
// Execute ist gleich
// kein Rename
// XXX Fehlerbehandlung???
// bei aktiviertem ChangeTracking kein TabMove
//  Tabelle ist 1-basiert
// nur die ScDocShell's zaehlen
// Kein Dokumentname -> neues Dokument
//  Tabelle ist 1-basiert, wenn nicht APPEND
// aufzeichnen, solange das Dokument noch aktiv ist
//  Parameter war ueberfluessig, weil die Methode an der Table haengt
//  wenn's nicht von Basic kommt, nochmal nachfragen:
//  FID_TAB_MENU_RENAME - "umbenennen" im Menu


28 / 87 | libreoffice-4.4.0.3/sc/source/ui/view/tabview2.cxx
//  Wenn keine (alte) Markierung mehr da ist, Anker in SelectionEngine loeschen:
// Status wird mit gesetzer Markierung abgefragt
//  Teil von Markierung aufheben?
//  Wenn zwischen Tabellen- und Header SelectionEngine gewechselt wird,
//  wird evtl. DeselectAll gerufen, weil die andere Engine keinen Anker hat.
//  Mit bMoveIsShift wird verhindert, dass dann die Selektion aufgehoben wird.
//  Die Tabelle kann an dieser Stelle ungueltig sein, weil DoneBlockMode
//  aus SetTabNo aufgerufen wird
//  (z.B. wenn die aktuelle Tabelle von einer anderen View aus geloescht wird)
// true -> Block loeschen
//  Markierung ist veraendert worden
//  (z.B. MarkToSimple, wenn per negativ alles bis auf ein Rechteck geloescht wurde)
//  oder nach InitOwnBlockMode wird mit Shift-Klick weitermarkiert...
//  wirklich umsetzen
//! direkt Variablen setzen? (-> kein Geflacker)
//  FindAreaPos kennt nur -1 oder 1 als Richtung
// unten/rechts nicht zuviel grau anzeigen
//! PaintBlock in zwei Methoden aufteilen: RepaintBlock und RemoveBlock o.ae.
// Invertieren beim Loeschen nur auf aktiver View
// Ergebnis
// rZoom ist kein besonderer prozentualer Wert
// nZoom entspricht der ganzen Seite oder
// nZoom entspricht der Seitenbreite
//  wird z.B. gerufen, wenn sich das View-Fenster verschiebt:
//  pDrawView wird per Notify gesetzt
// falls per Focus aus MouseButtonDown aufgerufen
//  ScPrintFunc fuellt im ctor die PageBreakData
//  Druckbereiche veraendert?


1 / 6 | libreoffice-4.4.0.3/sc/source/ui/view/hintwin.cxx
//  Hellgelb, wie Notizen in detfunc.cxx


18 / 52 | libreoffice-4.4.0.3/sc/source/ui/view/viewfun4.cxx
// sonst kommt der Sfx durcheinander...
// sollte spaeter durch Wrapper geschehen!
//  ab hier kein return mehr
// Pasten von FORMAT_FILE-Items
//  wird nicht direkt aus Drop aufgerufen, sondern asynchron -> Dialoge sind erlaubt
// bei bLink nur Grafik oder URL
// 1. Kann ich die Datei oeffnen?
// nur nach eigenen Filtern suchen, ohne Auswahlbox (wie in ScDocumentLoader)
// Code aus dem SFX geklaut!
// Asynchron oeffnen, kann naemlich auch aus D&D heraus passieren
// und das bekommt dem MAC nicht so gut ...
// 2. Kann die Datei ueber die Grafik-Filter eingefuegt werden?
// (als Link, weil Gallery das so anbietet)
// bei bLink alles, was nicht Grafik ist, als URL
// 3. Kann die Datei als OLE eingefuegt werden?
// auch nicht-Storages, z.B. Sounds (#38282#)
//  in die gerade editierte Zelle einfuegen
//  in nicht editierte Zelle einfuegen


1 / 86 | libreoffice-4.4.0.3/sc/source/ui/view/cellsh.cxx
// In interpreter may happen via rescheduled Basic


6 / 42 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsha.cxx
//  Zahlformat aus Attributen oder Formel
//  Bei Bedarf ein ' vorneweg, damit der String nicht ungewollt
//  als Zahl interpretiert wird, und um dem Benutzer zu zeigen,
//  dass es ein String ist (#35060#).
//! Auch bei Zahlformat "Text"? -> dann beim Editieren wegnehmen
// immer zusammen mit Eingabezeile


16 / 43 | libreoffice-4.4.0.3/sc/source/ui/view/tabview4.cxx
// ---  Referenz-Eingabe / Fill-Cursor
// nicht fuer einzelne Zelle
// nicht ueber die editierte Formel
//  dann an der oberen Kante der editierten Zelle ausrichten
// die 3 von oben
//! sollte das nicht bei Reset passieren?
//  Das kommt vor, wenn bei einem Referenz-Dialog als erstes mit Control in die
//  die Tabelle geklickt wird. Dann die neue Referenz an den alten Inhalt anhaengen:
// Reihenfolge ist richtig
//  je nach Richtung die obere oder untere Ecke:
//! nur Markierung ueber Inhalte zeichnen!
//  SetReference ohne Merge-Anpassung
//  UpdateScrollBars - sichtbaren Bereich und Scrollweite der Scrollbars einstellen
// immer moeglich !
//! cachen !!!!!!!!!!!!!!!
//      Bereich testen


75 / 187 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh4.cxx
//  hier kein GrabFocus, sonst gibt's Probleme wenn etwas inplace editiert wird!
//  fuer Eingabezeile (ClearCache)
//  AutoCorrect umsetzen, falls der Writer seins neu angelegt hat
//  RegisterNewTargetNames gibts nicht mehr
//  eigentlich nur beim Reload (letzte Version) noetig:
//  Das InputWindow bleibt stehen, aber die View mitsamt InputHandler wird
//  neu angelegt, darum muss der InputHandler am InputWindow gesetzt werden.
//  Aenderungs-Dialog aktualisieren
//  Wenn Referenzeingabe-Tip-Hilfe hier wieder angezeigt werden soll (ShowRefTip),
//  muss sie beim Verschieben der View angepasst werden (gibt sonst Probleme unter OS/2
//  beim Umschalten zwischen Dokumenten)
// Timer-verzoegert wg. Dokumentwechsel
// Notiz-Anzeige
// Formel-AutoEingabe-Tip abschalten
// Die Sfx-View moechte sich gerne selbst aktivieren, weil dabei noch
// magische Dinge geschehen (z.B. stuerzt sonst evtl. der Gestalter ab)
//  aus Verhaeltnis von VisArea und Fenstergroesse des GridWin
// rSize = Groesse von gridwin
// Position und Groesse von tabview wie uebergeben
// ForceMove als Ersatz fuer den Sfx-Move-Mechanismus
// (aWinPos muss aktuell gehalten werden, damit ForceMove beim Ole-Deaktivieren klappt)
//  auf ganze Zellen anpassen (in 1/100 mm)
/*!!!   ShowCursor wird nicht paarweise wie im gridwin gerufen.
        Der CursorLockCount am Gridwin muss hier direkt auf 0 gesetzt werden

    if (bOn)
        ShowAllCursors();
    else
        HideAllCursors();
*/
//! ist diese ViewShell immer aktiv???
//! ist diese ViewShell immer aktiv???
//  Mirror / Rotate aus
//  Aktiven Teil an Cursor anpassen, etc.
//Wird eh immer gebraucht.
// die Wartezeit lieber jetzt als beim Klick
//  GetMySubShell / SetMySubShell: altes Verhalten simulieren,
//  dass es nur eine SubShell gibt (nur innerhalb der 5 eignenen SubShells)
//  GetSubShell() war frueher const, und GetSubShell(sal_uInt16) sollte es auch sein...
// keine von meinen dabei
//  Drucker ist immer da (wird fuer die FontListe schon beim Starten angelegt)
// nur Zeichen & Backspace
// Notiz-Anzeige
// Eingabe
//  Will der InputHandler auch ein einfaches Return?
// ohne Modifier oder Shift-Space
// nur ohne Modifier
// Eingabe
// Eingabe nochmal hinterher
//  Spezialfall: Copy/Cut bei Mehrfachselektion -> Fehlermeldung
//  (Slot ist disabled, SfxViewShell::KeyInput wuerde also kommentarlos verschluckt)
// Eingabe
//  je nach Optionen mit Enter in den Edit-Modus schalten
// An Edit-Engine weiter
//  hier kein UpdateInputHandler, weil bei Referenzeingabe auf ein
//  anderes Dokument diese ViewShell nicht die ist, auf der eingegeben
//  wird!
//  Alt-Cursortasten hart codiert, weil Alt nicht konfigurierbar ist
// schon so initialisiert
// keine blaue Markierung
//  jeder Task hat neuerdings sein eigenes InputWindow,
//  darum muesste eigentlich entweder jeder Task seinen InputHandler bekommen,
//  oder das InputWindow muesste sich beim App-InputHandler anmelden, wenn der
//  Task aktiv wird, oder das InputWindow muesste sich den InputHandler selbst
//  anlegen (dann immer ueber das InputWindow suchen, und nur wenn das nicht da
//  ist, den InputHandler von der App nehmen).
//  Als Sofortloesung bekommt erstmal jede View ihren Inputhandler, das gibt
//  nur noch Probleme, wenn zwei Views in einem Task-Fenster sind.
// Alte Version:
//  if ( !GetViewFrame()->ISA(SfxTopViewFrame) )        // OLE oder Plug-In
//  FormShell vor MakeDrawView anlegen, damit die DrawView auf jeden Fall
//  an der FormShell angemeldet werden kann
//  Gepusht wird die FormShell im ersten Activate
//  DrawView darf nicht im TabView - ctor angelegt werden,
//  wenn die ViewShell noch nicht kostruiert ist...
// legt auch evtl. DrawView an
//  Link-Update nicht verschachteln
// importierte Daten aktualisieren
// NavigatorUpdate aufschieben bis Activate()
//  alles auf NULL, falls aus dem TabView-dtor noch darauf zugegriffen wird
//! (soll eigentlich nicht !??!?!)
//  ohne installiertes Chart darf Chart nicht Default sein...


1 / 5 | libreoffice-4.4.0.3/sc/source/ui/view/auditsh.cxx
// aktive Funktion markieren


3 / 7 | libreoffice-4.4.0.3/sc/source/ui/view/notemark.cxx
//  Am Outliner des Draw-Model ist auch der Drucker als RefDevice gesetzt,
//  und es soll einheitlich aussehen.
// Page einfuegen damit das Model sie kennt und auch deleted


49 / 198 | libreoffice-4.4.0.3/sc/source/ui/view/viewfun3.cxx
//  GlobalName der Writer-DocShell kommt jetzt aus comphelper/classids.hxx
// zu loeschender Bereich
// Zusammengefasste Zellen im Bereich?
// erst jetzt ist Draw-Undo verfuegbar
// kein CutMode mehr
//  als erstes SvDraw-Model, dann Grafik
//  (Grafik darf nur bei einzelner Grafik drinstehen)
//  keine Fehlermeldung, weil SID_PASTE in der idl das FastCall-Flag hat,
//  also auch gerufen wird, wenn nichts im Clipboard steht (#42531#)
//  als erstes SvDraw-Model, dann Grafik
//  (Grafik darf nur bei einzelner Grafik drinstehen)
//      Einfuegen auf Tabelle:
//  fuer Undo etc. immer alle oder keine Inhalte sichern
// evtl. Attribute ins Undo ohne sie vom Clip ins Doc zu kopieren
// zuviele Zeilen zum Transponieren
//  Nachfrage, wenn die Selektion groesser als 1 Zeile/Spalte, aber kleiner
//  als das Clipboard ist (dann wird ueber die Selektion hinaus eingefuegt)
//  Zielbereich, wie er angezeigt wird:
//  Sollen Zellen eingefuegt werden?
//  (zu grosse nEndCol/nEndRow werden weiter unten erkannt)
// wird vor CopyFromClip sowieso gesetzt
// Clipboard-Bereich erweitern
//  Test auf Zellschutz
//! Test auf Ueberlappung
//! nur wirkliche Schnittmenge testen !!!!!!!
// kein CutMode mehr
// bei Transpose Referenzen per Hand anpassen
//  alle Inhalte kopieren (im TransClipDoc stehen nur Formeln)
// und Bereich neu
// Rechenfunktionen mit Original-Daten auszufuehren ?
//  ggf. Autofilter-Koepfe loeschen
//!     Block-Bereich bei RefUndoDoc weglassen !!!
// Redo-Daten werden erst beim ersten Undo kopiert
// ohne RefUndoDoc muss das Redo-Doc noch nicht angelegt werden
//      angepasste Referenzen ins Redo-Doc
//      alte Referenzen ins Undo-Doc
//! Tabellen selektieren ?
// nur zum Zeichnen !
// nur zum Zeichnen !
//  innerhalb des Dokuments
// wegen zusammengefassten
//  Zielbereich markieren
//  Link innerhalb des Dokuments
//  Test auf Ueberlappung
//  Ausfuehren per Paste
//  Zielbereich markieren (Cursor setzen, keine Markierung)
// kein CutMode mehr
// nur zum Zeichnen !
// nur zum Zeichnen !


1 / 27 | libreoffice-4.4.0.3/sc/source/ui/view/output3.cxx
//  Teile nur fuer Bildschirm


4 / 10 | libreoffice-4.4.0.3/sc/source/ui/view/drawvie2.cxx
// UpdateBrowser in MarkListHasChanged gerufen
//  VC's und den Browser dazu gibts nicht mehr...
//  GetSbxForm gibt's nicht mehr, muss auch nichts mehr angemeldet werden
//  GetSbxForm gibt's nicht mehr, muss auch nichts mehr angemeldet werden


5 / 9 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwshg.cxx
//  Tabelle geschuetzt ?
// Groesse wie in 3.1:
//  am alten VC-Button musste die Position/Groesse nochmal explizit
//  gesetzt werden - das scheint mit UnoControls nicht noetig zu sein
//  nicht markieren wenn Ole


156 / 576 | libreoffice-4.4.0.3/sc/source/ui/view/gridwin.cxx
//  ListBox in einem FloatingWindow (pParent)
// ohne alle Modifiers
// auswaehlen
// loescht die List-Box !!!
//  wenn es ein editierbarer Bereich ist, und rechts unten eine Matrix-Zelle
//  mit Origin links oben liegt, enthaelt der Bereich genau die Matrix.
//! Direkt die MatrixEdges Funktionen von der Column herausreichen ???
// weitersuchen
// nicht mehr auswaehlen
// Zelle unterhalb des Buttons
// Bereich ganz oben -> Button unterhalb
//! Texthoehe addieren (wenn sie an der View gespeichert ist...)
//  Die ListBox direkt unter der schwarzen Linie auf dem Zellgitter
//  (wenn die Linie verdeckt wird, sieht es komisch aus...)
// nicht resizable etc.
// Show muss vor SetUpdateMode kommen !!!
//  SetOutputSizePixel/StartPopupMode erst unten, wenn die Groesse feststeht
// auch nicht uebertreiben (Pixel)
// Groesse auf benoetigte Groesse anpassen
// Szenario-Auswahl kommt aus MouseButtonDown:
//  der naechste MouseMove auf die Filterbox ist wie ein ButtonDown
// nicht resizable etc.
//! wird der Titel ueberhaupt ausgewertet ???
//  Position und Groesse an Fenster anpassen
//! vorher Abfrage, ob die Eintraege hineinpassen (Breite)
// Show muss vor SetUpdateMode kommen !!!
// AutoFilter: aktiven Eintrag selektieren
// kann nur MAXQUERY Eintraege ergeben
// bisherige Filter-Einstellungen
//!         Abfrage mit DrawButtons zusammenfassen!
//  neu (309): irgendwas muss immer selektiert sein:
//  keine leere Auswahl-Liste anzeigen:
//  Select erst nach GrabFocus, damit das Focus-Rechteck richtig landet
//  der naechste MouseMove auf die Filterbox ist wie ein ButtonDown
// unter OS/2 stimmt der Focus sonst nicht
// kann nur MAXQUERY Eintraege ergeben
//! auch ueber Slot ??
// bisherige Filter-Einstellungen
//!         Abfrage mit DrawButtons zusammenfassen!
// diese Spalte zweimal?
// loeschen geht immer
// speichern
//  "Zuviele Bedingungen"
//  Embedded-Rechteck
//  Filter-Popup beendet sich mit eigenem Mausklick, nicht erst beim Klick
//  in das GridWindow, darum ist die folgende Abfrage nicht mehr noetig:
// loescht FilterBox, wenn vorhanden
// Notiz-Anzeige
// falls auf Link geklickt wird
// um Control-Klick immer zu erkennen
// Referenz angefangen
// naechster Klick -> Referenz
// auch bei Mode==SC_INPUT_TYPE
//  DeactivateIP passiert nur noch bei MarkListHasChanged
//  im GrabFocus Aufruf kann eine Fehlermeldung hochkommen
//  (z.B. beim Umbenennen von Tabellen per Tab-Reiter)
//  beim Klick in die Tabellen-EditView immer den Focus umsetzen
// sonst ist es oben schon passiert
// Reihenfolge passend zum angezeigten Cursor:
// die anderen Variablen sind oben initialisiert
// kein Draw-Objekt selektiert
//  TestMouse schon oben passiert
//      Doppelklick angefangen ?
// StopMarking kann aus DrawMouseButtonDown gerufen werden
// Klick auf Link: Cursor nicht bewegen
// auch nur dann beim ButtonUp ausfuehren
//  SelMouseButtonDown an der View setzt noch das bMoveIsShift Flag
//  Tracking statt CaptureMouse, damit sauber abgebrochen werden kann
//! Irgendwann sollte die SelectionEngine selber StartTracking rufen!?!
// reset und return
// Selection-Engine: Markieren abbrechen
// Markieren/Verschieben auf Drawing-Layer abbrechen
// Range wieder richtigherum
// Undo im Giesskannenmodus
//  Giesskannen-Modus (Gestalter)
//  Abfrage auf Undo schon oben
//  Text-Cursor gleich an die geklickte Stelle setzen
//  beim ButtonUp nur ausfuehren, wenn ButtonDown auch ueber einer URL war
// keinen Doppelklick anfangen
//! SID_MARKAREA gibts nicht mehr ???
//! was passiert beim Markieren mit dem Cursor ???
// nur Cursor bewegen
//  Ob aus dem Edit-Modus Drag&Drop gestartet wurde, bekommt man leider
//  nicht anders mit:
// Undo im Giesskannenmodus -> nur auf Up warten
// naechster Klick -> Referenz
//  anderen Mauszeiger anzeigen?
//  Fill-Cursor anzeigen ?
// ausgewertet bei AutoFill und Matrix
// Edit-Mode muss zuerst kommen!
// setzt Pointer um
//  Weil die SelectionEngine kein Tracking kennt, die Events nur auf
//  die verschiedenen MouseHandler verteilen...
// gezeichnet wird per bDragRect
// richtig abbrechen geht dabei nicht...
// mit Status SC_GM_IGNORE aus StopMarking
// Dialog nicht verkleinert lassen
//  MouseButtonUp immer mit passenden Buttons (z.B. wegen Testtool, #63148#)
//  Schliesslich behauptet der Tracking-Event ja, dass normal beendet und nicht
//  abgebrochen wurde.
// Edit-Zelle mit Spelling-Errors ?
//  GetEditUrlOrError hat den Cursor schon bewegt
// ist dann nicht 0
//  Wenn man unter OS/2 neben das Popupmenue klickt, kommt MouseButtonDown
//  vor dem Ende des Menue-Execute, darum muss SetModified vorher kommen
// wenn semi-Modeless-SfxChildWindow-Dialog oben, keine KeyInputs:
//  keine Eingaben im Zeichenmodus
// von SfxViewShell
// Markieren/Verschieben auf Drawing-Layer abbrechen
// sensitiver Bereich (Pixel)
//  Testet, ob bei eingeschalteten RedLining,
//  bei einem Drop ein Scenario betroffen ist.
// Rechteck loeschen
// verschobenen MapMode erzeugen
//  Formeln neu zeichnen -------------------------------------------------
//  nicht anfangen, verschachtelt zu painten
//  (dann wuerde zumindest der MapMode nicht mehr stimmen)
// -> am Ende vom Paint nochmal Invalidate auf alles
//      StopMarking();      // falls Dialog (Fehler), weil dann kein ButtonUp
// MO: nur wenn nicht im RefInput-Modus
//     -> GetFocus/MouseButtonDown-Reihenfolge
//        auf dem Mac
//  zusammengefasste (einzeln/Bereich) ???
//  der Range ist immer richtigherum
//  nur an den Raendern entlang
//  Repaint fuer die Teile des Rahmens in Old, die bei New nicht mehr da sind
// Tab aendert sich nicht
//  komplett weggeschoben oder alle Seiten veraendert
//  (Abfrage <= statt < geht schief bei einzelnen Zeilen/Spalten)
//  alle vier Kanten einzeln testen
//  nur obere Linie loeschen
//  den Teil, der oben wegkommt
//  unterer Teil
//  nur untere Linie loeschen
//  den Teil, der unten wegkommt
//  nur linke Linie loeschen
//  den Teil, der links wegkommt
//  nur rechte Linie loeschen
//  den Teil, der rechts wegkommt
//  Mauszeiger
//  Umschalten bei Fixierung (damit Scrolling funktioniert)
//  Verschieben
// beim ButtonUp wieder richtigherum
//  nur das neuzeichnen, was sich veraendert hat...
//  neuen Rahmen nur drueberzeichnen (synchron)
// was man bewegt, will man auch sofort sehen
// Event wiederholen
// nicht implementiert
//! nPosX/Y mit uebergeben?
//  vertikal kann (noch) nicht angeklickt werden:
// ohne Drawing-Skalierung
// kein return mehr
// noch kein Button gezeichnet -> da ist auch keiner
//  Szenario-Rahmen immer dann auf zusammengefasste Zellen erweitern, wenn
//  dadurch keine neuen nicht-ueberdeckten Zellen mit umrandet werden
//  Delimiters hier wie in inputhdl.cxx !!!


1 / 7 | libreoffice-4.4.0.3/sc/source/ui/view/tabvwsh9.cxx
//  Disabled wird nicht mehr...


25 / 73 | libreoffice-4.4.0.3/sc/source/ui/view/gridwin2.cxx
//  Horizontal mehr Toleranz als vertikal, weil mehr Platz ist
// linker Rand der naechsten Zelle
// oberer Rand der naechsten Zelle
// Druckbereich
// X/Y Position des verchobenen Seitenumbruchs
// X/Y Anfang der Seite, die am Umbruch zuende ist
//! Scrolling und Umschalten mit RFMouseMove zusammenfassen !
//! (Weginvertieren vor dem Scrolling ist anders)
// weginvertieren
//  Umschalten bei Fixierung (damit Scrolling funktioniert)
//  ab hier neu
//  gesucht wird eine Position zwischen den Zellen (vor nPosX / nPosY)
// ans Ende ist auch erlaubt
// ans Ende ist auch erlaubt
//  zeichnen...
// weginvertieren
// hininvertieren
//  bei ButtonUp die Aenderung ausfuehren
// am Ende nicht
//  vorigen Break auf hart, und Skalierung aendern
// am Ende nicht
//  vorigen Break auf hart, und Skalierung aendern
// sonst in AdjustPrintZoom schon passiert
//  Druckbereich setzen
// Event wiederholen


1 / 67 | libreoffice-4.4.0.3/sc/source/ui/view/viewfun5.cxx
// (wg. Selection Manager bei Trustet Solaris)


1 / 12 | libreoffice-4.4.0.3/sc/source/ui/pagedlg/tphfedit.cxx
//  (GetAttribs beim Format-Dialog-Aufruf gibt immer gesetzte Items zurueck)


1 / 8 | libreoffice-4.4.0.3/sc/source/ui/pagedlg/hfedtdlg.cxx
// kann ja nur ne ScHFEditPage sein...


13 / 49 | libreoffice-4.4.0.3/sc/source/ui/pagedlg/areasdlg.cxx
//@BugID 54702 Enablen/Disablen nur noch in Basisklasse
//  Druckbereiche gelten pro Tabelle, darum macht es keinen Sinn,
//  bei der Eingabe die Tabelle umzuschalten
// Druckbereich
// Wiederholungszeile
// Wiederholungsspalte
// Fehlermeldungen
// Selektion holen und String in PrintArea-ListBox merken
// Ranges holen und in ListBoxen merken
// Druckbereich veraendert?
// Wiederholungszeile veraendert?
// Wiederholungsspalte veraendert?
// Zulaessige Syntax fuer rStr:


1 / 4 | libreoffice-4.4.0.3/sc/source/ui/docshell/pagedata.cxx
//! ScPrintRangeData komplett vergleichen ??


63 / 149 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh4.cxx
// geschuetzte Zelle
//! welchen Fehler ?
// Default sal_True (keine Nachfrage)
// bei Bedarf neuen Datenbankbereich anlegen
// nachfragen, bevor alter DB-Bereich ueberschrieben wird
//  UpdateImport aktualisiert auch die internen Operationen
//! immer oder gar nicht begrenzen ???
// Dialog fuer Spalten/Zeilenkoepfe
// ausfuehren
//  Formeln berechnen und painten wie im TrackTimeHdl
//  wenn FID_DATACHANGED irgendwann mal asynchron werden sollte
//  (z.B. mit Invalidate am Window), muss hier ein Update erzwungen werden.
//  wird nach dem Laden aufgerufen, wenn DB-Bereiche mit
//  weggelassenen Daten enthalten sind
//  Import und interne Operationen wie SID_REFRESH_DBAREA
//  (Abfrage auf Import hier nicht noetig)
//  markieren (Groesse kann sich geaendert haben)
// Fehler beim Import -> Abbruch
//  interne Operationen, wenn welche gespeichert
//  Pivottabellen die den Bereich als Quelldaten haben
//  wenn nicht, dann aber die abhaengigen Formeln updaten
//! auch fuer einzelne Bereiche, die nicht aktualisiert werden koennen
//! nur die abhaengigen
//  kein Filter angegeben -> Detection
// nun wirklich ausfuehren...
// auch Warnings
// nur Errors
//  neu eingeschaltet -> auch anzeigen
// delete passiert mit der Ref
//  DeleteTable von viewfunc nach docfunc verschieben!
// immer an den DocOptions setzen, damit das auch fuer SO50
// gespeichert wird (und alle Abfragen bisher auch darauf laufen).
// SetDocOptions propagiert das an den NumberFormatter
// die FormShell soll es mitbekommen
// kleiner (?) Hack -> forward der Slots an TabViewShell
// Teilergebnis als QuickHelp
// sonst Dokument neu berechnen
//  Wenn es Charts gibt, dann alles painten, damit nicht
//  PostDataChanged und die Charts nacheinander kommen und Teile
// erzeugt eigenes Undo
// schon auf neu angepasst
//  alles andere geht ueber Slots...
//  wie in printfun.cxx
//  benoetigte Skalierung fuer Selektion ausrechnen
// Begrenzung
// bei bApi nur, wenn Umbrueche schon angezeigt
// nicht verwendet -> nichts zu tun
//! ohne CountPages auskommen
//  setzt Umbrueche auf allen Tabs
// Click auf StatusBar-Control
//  Wenn eine Formel editiert wird, muss FID_RECALC auf jeden Fall enabled sein.
//  Recalc fuer das Doc war mal wegen eines Bugs disabled, wenn AutoCalc an war,
//  ist jetzt wegen eines anderen Bugs aber auch immer enabled.
//  Wenn hier Slots von der View-Shell executed werden, muss auch der
//  GetState weitergeleitet werden!
// sichtbare View
//  ohne Inhalte wissen wir auch nicht, wie gross die Inhalte sind
//  leeres Rechteck zurueckgeben, das wird dann nach dem Laden berechnet
//  Visarea holen wie nach Load
// mindestens eine Spalte
// mindestens eine Zeile
// ungueltiger Bereich
// falsches Doc?


16 / 80 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh6.cxx
// Zoom in der InPlace View einstellen
//ViewChanged( ASPECT_CONTENT );          // auch im Container anzeigen
//  wenn's gar nicht Ole ist, kann man sich die Berechnungen sparen
//  (VisArea wird dann beim Save wieder zurueckgesetzt)
// hier muss auch der Start angepasst werden
//  nach dem Laden von Vorlagen aus einem anderen Dokment (LoadStyles, Insert)
//  muessen die SetItems (ATTR_PAGE_HEADERSET, ATTR_PAGE_FOOTERSET) auf den richtigen
//  Pool umgesetzt werden, bevor der Quell-Pool geloescht wird.
// nicht mehr benutzte Links raus
// nicht mehr benutzt -> loeschen
// neue Links eintragen
// im Dokument mehrfach?
// schon als Filter eingetragen?
//			pTabLink->SetAddUndo(sal_False);		//! Undo's zusammenfassen
// pTabLink->SetPaint(false);          //  Paint nur einmal am Ende
//  Paint nur einmal


1 / 201 | libreoffice-4.4.0.3/sc/source/ui/docshell/externalrefmgr.cxx
// being 0xffffffff


2 / 67 | libreoffice-4.4.0.3/sc/source/ui/docshell/dbdocimp.cxx
// ohne die Formeln
// Formeln nicht loeschen


4 / 217 | libreoffice-4.4.0.3/sc/source/ui/docshell/impex.cxx
// zuviele Spalten/Zeilen
// sonst auch nCol nicht hochzaehlen
// pColStart ist 1-basiert
// ColInfos sind in Reihenfolge


1 / 24 | libreoffice-4.4.0.3/sc/source/ui/docshell/servobj.cxx
// um mitzubekommen, wenn die DocShell geloescht wird


7 / 21 | libreoffice-4.4.0.3/sc/source/ui/docshell/autostyl.cxx
//  Timeouts von allen Eintraegen anpassen
//  Einfuege-Position suchen
//  abgelaufene ausfuehren, Timer neu starten
// abgelaufen
// weiterzaehlen
// ersten Eintrag mit Timeout != 0 suchen
// eingestellte Wartezeit


81 / 284 | libreoffice-4.4.0.3/sc/source/ui/docshell/docfunc.cxx
//  Zeile ueber dem Range painten (fuer Linien nach AdjustRowHeight)
//  Loeschen auf allen Tabellen
//  wenn automatisch, an letzte Aktion anhaengen
//  Reihenfolge:
//  2) Objekte loeschen (DrawUndo wird gefuellt)
//  3) Inhalte fuer Undo kopieren und Undo-Aktion anlegen
//  4) Inhalte loeschen
// fuer Linien ueber dem Bereich
//  wegen ChangeTracking darf UndoAction erst nach SetString angelegt werden
//  PutData ruft PutCell oder SetNormalString
// sonst Null behalten -> SetString mit lokalen Formeln/Zahlformat
//! ist das noetig ???
//! Umrandung
// fuer Linien ueber dem Bereich
//  zugehoerige Szenarien auch anpassen
// Test zusammengefasste
// wichtig wegen TrackFormulas bei UpdateReference
// Spalte/Zeile voll
// Test Zellschutz
// Test zusammengefasste
//      ausfuehren
// wichtig wegen TrackFormulas bei UpdateReference
//  alle Tabellen anlegen, damit Formeln kopiert werden koennen:
//  kopieren mit bColRowFlags=false (#54194#)
//  ganze Zeilen loeschen: nichts anpassen
//  zugehoerige Szenarien auch anpassen - nur wenn innerhalb einer Tabelle verschoben wird!
// erweitert im Zielblock
//  Test auf Zellschutz
//  Test auf zusammengefasste - beim Verschieben erst nach dem Loeschen
// "Zusammenfassen nicht verschachteln !"
//  ausfuehren
// Hoehen angepasst?
//  Test auf zusammengefasste
//  Fehlermeldung erst nach dem Wiederherstellen des Inhalts
// "Zusammenfassen nicht verschachteln !"
//  Zielbereich:
// Breiten mitkopiert?
//  Quellbereich:
//  InsertTab erzeugt ein SdrUndoNewPage
// wichtig fuer Undo
// nur nTab mit Flags
//  Drawing-Layer muss sein Undo selbst in der Hand behalten !!!
//  DeleteTab erzeugt ein SdrUndoDelPage
// nichts zu tun - ok
//  nicht alle Tabellen ausblenden
//! eigene Meldung?
//! SetWidthOrHeight - noch doppelt zu ViewFunc !!!!!!
//! - Optimale Hoehe fuer Edit-Zellen ist unterschiedlich zwischen Drucker und Bildschirm
//! - Optimale Breite braucht Selektion, um evtl. nur selektierte Zellen zu beruecksichtigen
//! eigene Meldung?
//! Option "Formeln anzeigen" - woher nehmen?
// Hoehen immer blockweise
//  fuer alle eingeblendeten CR_MANUALSIZE loeschen,
//  dann SetOptimalHeight mit bShrink = FALSE
//  Manual-Flag wird bei bAll=sal_True schon in SetOptimalHeight gesetzt
//  (an bei Extra-Height, sonst aus).
// Spaltenbreiten
// erste Spalte / Zeile
// ChangeIndent setzt auf links
// Draw-Undo erst jetzt verfuegbar
//! auch bei Undo selektierte Tabellen beruecksichtigen
//! auch bei Undo selektierte Tabellen beruecksichtigen
//  Err522 beim Paint von DDE-Formeln werden jetzt beim Interpretieren abgefangen
//! auch bei Undo selektierte Tabellen beruecksichtigen
// Draw-Undo erst jetzt verfuegbar
//  mindestens eine Zeile/Spalte als Quellbereich behalten:
// Draw-Undo erst jetzt verfuegbar
//      Zellschutz testen
//!     Quellbereich darf geschuetzt sein !!!
//!     aber kein Matrixfragment enthalten !!!
// Draw-Undo erst jetzt verfuegbar
// Zielbereich zurueckgeben (zum Markieren)
// "Zusammenfassen nicht verschachteln !"
// per API nicht nachfragen
// soll nicht sein
// wegen Hoehenanpassung
// relative Referenzen Excel-konform auf die linke Spalte anpassen:
//  versuchen, alten Zustand wiederherzustellen
//  Update hat sein eigenes Undo
// beim ersten Update ggf. nichts einfuegen
// kein SetInCreate -> Update ausfuehren


3 / 92 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh8.cxx
// nur Strings in erster Zeile => sind Feldnamen
// Paragraphs erhalten
// zwischen 0 Wert und 0 kein Wert unterscheiden


19 / 28 | libreoffice-4.4.0.3/sc/source/ui/docshell/olinefun.cxx
// wegen ein-/ausblenden
//! PaintWidthHeight zur DocShell verschieben?
// fuer Test auf Merge
// Datenbereich nicht geaendert
// "Gruppierung nicht moeglich"
// Datenbereich nicht geaendert
// es wird nicht wieder eingeblendet -> kein UpdatePageBreaks
// "Aufheben nicht moeglich"
// einblenden
// ist schon da
//! start und end berechnen
// alle Eintraege
// einblenden
// ausblenden
//  Spalten
//  Zeilen
//  Spalten
//  Zeilen
//! start und end berechnen


73 / 161 | libreoffice-4.4.0.3/sc/source/ui/docshell/dbdocfun.cxx
// Fehler -> alten Zustand wiederherstellen
// gehoert dann dem Dokument
// Einfuegen hat geklappt
// dann muss neu compiliert werden
//! auch fuer ScDBFunc::RepeatDB benutzen!
//!     Undo nur benoetigte Daten ?
//  Datenbereich sichern - incl. Filter-Ergebnis
//  alle Formeln wegen Referenzen
//  DB- und andere Bereiche
//  Sortieren ohne SubTotals
// wird unten wieder zurueckgesetzt
// Bereich kann sich geaendert haben
// Bereich kann sich geaendert haben
//  bei nicht-inplace kann die Tabelle umgestellt worden sein
// Bereich kann sich geaendert haben
// "Keine Operationen auszufuehren"
//  Merge-Attribute wuerden beim Sortieren durcheinanderkommen
//      ausfuehren
// bestehenden Filter wiederholen?
//  Wechsel von Inplace auf nicht-Inplace, dann erst Inplace aufheben:
//  (nur, wenn im Dialog "Persistent" ausgewaehlt ist)
//  alte Filterung aufheben
// fuer Paint / Zielbereich
// kopiert wird in Table::Query
// Bereich, in den kopiert wird
// Zielgroesse anpassen (einf./loeschen)
//  Test, ob Formeln aufgefuellt werden muessen (nFormulaCols):
// neben dem Bereich
// kann keine Zeilen einfuegen
//      ausfuehren
// bestehende Teilergebnisse wiederholen?
// nicht beim Aufheben
// Teilergebnisse vorhanden?
//  Attribute sichern, falls beim Filtern mitkopiert
// Zielbereich loeschen
//  kleinere der End-Spalten, Header+1 Zeile
//  auch fuer aufgefuellte Formeln
// einfach loeschen
//  Filtern am Dokument ausfuehren
//  auf wirklichen Ergebnis-Bereich anpassen
//  (das hier ist immer eine Verkleinerung)
// sal_False - nicht loeschen
//  Formeln ausfuellen
// gemerkte Attribute zurueckkopieren
//  speichern: Inplace immer, sonst je nach Einstellung
//             alter Inplace-Filter ist ggf. schon aufgehoben
// neuen DB-Bereich merken
//  selektieren wird hinterher von aussen (dbfunc)
//  momentan ueber DB-Bereich an der Zielposition, darum muss dort
//  auf jeden Fall ein Bereich angelegt werden.
// Bereich vorhanden -> anpassen (immer!)
// Bereich anlegen
//  Query-Param wird am Ziel nicht mehr eingestellt, fuehrt nur zu Verwirrung
//  und Verwechslung mit dem Query-Param am Quellbereich (#37187#)
//! auch fuer ScDBFunc::DoSubTotals benutzen!
//  dann bleibt aussen:
//  - neuen Bereich (aus DBData) markieren
// sal_False = nur loeschen
// nicht in zusammengefasste einfuegen
// "StarCalc" "Daten loeschen?"
// Bereichsende wird veraendert
// alte Daten sichern
//  Datenbereich sichern - incl. Filter-Ergebnis
//  alle Formeln wegen Referenzen
//  DB- und andere Bereiche
// nur Zeilen-Outlines loeschen
//  Teilergebnis-Felder vor die Sortierung setzen
//  (doppelte werden weggelassen, kann darum auch wieder aufgerufen werden)
// "Kann keine Zeilen einfuegen"
//  DB-Operationen wiederholen
// Fehler beim Import -> Abbruch
//  interne Operationen, wenn welche gespeichert
//  Pivottabellen die den Bereich als Quelldaten haben


28 / 62 | libreoffice-4.4.0.3/sc/source/ui/docshell/arealink.cxx
//  DefModalDialogParent setzen, weil evtl. aus der DocShell beim ConvertFrom
//  bei bInCreate nichts tun, damit Update gerufen werden kann, um den Status im
//  LinkManager zu setzen, ohne die Daten im Dokument zu aendern
// Verknuepfung loeschen: Undo
// nur einmal
// benannte Bereiche
// Datenbankbereiche
//  ausfuehren:
//  Dokument laden - wie TabLink
//  wenn neuer Filter ausgewaehlt wurde, Optionen vergessen
// Optionen koennten gesetzt worden sein
//  alte Daten loeschen / neue kopieren
// alter Bereich, wenn Datei nicht gefunden o.ae.
// Bereich veraendert?
// nur Zieltabelle
// ohne Einfuegen
// nur Zieltabelle
//  Zellen einfuegen / loeschen
//  DeleteAreaTab loescht auch MERGE_FLAG Attribute
// incl. loeschen
//  Daten kopieren
//  neue Einstellungen merken
//  CanFitBlock sal_False -> Probleme mit zusammengefassten Zellen
//                       oder Tabellengrenze erreicht!
//! Zellschutz ???
//! Link-Dialog muss Default-Parent setzen
//  "kann keine Zeilen einfuegen"
//  aufraeumen


54 / 142 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh3.cxx
//          Redraw - Benachrichtigungen
//! Navigator direkt benachrichtigen!
// Platz fuer Linien beruecksichtigen
//! Abfrage auf versteckte Spalten/Zeilen!
// um zusammengefasste erweitern
//      Paint jetzt ausfuehren
// nicht weitersammeln
// loeschen
// bei Unlock sofort ausfuehren
// jetzt
// passt sonst nicht zur inaktiven Darstellung
//  Einstellungen aus dem SpellCheckCfg kommen in Doc- und ViewOptions
// zweistellige Jahreszahleneingabe aus Extras->Optionen->Allgemein->Sonstiges
//  Druck-Optionen werden jetzt direkt vor dem Drucken gesetzt
//! aus neuem Printer ???
//  Groesse umdrehen
// der letzte gewinnt
// ohne Aktion ist nichts..
//! Changes vorhanden -> Nachfrage ob geloescht werden soll
//              Merge (Aenderungen zusammenfuehren)
//  State nicht vergleichen, falls eine alte Aenderung akzeptiert wurde
//! Funktionen an die DocShell
//! nichts zu tun - Fehlermeldung?
// anschalten
// visuelles RedLining einschalten
//  gemeinsame Ausgangsposition suchen
//  pSourceAction und pThisAction zeigen jetzt auf die ersten "eigenen" Aktionen
//  Die gemeinsamen Aktionen davor interessieren ueberhaupt nicht
//! Abfrage, ob die Dokumente vor dem Change-Tracking gleich waren !!!
//  MergeChangeData aus den folgenden Aktionen erzeugen
//! nichts zu tun - Fehlermeldung?
//  ab hier kein return mehr
// UpdateReference-Undo, gueltige Referenzen fuer den letzten gemeinsamen Zustand
//  MergeChangeData an alle noch folgenden Aktionen in diesem Dokument anpassen
//  -> Referenzen gueltig fuer dieses Dokument
// deleted Table enthaelt deleted Cols, die nicht
//  MergeChangeData in das aktuelle Dokument uebernehmen
//! muss hier noch festgestellt werden, ob wirklich in
//  liegt in einem Bereich, der in diesem Dokument geloescht wurde
//  -> wird weggelassen
//! ??? Loesch-Aktion rueckgaengig machen ???
//! ??? Aktion irgendwo anders speichern  ???
//! Datum/Autor/Kommentar der Source-Aktion uebernehmen!
//  alte Aktion (aus den gemeinsamen) ablehnen
//! was passiert bei Aktionen, die in diesem Dokument accepted worden sind???
//! Fehlermeldung oder was???
//! oder Reject-Aenderung normal ausfuehren
//  normal ausfuehren
//! Test, ob es ganz unten im Dokument war, dann automatisches
//! Zeilen-Einfuegen ???
// deleted Table enthaelt deleted Cols, die nicht
// Referenzen anpassen
//! der ist jetzt verhunzt
// Reject() paintet nicht selber


19 / 58 | libreoffice-4.4.0.3/sc/source/ui/docshell/tablink.cxx
// Verbindung aufheben
//  DefModalDialogParent setzen, weil evtl. aus der DocShell beim ConvertFrom
// Verknuepfung loeschen: Undo
// nur einmal
// Verbindung wird im dtor aufgehoben
//  wenn neuer Filter ausgewaehlt wurde, Optionen vergessen
// Optionen hart angegeben?
//  ItemSet immer anlegen, damit die DocShell die Optionen setzen kann
// Optionen koennten gesetzt worden sein
//  Tabellen kopieren
//  Tabellenname einer ExtDocRef anpassen
// kein RefUpdate, kein ValidTabName
// nicht neu einfuegen
// nur Werte?
//  neue Einstellungen merken
//  aufraeumen
//  Paint (koennen mehrere Tabellen sein)
//! Fehler ausgeben ?
// Optionen werden beim Laden per Dialog gesetzt


38 / 85 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh5.cxx
//  Nicht einfach GetDBAtCursor: Der zusammenhaengende Datenbereich
//  fuer "unbenannt" (GetDataArea) kann neben dem Cursor legen, also muss auch ein
//  benannter DB-Bereich dort gesucht werden.
//      Bereich nehmen, wenn nichts anderes markiert
// passt gar nicht
//  Bereich auf neue End-Zeile erweitern
// immer Markierung nehmen (Bug 11964)
//      fuer Import nie "unbenannt" nehmen
// nichts gefunden
// zusammenhaengender Bereich
// alten Bereich sauber wegnehmen
// neu setzen
// Undo fuer Import1-Bereich
//  neuen Bereich am Sba anmelden nicht mehr noetig
//  "Import1" etc am Navigator bekanntmachen
//  Hoehen anpassen
//! mit docfunc zusammenfassen
// Test, ob Quelldaten verschoben wuerden
//      ausfuehren
// Zeilenstatus
// komplette Ausgangszeilen
// alten Ausgabebereich
// alten Ausgabebereich
// Zielbereich loeschen / anpassen
// noch auf der Suche nach dem Szenario?
// Zellschutz testen
// auch alle Szenarien
//  angezeigte Tabelle:
//  Bei Zurueckkopier-Szenarios auch Inhalte
//  alles painten, weil in anderen Bereichen das aktive Szenario
//  geaendert sein kann
//! nur, wenn sichtbare Rahmen vorhanden?
//  ausfuehren
// ohne Formel-Update
//!     auf Filter / Buttons / Merging testen !
//  dies ist dann das aktive Szenario
// sal_True - nicht aus Szenario kopieren
// Tabellenreiter


1 / 254 | libreoffice-4.4.0.3/sc/source/ui/docshell/docsh.cxx
//  RegisterNewTargetNames gibts nicht mehr


1 / 61 | libreoffice-4.4.0.3/sc/source/ui/Accessibility/AccessibleDocumentPagePreview.cxx
//neue VisArea setzen


2 / 97 | libreoffice-4.4.0.3/sc/source/ui/Accessibility/AccessibleDocument.cxx
// Neues Zeichenobjekt eingefuegt
// Zeichenobjekt aus Liste entfernt


1 / 125 | libreoffice-4.4.0.3/sc/source/ui/vba/vbachart.cxx
// SegmentOffset an ChartDataPointProperties ->am XDiagram abholen //wie macht Excel das?


2 / 40 | libreoffice-4.4.0.3/sc/source/ui/unoobj/fmtuno.cxx
//  Eintrag aus dem Dokument lesen...
//  Eintrag aus dem Dokument lesen...


2 / 221 | libreoffice-4.4.0.3/sc/source/ui/unoobj/dapiuno.cxx
// nicht gefunden
// sollte nicht vorkommen


1 / 206 | libreoffice-4.4.0.3/sc/source/ui/unoobj/chart2uno.cxx
// Dummy fuer Beschriftung


3 / 15 | libreoffice-4.4.0.3/sc/source/ui/unoobj/srchuno.cxx
//! SearchWords sucht in ganzen Zellen - umbenennen ???
// enum TableSearch ist weg
//  Selection-Flag wird beim Aufruf gesetzt


38 / 139 | libreoffice-4.4.0.3/sc/source/ui/unoobj/styleuno.cxx
//  Map mit allen Seitenattributen, incl. Kopf-/Fusszeilenattribute
//  Map mit Inhalten des Header-Item-Sets
//  Map mit Inhalten des Footer-Item-Sets
//  Index-Access auf die Style-Typen: 0 = Cell, 1 = Page
//  Referenz-Update interessiert hier nicht
// ungueltiger Index
// muss zu getByIndex passen
//  Referenz-Update interessiert hier nicht
//  Reflection muss nicht uno::XInterface sein, kann auch irgendein Interface sein...
// noch nicht eingefuegt?
// noch nicht vorhanden
// Objekt kann benutzt werden
// verwendet wird der neue Style noch nicht
//! zusammenfassen?
// muss zu getByIndex passen
//  Default-ctor wird fuer die Reflection gebraucht
//  pDocShell ist Null, wenn per ServiceProvider erzeugt
//  Referenz-Update interessiert hier nicht
//  wie bei setPropertyValue
//  Zeilenhoehen anpassen...
//! ModifyStyleSheet am Dokument (alte Werte merken)
//  Zellvorlagen = 2, Seitenvorlagen = 4
// kann eigentlich nicht sein...
//  duemmliche Default-Implementierung: alles einzeln per getPropertyState holen
//! sollte optimiert werden!
//  Default ist Default vom ItemPool, nicht vom Standard-Style,
//  damit es zu setPropertyToDefault passt
//  Default-Items mit falscher Slot-ID funktionieren im SfxItemPropertySet3 nicht
// fuer Item-Spezial-Behandlungen
// direkt im lebenden Style aendern...
// fuer Item-Spezial-Behandlungen
//  Default-Items mit falscher Slot-ID
//  funktionieren im SfxItemPropertySet3 nicht
//  Zeilenhoehen anpassen...
//! ModifyStyleSheet am Dokument (alte Werte merken)
// fuer Item-Spezial-Behandlungen
//  Default-Items mit falscher Slot-ID
//  funktionieren im SfxItemPropertySet3 nicht


17 / 63 | libreoffice-4.4.0.3/sc/source/ui/unoobj/fielduno.cxx
//  ScUnoEditEngine nur um aus einer EditEngine die Felder herauszubekommen...
//  EditSource hat sich selber als Listener angemeldet
//! Feld-Funktionen muessen an den Forwarder !!!
// Feld ist 1 Zeichen
//! Feld-Funktionen muessen an den Forwarder !!!
// Felder zaehlen, in Zelle ist der Typ egal
//! Feld-Funktionen muessen an den Forwarder !!!
//! Feld-Funktionen muessen an den Forwarder !!!
//  Typ egal (in Zellen gibts nur URLs)
//! Feld-Funktionen muessen an den Forwarder !!!
//  Typ egal (in Zellen gibts nur URLs)
// noch nicht eingefuegt
//  Typ egal (in Zellen gibts nur URLs)
//! Broadcast, um Selektion in anderen Objekten anzupassen
//! (auch bei anderen Aktionen)
//! Feld-Funktionen muessen an den Forwarder !!!
//  Typ egal (in Zellen gibts nur URLs)


4 / 61 | libreoffice-4.4.0.3/sc/source/ui/unoobj/textuno.cxx
//! wie ScCellObj::createTextCursorByRange, wenn SvxUnoTextRange_getReflection verfuegbar
//  neue Selektion: ein Zeichen
//! Testen, ob das Feld in dieser Zelle ist
//  sowas gibts nicht im Calc (?)


4 / 40 | libreoffice-4.4.0.3/sc/source/ui/unoobj/chartuno.cxx
// nicht weitersuchen
//! Fehler/Exception, wenn leer/ungueltig ???
// ist nicht 0
// ist nicht 0


3 / 76 | libreoffice-4.4.0.3/sc/source/ui/unoobj/servuno.cxx
//  noch nicht eingefuegt - DocShell=Null
//  wird nicht eingefuegt, sondern gefuellt
//  -> DocShell muss gesetzt sein, aber leere Ranges


42 / 129 | libreoffice-4.4.0.3/sc/source/ui/unoobj/viewuno.cxx
//! Clipping-Markierungen
//  VisibleCellsX gibt nur komplett sichtbare Zellen,
//  VisibleRange in Excel auch teilweise sichtbare.
// irgendwas muss ja im Range sein
//! Hilfsfunktion mit ScRange?
//  Default-ctor wird fuer SMART_REFLECTION_IMPLEMENTATION gebraucht
//! Listening oder so
//  Zuerst evtl. Drawing-Selektion aufheben
//  (MarkListHasChanged hebt Tabellen-Selektion auf)
//  Slot der Zeichenfunktion nochmal ausfuehren -> abschalten
// nach dem Dispatcher-Execute
//  Mehrfachselektion
// Markierung (alt&neu)
//! Methode an der View, um RangeList zu selektieren
// einzelnes Shape
// Shape-Collection (xShapeColl ist nicht 0)
//  Es wird auf die Tabelle des ersten Objekts umgeschaltet,
//  und alle Objekte selektiert, die auf dieser Tabelle liegen
//! Exception, wenn Objekte auf verschiedenen Tabellen?
// erstes Objekt
//  Ist auf dem Drawing-Layer etwas selektiert?
//  ShapeCollection erzeugen (wie in SdXImpressView::getSelection im Draw)
//  Zurueckgegeben wird XInterfaceRef, das muss das UsrObject-XInterface sein
//  sonst Tabellen-(Zellen-)Selektion
//  Mehrfachselektion
//  bei mehreren Tabellen Ranges kopieren
//! sollte eigentlich schon in ScMarkData::FillRangeListWithMarks passieren?
//  links oben, links unten, rechts oben, rechts unten - wie in Excel
// nicht geteilt: nur 0 gueltig
//  XSpreadsheet und ScCellRangesBase -> muss ein Sheet sein
// Y wird angezeigt
// es ist vertikal geteilt
//  erst alles aufheben -> kein Stress mit Scrolling zwischendurch o.ae.
//! wozu der Mumpitz mit queryInterface?
//! auch an der Applikation anbieten?
//  Optionen werden an der View und am Dokument (fuer neue Views) gesetzt,
//  damit sie beim Speichern erhalten bleiben.
//! An der App (Module) braeuchte man noch eine Extra-Moeglichkeit,
//! das einzustellen (fuer neue Dokumente)
//! wirklich?
// -> Checks im Menue
//! wozu der Mumpitz mit queryInterface?


187 / 632 | libreoffice-4.4.0.3/sc/source/ui/unoobj/cellsuno.cxx
//  CellRange enthaelt alle Eintraege von Cells, zusaetzlich eigene Eintraege
//  mit Which-ID 0 (werden nur fuer getPropertySetInfo benoetigt).
//  Cell enthaelt alle Eintraege von CellRange, zusaetzlich eigene Eintraege
//  mit Which-ID 0 (werden nur fuer getPropertySetInfo benoetigt).
//  Column und Row enthalten alle Eintraege von CellRange, zusaetzlich eigene Eintraege
//  mit Which-ID 0 (werden nur fuer getPropertySetInfo benoetigt).
//! ScLinkListener in anderes File verschieben !!!
// soll nicht sein
//! lcl_ApplyBorder nach docfunc verschieben!
// RowHeight bei Umrandung alleine nicht noetig
//  GetString an der EditCell macht Leerzeichen aus Umbruechen,
//  hier werden die Umbrueche aber gebraucht
//  ggf. ein ' davorhaengen wie in ScTabViewShell::UpdateInputHandler
//! (ChartCollection haelt dann auch dieses Objekt fest!)
//  Dontcare durch Default ersetzen, damit man immer eine Reflection hat
// Range im Range-Objekt anpassen
// um Dummy Position angeben zu koennen
// wenn nicht Marked, ignoriert wegen Negative
// sonst ist nichts zu tun
//  Which-ID des betroffenen Items, auch wenn das Item die Property
//  nicht alleine behandeln kann
// leer = nichts zu tun
//! Bei Items, die mehrere Properties enthalten (z.B. Hintergrund)
//! wird hier zuviel zurueckgesetzt
//! mit getPropertyValue zusammenfassen
// fuer Item-Spezial-Behandlungen
// leer = nichts zu tun
//  Fuer Teile von zusammengesetzten Items mit mehreren Properties (z.B. Hintergrund)
//  muss vorher das alte Item aus dem Dokument geholt werden
//! Das kann hier aber nicht erkannt werden
//! -> eigenes Flag im PropertyMap-Eintrag, oder was ???
//! Item direkt von einzelner Position im Bereich holen?
//  ClearInvalidItems, damit auf jeden Fall ein Item vom richtigen Typ da ist
// leer = nichts zu tun
// Index wird beim Einfuegen gesetzt
// leer = nichts zu tun
// fuer Item-Spezial-Behandlungen
// leer = nichts zu tun
// leer = nichts zu tun
//  ganze Tabelle sinnvoll begrenzen (auf belegten Datenbereich)
//  (nur hier, Listener werden auf den ganzen Bereich angemeldet)
//! direkt testen, ob es ein ScTableSheetObj ist?
//  sonst Ranges direkt uebernehmen
// RowAsHdr = ColHeaders und umgekehrt
//! auf doppelte testen?
//  im ScChartArray wird DBL_MIN verwendet, weil das Chart es so will
//  im ScChartArray wird DBL_MIN verwendet, weil das Chart es so will
//! fuer alle Tabellen getrennt, wenn Markierungen pro Tabelle getrennt sind!
//  belegte Zellen wegmarkieren
//  Notizen zaehlen als nicht-leer
//  IsMultiMarked reicht hier nicht (wird beim deselektieren nicht zurueckgesetzt)
// aNewRanges kann leer sein
//  passende Zellen selektieren
//  Date/Time Erkennung
// aNewRanges kann leer sein
//  passende Zellen selektieren
// aNewRanges kann leer sein
//  zuerst alles selektieren, wo ueberhaupt etwas in der Vergleichsspalte steht
//  (fuer gleiche Zellen wird die Selektion im zweiten Schritt aufgehoben)
//! fuer alle Tabellen, wenn Markierungen pro Tabelle!
//  alle nichtleeren Zellen mit der Vergleichsspalte vergleichen und entsprechend
//  selektieren oder aufheben
// aNewRanges kann leer sein
// kann leer sein
// von Teil des Ranges abhaengig
//  Wenn nichts gefunden wird, soll Null zurueckgegeben werden (?)
//  immer nur innerhalb dieses Objekts
//  bei findAll immer CellRanges, egal wieviel gefunden wurde
//  immer nur innerhalb dieses Objekts
//! mehrere Tabellen?
//  immer nur innerhalb dieses Objekts
// bei SearchAndReplace nicht benutzt
//  nix weiter...
// keine DocShell oder falscher Index
// leer ist moeglich
// nicht gefunden
//  einzelnen Range weglassen
//! zusammenfassen?
//  ColumnCount / RowCount sind weggefallen
//! werden im Writer fuer Tabellen noch gebraucht ???
// keine Tabelle angegeben -> auf dieser Tabelle
//  Matrix-Formel, wenn eindeutig Teil einer Matrix,
//  also wenn Anfang und Ende des Blocks zur selben Matrix gehoeren.
// beides dieselbe Matrix
// egal, von welcher Zelle
//! Fehler abfangen?
// DB-Bereich anlegen erst beim Ausfuehren, per API immer genau den Bereich
//  im SortDescriptor sind die Fields innerhalb des Bereichs gezaehlt
// ggf. Bereich anlegen
//  alten Einstellungen holen, falls nicht alles neu gesetzt wird
//  im SortDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  ByRow kann bei FillSortParam umgesetzt worden sein
// ggf. Bereich anlegen
// Bereich muss angelegt sein
// DB-Bereich anlegen erst beim Ausfuehren, per API immer genau den Bereich
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  das koennte theoretisch ein fremdes Objekt sein, also nur das
//  oeffentliche XSheetFilterDescriptor Interface benutzen, um
//  die Daten in ein ScFilterDescriptor Objekt zu kopieren:
//! wenn es schon ein ScFilterDescriptor ist, direkt per getImplementation?
//  Rest sind jetzt Properties...
//  ausfuehren...
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  Im Dialog wird immer der String angezeigt -> muss zum Wert passen
// ggf. Bereich anlegen
// Bereich muss angelegt sein
//  this ist hier nicht der Bereich, der gefiltert wird, sondern der
//  Bereich mit der Abfrage...
//! Test, ob xObject im selben Dokument ist
//! stattdessen vom Objekt?
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
// ungueltig -> null
// DB-Bereich anlegen erst beim Ausfuehren, per API immer genau den Bereich
//  im SubTotalDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  im SubTotalDescriptor sind die Fields innerhalb des Bereichs gezaehlt
// ggf. Bereich anlegen
// Bereich muss angelegt sein
// auch bei Remove die Feld-Eintraege behalten
// ggf. Bereich anlegen
// Bereich muss angelegt sein
// DB-Bereich anlegen erst beim Ausfuehren, per API immer genau den Bereich
// ggf. Bereich anlegen
// Bereich muss angelegt sein
// XPropertySet erweitert fuer Range-Properties
//  nicht ersetzen -> hinten anhaengen
//  neue Selektion: ein Zeichen
//! Testen, ob das Feld in dieser Zelle ist
//! Exception oder so?
// wenn keine Formel
//! Exception oder so?
//  sowas gibts nicht im Calc (?)
// XPropertySet erweitert fuer Zell-Properties
//! Exception oder so...
// soll nicht sein
//! einzelne Zelle oder ganze Tabelle???????
// effektive Groesse schon gesetzt?
//  Umbrueche updaten wie in ScDocShell::PageStyleModified:
// effektive Groesse schon gesetzt?
//  Umbrueche updaten wie in ScDocShell::PageStyleModified:
//! docfunc Funktion, auch fuer ScViewFunc::RemoveManualBreaks
//  Das DrawPage-Objekt meldet sich als Listener am SdrModel an
//  und sollte von dort alle Aktionen mitbekommen
//  Umbrueche und Undo
// keinen bestehenden Bereich veraendern
// einschalten
// abschalten
//! zuletzt gesetzten Bereich beim Abschalten merken und beim Einschalten wiederherstellen ???
// immer auch einschalten
// keinen bestehenden Bereich veraendern
// einschalten
// abschalten
//! zuletzt gesetzten Bereich beim Abschalten merken und beim Einschalten wiederherstellen ???
// immer auch einschalten
//! Filter und Options aus altem Link suchen
//! Filter und Options aus altem Link suchen
//! Filter und Options aus altem Link suchen
// ggf. Link eintragen oder loeschen
//  Update immer, auch wenn der Link schon da war
//! Update nur fuer die betroffene Tabelle???
//! Der Dateiname sollte nur einmal vorkommen (?)
//! Exception oder so?
//  Szenario-Ranges sind durch Attribut gekennzeichnet
//! sonst Fehler oder so
// XPropertySet erweitert fuer Sheet-Properties
//! Exception oder so?
//! Undo? (auch bei SID_STYLE_APPLY an der View)
// XPropertySet erweitert fuer Spalten-Properties
//! Exception oder so?
//  SC_SIZE_DIRECT mit Groesse 0 blendet aus
// sal_False bei Spalten momentan ohne Auswirkung
//! momentan immer gesetzt ??!?!
// XPropertySet erweitert fuer Zeilen-Properties
//! Exception oder so?
//  SC_SIZE_DIRECT mit Groesse 0 blendet aus
//  SC_SIZE_DIRECT mit Groesse 0 blendet aus
//! schneller selber testen?
// aPos auf erste passende Zelle setzen
// kommt nix mehr
// aus verschobenen Bereichen neu erzeugen
// Interface-Typ muss zu ScCellsObj::getElementType passen
//! direkt auf die AttrArrays zugreifen !!!!
//! direkt auf die AttrArrays zugreifen !!!!
// AttrArray-Index neu suchen
// kommt nix mehr
// Dok weggekommen oder so
// Interface-Typ muss zu ScCellFormatsObj::getElementType passen
// Interface-Typ muss zu ScCellFormatsObj::getElementType passen


18 / 60 | libreoffice-4.4.0.3/sc/source/ui/unoobj/afmtuno.cxx
//  ein AutoFormat hat immer 16 Eintraege
//! Zahlformat (String/Language) ??? (in XNumberFormat nur ReadOnly)
//! Dieses Objekt darf es nur einmal geben, und es muss an den Auto-Format-Daten
//! bekannt sein, damit Aenderungen gebroadcasted werden koennen
// falscher Index
//  Reflection muss nicht uno::XInterface sein, kann auch irgendein Interface sein...
// noch nicht eingefuegt?
// sofort speichern
// kann jetzt benutzt werden
//! zusammenfassen?
// sofort speichern
// muss zu getByIndex passen
//  Wenn ein AutoFormat-Objekt losgelassen wird, werden eventuelle Aenderungen
//  gespeichert, damit sie z.B. im Writer sichtbar sind
// Save() setzt SaveLater Flag zurueck
// muss zu getByIndex passen
//! alter Index ist ungueltig
// unbekannte Property


8 / 44 | libreoffice-4.4.0.3/sc/source/ui/unoobj/appluno.cxx
//  Anzahl der Funktionen, die als zuletzt benutzt gespeichert werden
//! Define mit funcpage.hxx und dwfunctr.hxx zusammenfassen !!!
//  Anzahl der PropertyValues in einer Function-Description
//  es wird direkt die "lebende" Liste veraendert,
//  mehr tut ScGlobal::SetUserList auch nicht
// alle Eintraege raus
// Liste wird mit den App-Optionen gespeichert
//! auf gueltige Werte testen?


44 / 285 | libreoffice-4.4.0.3/sc/source/ui/unoobj/docuno.cxx
//! umbenennen, sind nicht mehr nur Options
//! StandardDecimals als Property und vom NumberFormatter ????????
// setDelegator veraendert den RefCount, darum eine Referenz selber halten
// (direkt am m_refCount, um sich beim release nicht selbst zu loeschen)
// waehrend des queryInterface braucht man ein Ref auf das
// SvNumberFormatsSupplierObj, sonst wird es geloescht.
// beim setDelegator darf die zusaetzliche Ref nicht mehr existieren
//  NumberFormatter-Pointer am Uno-Objekt neu setzen
//! Exception oder so?
//! Exception oder so?
//! Exception oder so?
//! Exception oder so?
//! Exception oder so?
//! Exception oder so?
// nichts gefunden
//! das ist gelogen
//  das koennte theoretisch ein fremdes Objekt sein, also nur das
//  oeffentliche XConsolidationDescriptor Interface benutzen, um
//  die Daten in ein ScConsolidationDescriptor Objekt zu kopieren:
//! wenn es schon ein ScConsolidationDescriptor ist, direkt per getImplementation?
//! auch an der Applikation anbieten?
//  alles was ich nicht kenn, werf ich der SvxFmMSFactory an den Hals,
//  da wird dann 'ne Exception geworfen, wenn's nicht passt...
//! unterscheiden zwischen eigenen Services und denen vom Drawing-Layer?
//! warum sind die Parameter bei concatServiceNames nicht const ???
//  Referenz-Update interessiert hier nicht
//  Referenz-Update interessiert hier nicht
// noch nicht eingefuegt?
//  Dokument und neuen Range am Objekt setzen
// noch nicht eingefuegt?
//  InsertTable kann jetzt eigentlich nicht schiefgehen...
//! Referenz-Update fuer Tab und Start/Ende
// falscher Index
//  Der zu loeschende Bereich muss innerhalb des Objekts liegen
// nicht gefunden
//! Referenz-Update fuer Tab und Start/Ende
// falscher Index
//  Der zu loeschende Bereich muss innerhalb des Objekts liegen
//  Referenz-Update interessiert hier nicht
//! nTab bei Referenz-Update anpassen!!!
//! Referenz-Update fuer Tab und Start/Ende
// kein Dokument oder falscher Index
// nicht gefunden
// sonst ist auch Count = 0


36 / 107 | libreoffice-4.4.0.3/sc/source/ui/unoobj/datauno.cxx
// Type ist immer ScDbQuery oder ScDbTable
//! SortAscending muss aus der SheetSortDescriptor service-Beschreibung raus
//  Uno-Werte zusammensuchen
// FieldType wird ignoriert
// FieldType wird ignoriert
// Objekt festhalten
//! sonst Exception oder so? (zuviele Spalten)
//! Notify oder so fuer die Field-Objekte???
//  Flags/Einstellungen als Properties
// vom Interface gesetzt
// von aussen gesetzt
// kopiert alles
// allozierte Eintraege im Param
// Param wird nicht unter 8 resized
// ueberzaehlige Felder zuruecksetzen
// Param wird nicht unter 8 resized
// ueberzaehlige Felder zuruecksetzen
// allozierte Eintraege im Param
// allozierte Eintraege im Param
// Param wird nicht unter 8 resized
// ueberzaehlige Felder zuruecksetzen
// vom Interface gesetzt
// von aussen gesetzt
//  im SortDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
//  im FilterDescriptor sind die Fields innerhalb des Bereichs gezaehlt
// Import zu wiederholen?
// interne Operationen (sort, query, subtotal) nur, wenn kein Fehler
//! static Funktion um ScCellObj/ScCellRangeObj zu erzeugen am ScCellRangeObj ???
//  Referenz-Update interessiert hier nicht
//! "unbenannt" weglassen ?
//! "unbenannt" weglassen ?
//! "unbenannt" weglassen ?
//  Referenz-Update interessiert hier nicht


3 / 16 | libreoffice-4.4.0.3/sc/source/ui/unoobj/editsrc.cxx
// Notizen haben keine Felder
// bDataValid wird bei SetDocumentModified zurueckgesetzt
// Text muss neu geholt werden


28 / 98 | libreoffice-4.4.0.3/sc/source/ui/unoobj/linkuno.cxx
//  fuer Sheet- und Area-Links benutzt:
// nicht gefunden
// Name ist der Dateiname (URL)
// Name ist der Dateiname (URL)
//  pLink->Refresh mit neuem Dateinamen bringt sfx2::LinkManager durcheinander
//  darum per Hand die Tabellen umsetzen und Link per UpdateLinks neu erzeugen
//  zuerst Tabellen umsetzen
// nur Datei aendern
// wird bei UpdateLinks ungueltig
// alter Link raus, evtl. neuen Link anlegen
//  Daten kopieren
// neuer Link mit neuem Namen
//  Referenz-Update interessiert hier nicht
// kein Dokument oder Index zu gross
//  Name ist der Dateiname
//  Name ist der Dateiname
//  Name ist der Dateiname
// nicht gefunden
//! Undo zusammenfassen
// bei Remove geloescht
// verschieben, wenn durch Update Groesse geaendert
// neuer Bereich angegeben -> keine Inhalte verschieben
//  Referenz-Update interessiert hier nicht
// nicht gefunden
//! Test, ob Link noch im Dokument enthalten?
//! Test, ob Link noch im Dokument enthalten?
//! Test, ob Link noch im Dokument enthalten?
//  Referenz-Update interessiert hier nicht


1 / 21 | libreoffice-4.4.0.3/sc/source/ui/unoobj/confuno.cxx
//  Referenz-Update interessiert hier nicht


6 / 22 | libreoffice-4.4.0.3/sc/source/ui/unoobj/notesuno.cxx
//  Parent der Notiz ist die zugehoerige Zelle
//! existierendes Objekt finden und zurueckgeben ???
//  hamma nich
//! Exception oder so ??!
//  Notizen brauchen keine Extrawurst
//  Notizen brauchen keine Extrawurst


9 / 36 | libreoffice-4.4.0.3/sc/source/ui/unoobj/cursuno.cxx
/*if (!bFound)
    {
        OSL_FAIL("keine Matrix");
        //! Exception, oder was?
    }*/
//! und dann?
//! wirklich?
//! Fehler/Exception oder so, wenn zu gross/zu klein?
//! wirklich?
//  bei Block immer den Start nehmen
//! sonst Exception oder so
//  bei Block immer den Start nehmen
//! sonst Exception oder so


10 / 49 | libreoffice-4.4.0.3/sc/source/ui/unoobj/scdetect.cxx
// Bedeutung der Sequenzen
// 0x00??: genau Byte 0x?? muss an dieser Stelle stehen
// 0x0100: ein Byte ueberlesen (don't care)
// 0x02nn: ein Byte aus 0xnn Alternativen folgt
// 0x8000: Erkennung abgeschlossen
// DIF mit CR-LF
// DIF mit CR oder LF
//                                direkter Byte-Vergleich
// zunaechst unsynchron
// jetzt erst Synchronisierung


1 / 6 | libreoffice-4.4.0.3/include/formula/formulahelper.hxx
// Ein- und Ausgabe


1 / 7 | libreoffice-4.4.0.3/include/formula/formdata.hxx
// fuer Verschachtelung


1 / 11 | libreoffice-4.4.0.3/include/formula/funcutl.hxx
// zugeordnetes Edit-Control


1 / 7 | libreoffice-4.4.0.3/include/svx/svdsob.hxx
/*
  Deklaration eines statischen Mengentyps. Die Menge kann die Elemente
  0..255 aufnehmen und verbraucht stets 32 Bytes.
*/


2 / 9 | libreoffice-4.4.0.3/include/svx/sxmbritm.hxx
// laesst sich auch draggen, indem man den Masslinienabstand
// (SdrMeasureLineDistItem) ueber die Bezugskante hinwegdraggt


105 / 140 | libreoffice-4.4.0.3/include/svx/svdsnpv.hxx
// SDRCROOK_STRETCH ist noch nicht implementiert!
// Wenn GridSnap aus, auf ein Pixel fangen um Werte wie 10.01 zu vermeiden
// Objekte nur verschieben bei Resize/Rotate/...
// Slant anstelle von Shear anwenden
// Objekte bei Crook nicht verzerren
// sal_True=Hilfslinien fixiert, also nicht verschiebbar
// f.abg.Klassen Actions z,B, Draggen abbrechen.
// RecalcLogicSnapMagnetic muss bei jedem Wechsel des OutputDevices
// sowie bei jedem Wechsel des MapModes gerufen werden!
// Auf die View bezogene Koordinaten!
// Rueckgabewerte sind SDRSNAP_NOTSNAPPED,SDRSNAP_XSNAPPED,
// SDRSNAP_YSNAPPED oder SDRSNAP_XYSNAPPED
// Alle Fangeinstellungen sind Persistent.
// Fang auf Rastergitter
// Fang auf Seitenraender
// Fang auf Hilfslinien
// Fang auf LogFram von umgebenden Zeichenobjekten
// Fang auf ausgepraegte Punkte von umgebenden Zeichenobjekten
// Fang auf Konnektoren der Zeichenobjekte
// Normalerweise werden beim Move-Dragging von Zeichenobjekten alle
// 4 Ecken des Object-SnapRects gefangen. Folgende Einstellmoeglichkeit,
// wenn man nur auf die linke obere Ecke fangen will (z.B. DialogEditor):
// Hilfslinien fixiert (nicht verschiebbar)
// Fang des LogFram aller markierten Objekte
// Fang aller LogFram der markierten Objekte
// Fang ausgepraegter Punkte der markierten Objekte
// Fang der Konnektoren der markierten Objekte
// HitTest. Bei sal_True steht in rnHelpLineNum die Nummer der Hilfslinie und in rpPV
// die zugehoerige PageView.
// Verschieben einer vorhandenen Hilfslinie. nHelpLineNum und pPV von PickHelpLine verwenden.
// Interaktives einfuegen einer neuen Hilfslinie
// Aendern des Hilfslinientyps waerend des draggens
// SnapAngle ist fuer Winkel im Kreis, RotateDragging, ...
// Der Winkelfang wird unterdrueckt, wenn er mit
// durch SetAngleSnapEnabled(sal_False) ausgeschaltet ist.
// Der Winkelfang ist unabhaengig vom Koordinatenfang
// und somit von der Einstellung IsSnapEnabled()
// Es sollten nur Werte angegeben werden fuer die gilt:
// - Kreisbogen/-sektor/-abschnitt Winkel (Create und Dragging)
// Ortho hat je nach Kontext verschiedene Effekte:
//   - Linien werden nur im 45deg Raster zugelassen
//   - Statt Rechtecke werden Quadrate erzeugt
//   - Statt Ellipsen werden Kreise erzeugt
//     - Move nur Hor, Vert oder 45deg
//     - Mirror: nichts
//     - Shear ohne Resize
//     - Crook ohne Resize
//   - verschieben der Handles
//     - Spiegelachse nur 45deg Raster
//     - Rechteck Eckenradius: nichts
//     - Kreisobjekt Winkel: nichts
//     - Linie behaelt beim Draggen ihren Winkel bei und wird nur    (ni)
//       verlaengert bzw. verkuerzt.
// Defaultmaessig ist Ortho ausgeschaltet. Persistent.
// BigOrtho hat nur Relevanz wenn Ortho eingeschaltet ist.
// Beispiel: Ein Rechteck wird mit eingeschaltetem Ortho (also ein Quadrat)
//   erzeugt und die Maus wurde dabei vom Nullpunkt zu den Koordinaten
//   (80,30) gedraggt. Dann stuenden nun 2 Alternativen zur Bestimmung der
//   Kantenlaenge des Quadrats zur Wahl: 30 und 80.
//   Die normale Ortho-Funktuionalitaet brachte hierbei ein Quadrat mit
//   Kantenlaenge 30 (also immer die kleinere Groesse). Bei hinzugeschal-
//   tetem BigOrtho bekaeme man dagegen ein Quadrat der Kantenlaenge 80.
// Gleiches gilt auch fuer Resize.
// Defaultmaessig ist BigOrtho eingeschaltet. Persistent.
// bei MoveOnlyDragging=sal_True wird bei Resize/Rotate/Shear/Mirror/Crook
// nur das Zentrum der markierten Objekte transformiert. Groesse, Form
// und Drehwinkel der Objekte bleiben erhalten, nur ihre Positionen
// aendern sich. Persistent. Default=FALSE. (ni)
// Slant anstelle von Shear anwenden. Persistent. Default=FALSE.
// Objekte bei Crook nicht verzerren. Persistent. Default=FALSE. (ni)
// Special fuer IBM: Beim Draggen eines Polygonpunkts wird dieser
// geloescht, wenn seine beiden angrenzenden Linien eh' fast eine
// durchgehende Linie sind.
//   - Etwas fangen=Gefangen werden kann z.B. der Mauszeiger oder die z.Zt. im
//     Drag befindlichen markierten Objekte.
//   - Auf etwas fangen=Man kann z.B. auf das Grid oder auf Hilfslinien fangen.
// Grundsaetzlich wird nur gefangen auf sichtbare Elemente (-> Border,
// Hilfslinien, Konnektoren; Ausnahme: Grid). Ebenso koennen nur sichtbare
// Auf's Grid wird immer erst dann gefangen, wenn nix Anderes in der Naehe
// Der "Cursor" (also der Mauszeiger) beim Erzeugen von Objekten, beim Draggen
// von Polygonpunkten, ... wird immer auf allen eingeschalteten Fangalternativen
// gefangen (max 6).
// Beim Verschieben markierter Objekte ist das etwas anders. Statt des einen
// Mauscursors gibt es hier 4 Alternativen an den markierten Objekten, die
//   1. die logisch-umschliessenden Rahmen der einzelnen Objekte
//   2. der logisch-umschliessende Rahmen aller markierten Objekte
//   3. ausgezeichnete Punkte der markierten Objekte (Polygonpunkte, ...)
//   4. die Konnektoren der markierten Objekte
// Da 1. und 2. einander ausschliessen (2. ist eine Verfeinerung von 1.)
// bleiben 3 voneinander unabhaengige Alternativen. Bei 6. Moeglichkeiten auf
// die gefangen werden kann kaeme man auf max. 18 Kombinationsmoeglichkeiten!
// Deshalb werden folgende Vereinfachungen festgelegt:
//   1. Konnektoren fangen sich nur auf Konnektoren.
// Verbleiben also nun noch max. 2x5+1=11 Fangkombinationen beim MoveDrag:
//   1-3.  umschliessende(r) Rahmen auf Grid/Border/Hilfslinien
//   4.    umschliessende(r) Rahmen auf ausgezeichnete Objektpunkte
//   5.    umschliessende(r) Rahmen auf umschliessenden Rahmen
//   6-8.  ausgezeichnete Punkte auf Grid/Border/Hilfslinien
//   7.    ausgezeichnete Punkte auf ausgezeichnete Objektpunkte
//   8-10. ausgezeichnete Punkte auf umschliessenden Rahmen
//   11.   Konnektoren auf Konnektoren
// Beim MouseMove-Event im DragMove werden also diese bis zu max. 11 moeglichen
// Alternativen durchgetestet und die mit dem gerigsten Korrekturaufwand
// Beim Resize, ... wird immer nur der logisch-umschliessende Rahmen der
// markierten Objekte gefangen.


55 / 85 | libreoffice-4.4.0.3/include/svx/svdedxv.hxx
// Textobjekt wurde geaendert
// Fuer Writer: Textobjekt sollte geloescht werden
// - Allgemeines Edit fuer objektspeziefische Eigenschaften
// - Textedit fuer alle vom SdrTextObj abgeleiteten Zeichenobjekte
// Aktuell im TextEdit befindliches Obj
// Na eben der Outliner fuers TextEdit
// die aktuelle View des Outliners
// passendes Win zu pTextEditOutlinerView
// Zum Restaurieren des Cursors am jeweiligen Win
// Da hau' ich erstmal alles rein um kompatibel zu bleiben...
// Zum rufen des alten Handlers
// Outliner und View bei SdrEndTextEdit nicht deleten (f. Rechtschreibpruefung)
// Nur eine OutlinerView (f. Rechtschreibpruefung)
// Aktuell editiertes Objekt wurde gerade neu erzeugt
// Eine neue OutlinerView auf dem Heap anlegen und alle erforderlichen Parameter setzen.
// pTextEditObj, pTextEditPV und pTextEditOutliner muessen initiallisiert sein.
// Feststellen, ob der gesamte Text markiert ist. Liefert auch sal_True wenn
// kein Text vorhanden ist.
// Handler fuer AutoGrowing Text bei aktivem Outliner
// TextEdit ueber einen Outliner
// QuickTextEditMode bedeutet, dass Objekte mit Text sofort beim Anklicken
// editiert werden sollen. Default=TRUE. Persistent.
// Starten des TextEditMode. Ist pWin==NULL, wird das erste an der View
// angemeldete Win verwendet.
// Der Cursor des Fensters an dem Editiert wird wird bei
// SdrBeginTextEdit() gemerkt und bei SdrEndTextEdit() wieder restauriert.
// Die App muss sicherstellen, das die zum Zeitpunkt des BegEdit am
// Windows angemeldete Cursorinstanz beim SdrEndTextEdit noch gueltig ist.
// Ueber den Parameter pEditOutliner kann die Applikation einen eigenen
// Outliner vorgeben, der zum Editieren verwendet wird. Dieser gehoert
// nach Aufruf von SdrBeginTextEdit der SdrObjEditView und wird von dieser
// SdrObjEditView setzt dann das Modusflag (EditEngine/Outliner) an
// dieser Instanz und ausserdem auch den StatusEventHdl.
// Ebenso kann eine spezifische OutlinerView vorgegeben werden.
// bDontDeleteReally ist ein Spezialparameter fuer den Writer.
// Ist dieses Flag gesetzt, dann wird ein evtl. leeres Textobjekt
// nicht geloescht. Stattdessen gibt es dann einen Returncode
// SDRENDTEXTEDIT_SHOULDBEDELETED (anstelle von SDRENDTEXTEDIT_BEDELETED)
// der besagt, dass das Objekt geloescht werden sollte.
// Diese Methode liefert sal_True, wenn der Punkt rHit innerhalb der
// des Objektbereichs oder der OutlinerView liegt.
// Diese Methode liefert sal_True, wenn der Punkt rHit innerhalb des
// Handle-dicken Rahmens liegt, der die OutlinerView bei TextFrames
// umschliesst.
// Bei aktiver Selektion, also zwischen MouseButtonDown und
// MouseButtonUp liefert diese Methode immer TRUE.
// Wer das z.Zt. im TextEdit befindliche Objekt braucht:
// Das aktuelle Win des Outliners
// An den hier abgeholten Outliner kann man schliesslich
// Events versenden, Attribute setzen, Cut/Copy/Paste rufen,
// Intern: Beim Splitteraufziehen neue OutlinerView...
// Object-MacroModus (z.B. Rect als Button oder sowas):
// Persistent. Default TRUE. SvDraw wertet das Flag u.a. bei
// SdrView::GetPreferredPointer() aus. Hat nur Wirkung, wenn das Dokument
// Draw-Objekte mit Macrofunktionalitaet hat (SdrObject::HasMacro()==sal_True).


3 / 194 | libreoffice-4.4.0.3/include/svx/svdmrkv.hxx
// Object for SdrBeginTextEdit (Textbereich)
// Persistent - FrameDrag auch bei Einzelobjekten
// bei einem anschliessenden Rotate sinnvoll als Drehmittelpunkt setzen.


35 / 55 | libreoffice-4.4.0.3/include/svx/svdtrans.hxx
// Winkelangaben der DrawingEngine sind 1/100 Degree
// Um Winkel der DrawingEngine mit den Trigonometrischen Funktionen
// verarbeiten zu koennen, muessen sie zunaest ins Bogenmass umgerechnet
// werden. Dies gestaltet sich recht einfach mit der folgenden Konstanten
// nPi180. Sei nAngle ein Winkel in 1/100 Deg so schreibt man z.B.:
// Rueckwandlung entsprechend durch Teilen.
// Bei zuweing Stellen ist tan(4500*nPi180)!=1.0
// Der maximale Shearwinkel
// rPnt.X bzw rPnt.Y wird auf rCenter.X bzw. rCenter.Y gesetzt!
// anschliessend muss rPnt nur noch um rCenter gedreht werden.
// Der Rueckgabewinkel ist ausnahmsweise in Rad.
// Die folgenden Methoden behandeln einen Punkt eines XPolygons, wobei die
// benachbarten Kontrollpunkte des eigentlichen Punktes ggf. in pC1/pC2
// uebergeben werden. Ueber rSin/rCos wird gleichzeitig sin(nAngle) und cos(nAngle)
// zurueckgegeben.
// Der Rueckgabewinkel ist hier ebenfalls in Rad.
// sonst nicht noetig
// sonst nicht noetig
// Y-Achse zeigt nach unten! Die Funktion negiert bei der
// Winkelberechnung die Y-Achse, sodass GetAngle(Point(0,-1))=90.00deg.
// Der Rueckgabewert liegt im Bereich -180.00..179.99 Degree und
// ist in 1/100 Degree angegeben.
// Winkel normalisieren auf -180.00..179.99
// Winkel normalisieren auf    0.00..359.99
// Sektor im kartesischen Koordinatensystem bestimmen
// Berechnet die Laenge von (0,0) via a^2 + b^2 = c^2
// Zur Vermeidung von Ueberlaeufen werden ggf. einige Stellen ignoriert.
/*
  Transformation eines Rechtecks in ein Polygon unter            ------------
  Anwendung der Winkelparameter aus GeoStat.                    /1        2/
  Referenzpunkt ist stets der Punkt 0, also die linke          /          /
  obere Ecke des Ausgangsrects.                               /          /
  Bei der Berechnung des Polygons ist die Reihenfolge        /          /
  (erst Shear, dann Rotation vorgegeben).                   /          / \
                                                           /          /   |
  A) Ausgangsrechteck aRect  B) Nach Anwendung von Shear  /0        3/  Rot|
  +------------------+       --------------------        ------------  ------
  |0                1|        \0                1\       C) Nach Anwendung
  |                  |         \                  \      von Rotate
  |                  |       |  \                  \
  |3                2|       |   \3                2\
  +------------------+       |    --------------------
                             |Shr |
  Bei Rueckkonvertierung des        Polygons in ein Rect ist die Reihenfolge
  zwangslaeufig umgekehrt:
  - Berechnung des Drehwinkels: Winkel der Strecke 0-1 aus Abb. C) zum Horizont
  - Rueckdrehung des geshearten Rects (man erhaelt Abb B))
  - Bestimmung der Breite des Rects=Laenge der Strecke 0-1 aus Abb. B)
  - Bestimmung der Hoehe des Rects=vertikaler Abstand zwischen den Punkten
    0 und 3 aus Abb. B)
  - Bestimmung des Shear-Winkels aus der Strecke 0-3 zur Senkrechten.
  Es ist darauf zu achten, dass das Polygon bei einer zwischenzeitlichen
  Transformation evtl. gespiegelt wurde (Mirror oder Resize mit neg. Faktor).
  In diesem Fall muss zunaecht eine Normalisierung durch Vertauschung der
  Punkte (z.B. 0 mit 3 und 1 mit 2) durchgefuehrt werden, damit der
  Richtungssinn im Polygon wieder stimmig ist.
  Hinweis: Positiver Shear-Winkel bedeutet Shear mit auf dem Bildschirm
  sichtbarer positiver Kursivierung. Mathematisch waere dass eine negative
  Kursivierung, da die Y-Achse auf dem Bildschirm von oben nach unten verlaeuft.
  Drehwinkel: Positiv bedeutet auf dem Bildschirm sichtbare Linksdrehung.
*/
// Geometrischer Status fuer ein Rect
// Multiplikation und anschliessende Division.
// Rechnung und Zwischenergebnis sind BigInt.
// Fehlerbehaftetes Kuerzen einer Fraction.
// nDigits gibt an, wieviele signifikante Stellen in
// Zaehler/Nenner mindestens erhalten bleiben sollen.
// Fuer die Umrechnung von Masseinheiten


1 / 125 | libreoffice-4.4.0.3/include/svx/unoshape.hxx
// Umrechnungen fuer den Writer, der in TWIPS arbeitet


37 / 99 | libreoffice-4.4.0.3/include/svx/svdhdl.hxx
// Wird ein Handle von der Maus beruehrt (IsHit()), so wird von der View der
// entsprechende Mauszeiger vom Handle abgeholt und der App auf Anfrage zum
// reinschalten uebergeben.
// Handles wie z.B. der Rotationsmittelpunkt oder die Spiegelachse werden von
// der View generiert, wenn vom Controller der entsprechende Transformations-
// Modus selektiert wird.
// HDL_MOVE...HDL_LWRGT muessen im enum immer zusammen stehen bleiben!
// Handle zum Verschieben des Objekts
// Oben rechts
// Unten links
// Unten rechts
// Punktselektion an Polygon oder Bezierkurve
// Gewicht an einer Bezierkurve
// Winkel an Kreissegmenten, Eckenradius am Rect
// Referenzpunkt 1, z.B. Rotationsmitte
// Referenzpunkt 2, z.B. Endpunkt der Spiegelachse
// Die Spiegelachse selbst
// fuer den Zugriff auf nObjHdlNum
// Gehoert das Handle zu einem Objekt?
// Gehoert das Handle zu einem Objekt in einer bestimmten PageView?
// Zum Feststelen der Handlegroesse
// Handles bzw. Mauszeiger drehen
// wird von der MarkView benoetigt
// ist noch vollstaendig zu implementieren
// Ein selektierter Polygonpunkt?
// True=Handle wird 1 Pixel groesser dargestellt
// u.a. fuer Hld-Paint Optimierung bei MarkPoint/UnmarkPoint, ...
// Spiegelachse
// Ein SdrHdlBezWgt hat Kenntnis von seinem "BasisHandle". Seine Draw-Methode
// zeichnet zusaetzlich eine Linie von seiner Position zur Position dieses
// das ist kein Copy-Ctor!!!
// Handles nach aussen ruecken (fuer TextEdit)
// Sortierung: 1.Level Erst Refpunkt-Handles, dann normale Handles, dann Glue, dann User, dann Plushandles
// AddHdl uebernimmt das Handle in sein Eigentum. Es muss
// also auf dem Heap stehen, da Clear() ein delete macht.
// Zuletzt eingefuegte Handles werden am ehesten getroffen
// (wenn Handles uebereinander liegen).


11 / 24 | libreoffice-4.4.0.3/include/svx/svdglev.hxx
//  Editieren von Klebepunkten an den Objekten (Klebepunkte fuer Verbinder)
// Markierte Klebepunkte kopieren und anstelle der alten markieren
// Durch den Parameter nThisEsc uebergibt man die Richtung, die man
// checken bzw. setzen/loeschen will.
// Moegliche Werte fuer nThisEsc sind z.Zt.
// SDRESC_LEFT, SDRESC_RIGHT, SDRESC_TOP und SDRESC_BOTTOM
// Checken/setzen, ob die Klebepunktpositionen relativ zur
// Objektgroesse sind (Percent=sal_True) oder nicht (Percent=sal_False)
// bVert=FALSE: Horizontales Alignment checken/setzen
//      SDRHORZALIGN_DONTCARE (nur bei Get())
// bVert=TRUE: Vertikales Alignment checken/setzen


113 / 180 | libreoffice-4.4.0.3/include/svx/svdoedge.hxx
//   Vorausdeklarationen
// Wird beim Draggen eines Knotens gesetzt
// Referenziertes Objekt
// sal_True= es wird der guenstigste Konnektor gesucht
// sal_True= es wird der guenstigste Scheitelpunkt zum konnekten gesucht
// sal_True= Hor. Objektabstand wurde gedragt (Overwrite)
// sal_True= Vert. Objektabstand wurde gedragt (Overwrite)
// AutoConnector am Scheitelpunkt nCon
// AutoConnector am Eckpunkt nCon
// Die 5 Distanzen werden beim draggen bzw. per SetAttr gesetzt und von
// ImpCalcEdgeTrack ausgewertet. Per Get/SetAttr/Get/SetStyleSh werden
// jedoch nur 0-3 longs transportiert.
// Nachfolgende Werte werden von ImpCalcEdgeTrack gesetzt
// 0xFFFF=keine, sonst Punktnummer des Linienbeginns
// Form des Ortho-Verbindes, z.B. 'Z','U',I','L','S',...
// Verbindungszustand des Linienanfangs
// Verbindungszustand des Linienendes
// sal_True=Verbindungsverlauf muss neu berechnet werden.
// Verbindungszustand des Linienanfangs
// Verbindungszustand des Linienendes
// Verrieglung
// sal_True=Verbindungsverlauf muss neu berechnet werden.
// Neuberechnung des Verbindungsverlaufs
// eventuelle Neuberechnung des Verbindungsverlaufs
// Werte vom Pool nach aEdgeInfo kopieren
// Werte vom aEdgeInfo in den Pool kopieren
// Zur Bestimmung der Verlaufslinie werden folgende Item-Parameter des SdrItemPool verwendet:
//      Verlauffreiheitswinkel.
//      Der Winkel, in dem die Verbindungslinie verlaufen darf.
//      Der Winkel, in dem die Verbindungslinie aus dem Objekt austreten darf.
//      sal_True= die Verbindungslinie tritt aus dem Obj Strahlenfoermig aus.
//      Also Winkelvorgabe durch die Strecke ObjMitte/Konnektor.
//      Objektdrehwinkelberuecksichtigung.
//      sal_True= Bei der Bestimmung des Objektaustrittswinkels wird der
//      Drehwinkel des Objekts als Offset beruecksichtigt.
//      Das ist der Default-Mindestabstand der bei der Berechnung der
//      Verbindungslinie zu den angedockten Objekten in logischen Einheiten.
//      Dieser Abstand wird innerhalb des Objektes "ueberschrieben", sobald
//      der User an den Linien draggd. Beim Andocken an ein neues Objekt wird
//      dann jedoch wieder dieser Default verwendet.
// Allgemeines zu Konnektoren:
// Es gibt Knoten und Kantenobjekte. Zwei Knoten koennen durch eine Kante
// miteinander verbunden werden. Ist eine Kante nur an einem Ende an einen
// Knoten geklebt, ist das andere Ende auf einer absoluten Position im Doc
// fixiert. Ebenso ist es natuerlich auch moeglich, dass eine Kante an beiden
// Enden "frei", also nicht mit einem Knotenobjekt verbunden ist.
// Ein Kantenobjekt kann theoretisch auch gleichzeitig Knotenobjekt sein. In
// der ersten Version wird das jedoch noch nicht realisiert werden.
// Eine Verbindung zwischen Knoten und Kante kann hergestellt werden durch:
// - Interaktives erzeugen eines neuen Kantenobjekts an der SdrView wobei
//   Anfangs- bzw. Endpunkt der Kante auf ein Konnektor (Klebestelle) eines
//   bereits vorhandenen Knotenobjekts gelegt wird.
// - Interaktives draggen des Anfangs- bzw. Endpunkts eines bestehenden
//   Kantenobjekts an der SdrView auf ein Konnektor (Klebestelle) eines
//   bereits vorhandenen Knotenobjekts.
// Verschieben von Knotenobjekten stellt keine Verbindungen her. Ebenso auch
// nicht das direkte Verschieben von Kantenendpunkten am SdrModel...
// Verbindungen koennen auch hergestellt werden, wenn die Konnektoren an der
// View nicht sichtbar geschaltet sind.
// Eine vorhandene Verbindung zwischen Knoten und Kante bleibt erhalten bei:
// - Draggen (Move/Resize/Rotate/...) des Knotenobjekts
// - Verschieben einer Konnektorposition im Knotemobjekt
// - gleichzeitiges Draggen (Move/Resize/Rotate/...) von Knoten und Kante
// Eine Verbindung zwischen Knoten und Kante kann geloesst werden durch:
// - Loeschen eines der Objekte
// - Draggen des Kantenobjekts ohne gleichzeitiges Draggen des Knotens
// - Loeschen des Konnektors am Knotenobjekt
// Beim Draggen muss die Aufforderung zum loesen der Verbindung von ausserhalb
// des Models befohlen werden (z.B. von der SdrView). SdrEdgeObj::Move() loesst
// die Verbindung nicht selbsttaetig.
// Jedes Knotenobjekt kann Konnektoren, sog. Klebestellen besitzen. Das sind die
// geometrischen Punkte, an denen das verbindende Kantenobjekt bei hergestellter
// Verbindung endet. Defaultmaessig hat jedes Objekt keine Konnektoren. Trotzdem
// kann man bei bestimmten View-Einstellungen eine Kante andocken, da dann z.B.
// an den 4 Scheitelpunkten des Knotenobjekts bei Bedarf automatisch Konnektoren
// generiert werden. Jedes Objekt liefert dafuer 2x4 sog. Default-Konnektorposi-
// tionen, 4 an den Scheitelpunkten und 4 an den Eckpositionen. Im Normalfall
// liegen diese an den 8 Handlepositionen; Ausnahmen bilden hier Ellipsen,
// Parallelogramme, ... . Darueberhinaus koennen auch an jedem Knotenobjekt
// anwenderspeziefische Konnektoren gesetzt werden.
// Dann gibt es noch die Moeglichkeit, ein Kante an einem Objekt mit dem
// Attribut "bUseBestConnector" anzudocken. Es wird dann aus dem Angebot der
// Konnektoren des Objekts oder/und der Scheitelpunkte, jeweils die fuer den
// Verlauf der Verbindungslinie guenstigste Konnektorposition verwendet. Der
// Anwender vergibt dieses Attribut, indem er den Knoten in seiner Mitte
// andockt (siehe z.B. Visio).
// 09-06-1996: bUseBestConnector verwendet nur Scheitelpunktklebepunkte.
// Und hier noch etwas Begriffsdefinition:
//   Verbinder : Eben das Verbinderobjekt (Kantenobjekt)
//   Knoten    : Ein beliebiges Objekt, an dem ein Verbinder drangeklebt
//               werden kann, z.B. ein Rechteck, ...
//   Klebepunkt: Der Punkt, an dem der Verbinder an das Knotenobjekt
//               geklebt wird. Hierbei gibt es:
//                 Scheitelpunktklebepunkte: Jedes Knotenobjekt hat diese
//                     Klebepunkte von Natur aus. Moeglicherweise gibt es
//                     im Draw bereits die Option "Automatisch ankleben an
//                     Objektscheitelpunkte" (default an)
//                 Eckpunktklebepunkte: Auch diese Klebepunkte sind den
//                     Objekten von mir bereits mitgegeben. Wie die oben
//                     erwaehnten gibt es fuer diese moeglicherweise
//                     bereits auch eine Option im Draw. (default aus)
//                 Scheitelpunktklebepunkte und Eckpunktklebepunkte sind
//                     im Gegensatz zu Visio nicht optisch sichtbar; sie
//                     sind eben einfach da (wenn Option eingeschaltet).
//                 Benutzerdefinierte Klebepunkte: Gibt es an jedem
//                     sichtbar geschaltet werden (beim editieren immer
//                     sichtbar). Zur Zeit sind die jedoch noch nicht ganz
//                     fertigimplementiert.
//                 Automatische Klebepunktwahl: Wird der Verbinder so an
//                     das Knotenobjekt gedockt, dass der schwarke Rahmen
//                     das gesamte Objekt umfasst, so versucht der
//                     Verbinder von den 4 Scheitelpunktklebepunkten (und
//                     zwar nur von denen) den guenstigsten herauszufinden.


1 / 28 | libreoffice-4.4.0.3/include/svx/viewpt3d.hxx
/*************************************************************************
|*
|* 3D-Viewport nach PHIGS
|*
\************************************************************************/


17 / 22 | libreoffice-4.4.0.3/include/svx/svdlayer.hxx
// zum Broadcasten
// Einem SdrLayer kann man sagen dass er ein (der) Standardlayer sein soll.
// Es wird dann laenderspeziefisch der passende Name gesetzt. SetName()
// setzt das Flag "StandardLayer" ggf. zurueck auf "Userdefined".
// Beim Aendern von Layerdaten muss man derzeit
// noch selbst das Modify-Flag am Model setzen.
// Der Admin der Seite kennt den Admin des Docs
// zum Broadcasten
// Eine noch nicht verwendete LayerID raussuchen. Sind bereits alle
// verbraucht, so gibt's 'ne 0. Wer sicher gehen will, muss vorher
// GetLayerCount()<SDRLAYER_MAXCOUNT abfragen, denn sonst sind alle
// vergeben.
// Alle Layer loeschen
// Neuer Layer wird angelegt und eingefuegt
// Neuer Layer, Name wird aus der Resource geholt
// Iterieren ueber alle Layer
/*
Anmerkung zu den Layer - Gemischt symbolisch/ID-basierendes Interface
    Einen neuen Layer macht man sich mit:
      pLayerAdmin->NewLayer("Der neue Layer");
    Der Layer wird dann automatisch an das Ende der Liste angehaengt.
    Entsprechdes gilt fuer Layersets gleichermassen.
    Das Interface am SdrLayerSet basiert auf LayerID's. Die App muss sich
    dafuer am SdrLayerAdmin eine ID abholen:
        SdrLayerID nLayerID=pLayerAdmin->GetLayerID("Der neue Layer");
    Wird der Layer nicht gefunden, so liefert die Methode SDRLAYER_NOTFOUND
    zurueck. Die Methoden mit ID-Interface fangen diesen Wert jedoch i.d.R
    sinnvoll ab.
    Hat man nicht nur den Namen, sondern gar einen SdrLayer*, so kann man
    sich die ID natuerlich wesentlich schneller direkt vom Layer abholen.
bInherited:
    TRUE: Wird der Layer/LayerSet nicht gefunden, so wird im Parent-LayerAdmin
          nachgesehen, ob es dort einen entsprechende Definition gibt.
    FALSE: Es wird nur dieser LayerAdmin durchsucht.
    Jeder LayerAdmin einer Seite hat einen Parent-LayerAdmin, n?mlich den des
    Model. Das Model selbst hat keinen Parent.
*/


10 / 25 | libreoffice-4.4.0.3/include/svx/sxmlhitm.hxx
//    # Zu bemassendes Objekt #
// Abstand der Masslinie zur Bezugskante (Norm=8mm)
// laesst sich auch draggen an den beiden Handles
// die auf den Pfeilspitzen liegen
// Ueberhang der Masshilfslinien an der Masslinie (Norm=2mm)
// Abstand der der Masshilfslinienenden zur Bezugskante
// Damit die Masshilfslinien nicht das Objekt beruehren
// Ueberlaenge der Hilfslinien ueber die Bezugskante
// laesst sich auch draggen an den beiden runden Handles,
// die sich default unter den beiden Referenzpunkten befinden


52 / 147 | libreoffice-4.4.0.3/include/svx/svdotext.hxx
//   Vorausdeklarationen
// Name des referenzierten Dokuments
// ggf. ein Filter
// Das aRect ist gleichzeig auch das Rect vom RectObj und CircObj.
// Bei bTextFrame=sal_True wird der Text in dieses Rect hineinformatiert.
// Bei bTextFrame=sal_False wird der Text am Mittelpunkt des Rect zentriert.
// Der GeoStat enthaelt den Drehwinkel und einen Shearwinkel
// Hier merke ich mir die Ausmasse des Textes (n.i.)
// Ein Outliner*, damit
// 1. das TextObj nicht von mehreren Views gleichzeitig editiert und
// 2. beim Streamen waerend des Editierens ein Flush() ausgefuehrt
// werden kann
// Bei Fontwork muss soviel auf's BoundRect draufgerechnet werden
// damit es ausreichend gross ist.
// Moegliche Werte fuer eTextKind sind:
//     OBJ_TEXTEXT      Textfortsetzungsrahmen
// eTextKind hat nur Bedeutung, wenn bTextFrame=sal_True, da es sich sonst
// um ein beschriftetes Grafikobjekt handelt.
// Fuer beschriftete Zeichenobjekte ist bTextFrame=FALSE. Der Textblock
// wird dann hoizontal und vertikal an aRect zentriert. Bei bTextFrame=
// sal_True wird der Text in aRect hineinformatiert. Der eigentliche Textrahmen
// ist durch ein SdrRectObj mit bTextFrame=sal_True realisiert.
// Fuer Optimierung von Textobjekten
// Obj darf nicht gesheart werden   (->Graf+Ole+TextFrame)
// Obj darf nicht gedreht werden    (->Ole)
// Obj darf nicht gespiegelt werden (->Ole,TextFrame)
// Fuer Objekt mit freier Groesse im Draw (Mengentext). Das Flag wird vom
// der App beim Create gesetzt.
// Wenn das Objekt dann spaeter in der Breite resized wird, wird
// AutoGrowWidth abgeschaltet (Hart auf sal_False attributiert). Das Flag wird
// dann ebenfalls auf sal_False gesetzt, sodass sich das Objekt anschliessend
// wie ein normales Textobjekt verhaelt.
// Resize in der Breite kann sein:
// - Interaktives Resize in Einfach- oder Mehrfachselektion
// Konstruktoren fuer beschriftete Zeichenobjekte
// via eCharSet kann der CharSet der vorliegenden Datei uebergeben werden.
// Bei RTL_TEXTENCODING_DONTKNOW wird der CharSet der aktuellen Plattform verwendet.
// Derzeit unterstuetzt wird ASCII und RTF wobei ich die Unterscheidung
// selbst treffe. rFilterName ist noch ohne Bedeutung und muss leer gelassen
// I.d.R. muss die App nur SetTextLink() rufen - der Rest geschieht von
// selbst (SfxLinkManager). Die Methode LoadText() kann ausserdem verwendet
// werden, um eine Datei in ein Textobjekt zu laden (ohne Verknuepfung).
// TextLinks koennen nicht editiert werden (allenfalls spaeter mal ReadOnly).
// Eine Attributierung kann nur am Textrahmen vollzogen werden.
// FitToSize und Fontwork wird bei GetTextSize() nicht berueksichtigt!
// Gleichzeitig wird der Text in den Outliner gesetzt (ggf.
// der des EditOutliners) und die PaperSize gesetzt.
// Soll die Fontwork-Kontour versteckt werden?
// Textfluss innerhalb Kontur
// Horizontale Textausrichtung
// Vertikale Textausrichtung
// Wird zur Bestimmung des Textankerbereichs benoetigt


5 / 11 | libreoffice-4.4.0.3/include/svx/svdpoev.hxx
// Ein PolySegment kann eine Strecke oder eine Bezierkurve sein.
// Moeglicherweise ist das Obj hinterher geloescht:
// Hierbei entstehen eventuell beliebig viele neue Objekte:
// Alle markierten Polylines werden zu Polygonen, alle offenen
// Bezierkurven zu geschlossenen.


8 / 18 | libreoffice-4.4.0.3/include/svx/svdglue.hxx
// Bezugspunkt ist SdrObject::GetSnapRect().Center()
// bNoPercent=false: Position ist -5000..5000 (1/100)% bzw. 0..10000 (je nach Align)
// bNoPercent=true : Position ist in log Einh, rel zum Bezugspunkt
// Temporaer zu setzen fuer Transformationen am Bezugsobjekt
// Temporaer zu setzen fuer Transformationen am Bezugsobjekt
// Beim Insert wird dem Objekt (also dem GluePoint) automatisch eine Id zugewiesen.
// ReturnCode ist der Index des neuen GluePoints in der Liste
// Temporaer zu setzen fuer Transformationen am Bezugsobjekt


1 / 85 | libreoffice-4.4.0.3/include/svx/fmgridif.hxx
// spaeter Constructor, immer nach dem realen Constructor zu rufen !


9 / 16 | libreoffice-4.4.0.3/include/svx/svdorect.hxx
//   Vorausdeklarationen
// Rechteck-Objekte (Rechteck,Kreis,...)
// wg SetXPolyDirty bei GrowAdjust
// RecalcXPoly sollte ueberladen werden. Dabei muss dann eine XPolygon
// Instanz generiert (new) und an mpXPoly zugewiesen werden.
// Der Eckenradius-Parameter fliegt irgendwann raus. Der Eckenradius
// ist dann (spaeter) ueber SfxItems einzustellen (SetAttributes()).
// Konstruktion eines Rechteck-Zeichenobjekts
// Konstruktion eines Textrahmens


29 / 100 | libreoffice-4.4.0.3/include/svx/svdpage.hxx
// unbekannt
// einlesen eines Doks
// kommt aus dem Undo
// irgendjemand kopiert...
// vom Anwender interaktiv erzeugt
// Diese Liste gehoert zu diesem Model (Layer,ItemPool,Storage).
// Page, in die Liste haengt. Kann auch this sein.
// OwnerObject, falls Liste eines GruppenObjekts.
// !!! Diese Methode nur fuer Leute, die ganz genau wissen was sie tun !!!
// alles Aufraeumen (ohne Undo)
// Neuberechnung der Objekt-Ordnungsnummern
// aus Liste entfernen ohne delete
// Vorhandenes Objekt durch ein anderes ersetzen.
// Wie Remove&Insert jedoch performanter, da die Ordnungsnummern
// nicht Dirty gesetzt werden muessen.
// Die Z-Order eines Objekts veraendern
// Alle Textobjekte neu formatieren, z.B. bei Druckerwechsel
// Die Vorlagenattribute der Zeichenobjekte in harte Attribute verwandeln.
// Gelinkte Seite oder gelinktes Gruppenobjekt
/*
Eine Sdraw-Seite enthaelt genau eine Objektliste sowie eine Beschreibung
der physikalischen Seitendimensionen (Groesse/Raender). Letzteres wird
lediglich zum Fangen von Objekten beim Draggen benoetigt.
An der Seite lassen sich (ueber SdrObjList) Objekte einfuegen und loeschen,
nach vorn und nach hinten stellen. Ausserdem kann die Ordnungszahl eines
Objektes abgefragt sowie direkt gesetzt werden.
*/
// Fuer das Fangraster/Punkgitter im Writer
// Seitenrand links
// Seitenrand oben
// Seitenrand rechts
// Seitenrand unten
// Aenderungen an den Layern setzen nicht das Modified-Flag !
// fuer's Raster im Writer, auch fuer AlignObjects wenn 1 Objekt markiert ist
// wenn pRect!=NULL, dann die Seiten, die von diesem Rect intersected werden
// ansonsten die sichtbaren Seiten.


67 / 152 | libreoffice-4.4.0.3/include/svx/svdpntv.hxx
// Nur zum vergleichen
// Aktueller Zeichenlayer
// Aktueller Layer fuer Bemassung
//  Container                   aPagV;         // Liste von SdrPageViews
// Persistent. Klebepunkte anzeigen
// Klebepunkte auch bei GluePointEdit anzeigen
// Klebepunkte auch bei EdgeTool anzeigen
// Klebepunkte anzeigen, wenn 1 Edge markiert
// Pens und Brushes werden zurueckgesetzt.
// bool fuer die Verwaltung des anzuzeigenden Status
// Gruppe Betreten/Verlassen. Default ist sal_True, wird aber
// beispielsweise beim Chart auf sal_False gesetzt, da dort
// die Ghosted-Effekte zur Darstellug unerwuenscht sind.
// Wenn man den IdleStatus des Systems nicht abwarten will (auf const geschummelt):
// ModelHasChanged wird gerufen, sobald nach beliebig vielen HINT_OBJCHG
// das System wieder idle ist (StarView-Timer). Wer diese Methode ueberlaed,
// muss unbedingt ModelHasChanged() der Basisklasse rufen.
// Alle Actions z.B. Draggen abbrechen.
// Muss dann bei jedem Fensterwechsel (wenn die SdrView in mehreren
// Fenstern gleichzeitig dargestellt wird (->z.B. Splitter)) und bei
// jedem MapMode(Scaling)-wechsel gerufen werden, damit ich aus meinen
// Pixelwerten logische Werte berechnen kann.
// Flag zur Visualisierung von Gruppen abfragen/testen
// Am DragStatus laesst sich beispielsweise erfragen, welche
// entfernung bereits gedraggd wurde, etc.
// Anmelden/Abmelden einer PageView an der View.
// Dieselbe // Seite kann nicht mehrfach angemeldet werden.
// Methoden mit dem Suffix PgNum erwarten als numerischen Parameter
// eine Seitennummer (0...). Methoden mit dem Suffix PvNum erwarten
// degagen als numerischen Parameter die Nummer der PageView an der
// SdrView (Iterieren ueber alle angemeldeten Pages).
// Iterieren ueber alle angemeldeten PageViews
// Pageview einer bestimmten Seite ermitteln
// Test, ob eine Seite getroffen
// Die Seite, die dem Punkt am naechsten ist. Liefert nur NULL,
// wenn absolut keine Seite angemeldet ist.
// Eine SdrView kann auf mehreren Fenstern gleichzeitig abgebiltet sein:
// Seite (weisse Flaeche) malen oder nicht
// Seite (weisse Flaeche) malen oder nicht
// Seitenrandlinie malen oder nicht
// Rastergitter malen oder nicht
// Rastergitter ueber die Objekte druebermalen oder dahinter
// Hilfslinien der Seiten malen oder nicht
// Hilfslinie ueber die Objekte druebermalen oder dahinter
// Konnektoren der objekte sichtbar oder nicht
// Wenn die View kein Invalidate() an den Fenstern durchfuehren soll, muss
// man diese beiden folgenden Methoden ueberladen und entsprechend anders
// reagieren.
// Verlassen einer betretenen Objektgruppe aller sichtbaren Seiten.
// Verlassen aller betretenen Objektgruppen aller sichtbaren Seiten.
// Feststellen, ob Leave sinnvoll ist.
// DefaultAttribute an der View: Neu erzeugte Objekte bekommen diese
// Attribute direkt nach dem Erzeugen erstmal zugewiesen.
// SwapIn (z.B. von Grafiken) asynchron durchfuehren. Also nicht
// beim Paint sofort nachladen, sondern dort das Nachladen anstossen.
// Nach Abschluss des Nachladens wird das Objekt dann angezeigt.
// Hat nur z.Zt. Wirkung, wenn SwapGraphics am Model eingeschaltet ist.
// Default=FALSE. Flag ist nicht persistent.
// Fuer PlugIn. Wird vom Paint des OLE-Obj gerufen.
// wird z.Zt. ausgewertet von SdrGrafObj, wenn in dem eine Animation steckt
// Das Unterbinden der automatischen Animation wird z.B. fuer die Dia-Show benoetigt
// Verhalten beim Starten von Animation im Paint-Handler:
// 2. Nur die Ersatzdarstellung der Animation zeichnen ( SDR_ANIMATION_DONT_ANIMATE )
// 3. Nicht starten und nichts ersatzweise ausgeben ( SDR_ANIMATION_DISABLE )
// bei bShow=sal_False wird der Browser destruiert
// Muss von App beim Scrollen usw. gerufen werden, damit ein u.U.
// aktives FormularControl mitverschoben werden kann


39 / 59 | libreoffice-4.4.0.3/include/svx/svdetc.hxx
// bereitgestellt werden, wobei pData/nLen einen SvMemoryStream beschreiben in
// dem ein SdrModel gestreamt wird an dem fuer die Zeitdauer des Streamens das
// Flag SdrModel::SetStreamingSdrModel(sal_True) gesetzt wird.
// sal_uIntPtr SdrGetExchangeFormat(); -- JP 18.01.99 - dafuer gibt es ein define
// Einen Outliner mit den engineglobalen
// Defaulteinstellungen auf dem Heap erzeugen.
// Ist pMod<>NULL, dann wird der MapMode des uebergebenen
// Models verwendet. Die resultierende Default-Fonthoehe bleibt
// jedoch dieselbe (die logische Fonthoehe wird umgerechnet).
// Globale Defaulteinstellungen fuer die DrawingEngine.
// Diese Einstellungen sollte man direkt beim Applikationsstart
// vornehmen, noch bevor andere Methoden der Engine gerufen werden.
// Default FontHeight ist 847. Die Fonthoehe wird in logischen Einheiten
// (MapUnit/MapFraction (siehe unten)) angegeben. Die Defaulteinstellung
// 847/100mm entspricht also ca. 24 Point. Verwendet man stattdessen
// beispielsweise Twips (SetMapUnit(MAP_TWIP)) (20 Twip = 1 Point) muss
// man als Fonthoehe 480 angeben um 24 Point als default zu erhalten.
// Der MapMode wird fuer den globalen Outliner benoetigt.
// Gleichzeitig bekommt auch jedes neu instanziierte SdrModel
// diesen MapMode default zugewiesen.
// Einen Outliner mit den engineglobalen
// Defaulteinstellungen auf dem Heap erzeugen.
// Ist pMod<>NULL, dann wird der MapMode des uebergebenen
// Models verwendet. Die resultierende Default-Fonthoehe bleibt
// jedoch dieselbe (die logische Fonthoehe wird umgerechnet).
// Liefert eine Ersatzdarstellung fuer einen XFillStyle
// Bei XFILL_NONE gibt's sal_False und rCol bleibt unveraendert.
// Ein ItemSet auf Outliner- bzw. EditEngine-Items durchsuchen
// Liefert sal_True, wenn der Set solchen Items enthaelt.
// zurueck erhaelt man einen neuen WhichTable den
// man dann irgendwann mit delete platthauen muss.
// Hilfsklasse zur kommunikation zwischen dem Dialog
// zum aufbrechen von Metafiles (sd/source/ui/dlg/brkdlg.cxx),
// Summe aller bearbeiteten Actions
// Anzahl der Actions im akt. Obj.
// Anzahl bearbeiteter Act. im akt. Obj.
// Anzahl einzufuegender Act. im akt. Obj.
// Anzahl bereits eingefuegter Actions
// Anzahl der selektierten Objekte


3 / 9 | libreoffice-4.4.0.3/include/svx/svdhlpln.hxx
/* Tatsaechliche Groesse= PIXELSIZE*2+1 */
// je nach Wert von eKind ist X oder Y evtl. belanglos
// OutputDevice wird benoetigt, da Fangpunkte eine feste Pixelgroesse haben


1 / 7 | libreoffice-4.4.0.3/include/svx/camera3d.hxx
// Bank angle links/rechts


32 / 41 | libreoffice-4.4.0.3/include/svx/svdxcgv.hxx
// liefert True, wenn rPt geaendert wurde
// Alle markierten Objekte auf dem angegebenen OutputDevice ausgeben.
// Alle markierten Objekte in ein Metafile stecken. Z.Zt. noch etwas
// Objektkopien (SdrVirtObj) mit Ankerpos<>(0,0)).
// Alle markierten Objekte auf eine Bitmap malen. Diese hat die Farbtiefe
// und Aufloesung des Bildschirms.
// Alle markierten Objekte in ein neues Model kopieren. Dieses neue Model
// hat dann genau eine Page. Das Flag PageNotValid an diesem Model ist
// gesetzt. Daran ist zu erkennen, dass nur die Objekte der Page Gueltikeit
// haben, die Page sebst jedoch nicht (Seitengroesse, Raender). Das neue
// Model wird auf dem Heap erzeugt und wird an den Aufrufer dieser Methode
// uebergeben. Dieser hat es dann spaeter zu entsorgen.
// Beim einfuegen der markierten Objekte in die eine Page des neuen Model
// findet ein Merging der seitenlokalen Layer statt. Sollte kein Platz mehr
// fuer weitere seitenlokale Layer sein, wird den entsprechenden Objekten
// der Default-Layer zugewiesen (Layer 0, (dokumentglobaler Standardlayer).
// Bei allen Paste-Methoden werden die neuen Draw-Objekte markiert.
// Wird der Parameter bAddMark auf sal_True gesetzt, so werden die neuen
// DrawObjekte zu einer bereits bestehenden Selektion "hinzumarkiert".
// Dieser Fall ist fuer Drag&Drop mit mehreren Items gedacht.
// Die Methoden mit Point-Parameter fuegen neue Objekte zentriert an
// dieser Position ein, die anderen zentriert am 1.OutputDevice der View.
// Ist der Parameter pPg gesetzt, werden die Objekte and dieser Seite
// eingefuegt. Die Positionierung (rPos bzw. Zentrierung) bezieht sich
// dann nichtmehr auf die View sondern auf die Page.
// Hinweis: SdrObjList ist Basisklasse von SdrPage.
// Die Methoden liefern sal_True, wenn die Objekte erfolgreich erzeugt und
// eingefuegt wurden. Bei pLst=sal_False und kein TextEdit aktiv kann man
// sich dann auch darauf verlassen, dass diese an der View markiert sind.
// Andernfalls erfolgt die Markierung nur, wenn pLst z.Zt. auch an der
// View angezeigt wird.
// Gueltige Werte fuer nOptions sind SDRINSERT_DONTMARK und


70 / 403 | libreoffice-4.4.0.3/include/svx/svdobj.hxx
// Natuerlicher kubischer Spline          (ni)
// Periodischer kubischer Spline          (ni)
// Texterweiterungsrahmen                 (ni)
// FitToSize-Text (alle Zeilen gleich)
// FitToSize-Text (Zeilenweise)           (ni)
// Verbindungsobjekt fuer Konnektoren
// Polygon/PolyPolygon dargestellt durch SdrPathObj
// Polyline dargestellt durch SdrPathObj
// if false, Kein verzerren (bei Crook) moeglich (nur true bei PathObj und Gruppierten PathObjs)
// Diese 3 Methoden muss ein abgeleitetes Objekt ueberladen, wenn es eigene
// geometrische Daten besitzt, die fuer den Undo-Fall gesichert werden
// sollen. NewGeoData() erzeugt lediglich eine leere Instanz auf eine von
// SdrObjGeoData abgeleitete Klasse.
// Ueber die Objekt-Ordnungsnummer kann man feststellen, ob ein Objekt vor
// oder hinter einem anderen liegt. Objekte mit kleinen Ordnungsnummern werden
// zuerst gezeichnet, Objekte mit grossen Ordnungsnummern zuletzt.
// Wird die Reihenfolge der Objekte in der Liste veraendert, so wird ein
// Dirty-Flag gesetzt (an der Page). Beim naechsten SdrObject::GetOrdNum()
// werden die Ordnungsnummer aller Objekte der Liste neu bestimmt.
// Das Xor-Polygon wird von der View zu Draggen des Objektes benoetigt.
// Alle Polygone innerhalb des tools::PolyPolygon werden als PolyLine interpretiert.
// Moechte man ein geschlossenes Polygon, so muss man es explizit schliessen.
// Die Kontur fuer TextToContour
// Ueber GetHdlCount gibt ein Objekt die Anzahl seiner Handles preis.
// Im Normalfall werden dies 8 sein, bei einer Strecke 2. Bei Polygonobjekten
// (Polygon,Spline,Bezier) kann die Handleanzahl wesentlich groesser werden.
// Polygonobjekten wird ausserdem die Moeglichkeit eingeraeumt einen Punkt
// eines selektierten Objekts zu selektieren. Das Handle dieses Punktes wird
// dann durch einen Satz neuer Handles ausgetauscht (PlusHdl). Bei einem
// Polygon wird das wohl ein einfacher Selektionshandle sein, bei einer
// Bezierkurve dagegen koennen das schon bis zu 3 Handles werden (inkl Gewichte).
// GetHdl() und GetPlusHdl() muessen Handleinstanzen mit new erzeugen!
// Ein Objekt, das bei HasSpacialDrag() true liefert muss diese Methoden
// zur Verfuegung stellen (inkl. FillHdlList).
// Die Standardtransformationen (Move,Resize,Rotate,Mirror,Shear) werden von der
// Objektspeziefisches draggen wie z.B. Eckenradius bei Rechtecken,
// Stuetzstellen bei Splines, Gewichte bei Bezierkurven und Pointer von
// Labelobjekten muss vom Objekt selbst gehandled werden. Um das Model
// Statusfrei zu halten werden die Statusdaten an der View gehalten und dem
// Objekt dann uebergeben. EndDrag liefrt im Normalfall true fuer Erfolg.
// false kann zurueckgegeben werden, wenn das Dragging das Objekt nicht
// veraendert hat, wobei dir evtl. Tatsache das die Maus nicht bewegt wurde
// bereits von der View abgefangen wird.
// Jedes Objekt muss in der Lage sein sich selbst interaktiv zu erzeugen.
// Beim MausDown wird zunaechst ein neues Objekt erzeugt und dann seine
// BegCreate()-Methode gerufen. Bei jedem MausMode wird dann MovCreate
// gerufen. BrkCreate() bedeutet, dass der User die interaktive Objekt-
// erzeugung abgebrochen hat. EndCreate() wird gerufen beim MouseUp-Event.
// Liefert EndCreate() ein true, so ist die Objekterzeugung abgeschlossen;
// das Objekt wird in die entsprechende Liste eingefuegt. Andernfalls
// (EndCreate()==false) gehe ich davon aus, dass weitere Punkte zur
// Objekterzeugung notwendig sind (Polygon,...). Der Parameter eCmd
// enthaelt die Anzahl der Mausklicks (so die App diese durchreicht).
// BckCreate() -> Letztes EndCreate() rueckgaengig machen (z.B. letzten
// Polygonpunkt wieder loeschen).
// ReturnCode: true=Weiter gehts, false=Create dadurch abgebrochen.
// damit holt man sich den Pointer, der das Createn dieses Objekts symbolisiert
// Polygon das waehrend des Erzeugens aufgezogen wird
// Die Methoden Move, Resize, Rotate, Mirror, Shear, SetSnapRect und
// SetLogicRect rufen jeweils die entsprechenden Nbc-Methoden, versenden einen
// Repaint-Broadcast und setzen den Modified-Status am Model. Abgeleitete
// Objekte sollten i.d.R. nur die Nbc-Methoden ueberladen.
// Die relative Position eines Zeichenobjektes ist die Entfernung der
// linken oberen Eche des logisch umschliessenden Rechtecks (SnapRect)
// zum Anker.
// Snap wird nicht auf dem BoundRect ausgefuehrt, sondern nach Moeglichkeit auf
// logischen Koordinaten (also ohne Beruecksichtigung von Strichstaerke, ... ).
// SetSnapRect() versucht das Objekt so hinzusizen, dass es in das uebergebene
// Rect passt (ohne Strichstaerke, ...)
// Zum Fangen von/auf ausgezeichneten Punkten eines Obj (Polygonpunkte,


2 / 82 | libreoffice-4.4.0.3/include/svx/fmsrcimp.hxx
// Levenshtein search
// Levenshtein search


3 / 10 | libreoffice-4.4.0.3/include/svx/svdogrp.hxx
//   Vorausdeklarationen
// Referenzpunkt innerhalb der Objektgruppe
// Ist ein RefPoint gesetzt?


1 / 21 | libreoffice-4.4.0.3/include/svx/svdmark.hxx
// Es werden saemtliche Entries kopiert!


34 / 104 | libreoffice-4.4.0.3/include/svx/svdview.hxx
//  Klassenhierarchie der View:
// Dieses Markieren bei SdrBeginTextEdit
// auch fuer EndInsPoint
// TextEdit laeuft zur Zeit
// nEventKind ist SDRMOUSEBUTTONDOWN, SDRMOUSEMOVE oder SDRMOUSEBUTTONUP
// Default sind alle Dispatcher aktiviert. Will die App z.B. fuer
// Sonderbehandlungen im MouseDispatcher eingreifen, so muss sie
// den erweiterten MouseDispather mit unten stehender Methode deaktivieren
// und selbst nachimplementieren. Beispiel fuer MouseButtonDown:
//      ... hier Applikationsspezifischer Eingriff ...
// Das OutputDevice ist notwendig, damit ich die HandleSize ermitteln kann.
// Bei NULL wird das 1. angemeldete Win verwendet.
// Die Methoden beruecksichtigen den jeweiligen Kontex:
// - Einfaches Zeichnen
// - Punktbearbeitungs-Mode
// Markieren von Objekten, Polygonpunkten oder Klebepunkten (je nach View-
// Kontext) durch Aufziehen eines Selektionsrahmens.
//   bAddMark=TRUE: zur bestehenden Selektion hinzumarkieren (->Shift)
//   bUnmark=TRUE: Bereits selektierte Objekte/Punkte/Klebepunkte die innerhalb
//                 des aufgezogenen Rahmens liegen werden deselektiert.
// Folgende Actions sind moeglich:
// und mehr...
// Die App macht sich zunaechst ein SdrModel.
// Anschliessend oeffnet sie ein Win und erzeugt dann eine SdrView.
// An der SdrView meldet sie dann mit der Methode ShowSdrPage() eine Seite an.
// Eine SdrView kann in beliebig vielen Fenstern gleichzeitig angezeigt werden.
// Eine SdrView kann beliebig viele Seiten gleichzeitig anzeigen. Seiten
// werden an- und abgemeldet mit ShowSdrPage()/HideSdrPage(). Fuer jede angemeldete
// Seite wird eine SdrPageView-Instanz im Container aPages angelegt. Bei
// gleichzeitiger Anzeige mehrerer Seiten ist darauf zu achten, dass der Offset-
// Parameter von ShowSdrPage() der Seitengroesse angepasst ist, da sich sonst die
// Seiten ueberlappen koennten.
//   Einfache Events:
//   Exchange (Clipboard derzeit noch ohne SdrPrivateData):


1 / 12 | libreoffice-4.4.0.3/include/svx/tabline.hxx
// auch in tab_area.hxx (mitpflegen !!!)


120 / 152 | libreoffice-4.4.0.3/include/svx/svdedtv.hxx
/* Obj wird nicht markiert (aktuelle Markierung bleibt bestehen) */
/* Das Obj wird zu einer ggf. bereits bestehenden Selektion hinzumarkiert */
/* Die aktuellen Attribute (+StyleSheet) werden dem Obj zugewiesen */
/* Der aktuelle Layer wird dem Obj zugewiesen */
/* Einfuegen mit NbcInsertObject() fuer SolidDragging */
// Die Transformationsnachfragen, etc. etwas cachen
// Es ist mehr als ein Objekt nicht verschiebbar
// Es ist mehr als ein Objekt nicht verschieb- und drehbar (Crook)
// Alles Polygone (nicht gruppiert)
// Mindestens 1 Polygon (nicht gruppiert)
// Z-Order von virtuellen Objekten zusammenhalten (Writer)
// Konvertierung der markierten Objekte in Poly bzw. Bezier.
// Konvertiert ein Obj, wirft bei Erfolg das alte as seiner Liste und
// fuegt das neue an dessen Position ein. Inkl Undo. Es wird weder ein
// MarkEntry noch ein ModelChgBroadcast generiert.
// Setzen der beiden Flags bToTopPossible und bToBtmPossible.
// bToTopPossibleDirty und bToBtmPossibleDirty werden dabei gleichzeitig
// zurueckgesetzt.
// Entfernt alle Obj der MarkList aus ihren ObjLists inkl Undo.
// Die Eintraege in rMark bleiben erhalten.
// Die Transformationsnachfragen etwas cachen
// Checken, was man so mit den markierten Objekten alles machen kann
// Jeder Aufruf einer undofaehigen Methode an der View generiert eine
// UndoAction. Moechte man mehrere
// Methodenaufrufe zu einer UndoAction zusammenfassen, so kann man diese
// mit BegUndo() / EndUndo() klammern (beliebig tief). Als Kommentar der
// UndoAction wird der des ersten BegUndo(String) aller Klammerungen
// verwendet. NotifyNewUndoAction() wird in diesem Fall erst beim letzten
// EndUndo() gerufen. NotifyNewUndoAction() wird nicht gerufen bei einer
// leeren Klammerung.
// Undo-Klammerung auf
// Undo-Klammerung auf
// Undo-Klammerung auf
// Undo-Klammerung zu (inkl BroadcastEdges)
// Action hinzufuegen
// nur nach dem 1. BegUndo oder vor dem letzten EndUndo:
// Layerverwaltung. Mit Undo.
// Loeschen eines Layer inkl. aller darauf befindlichen Objekte
// Verschieben eines Layer (Layerreihenfolge aendern)
// Markierte Objekte die ausserhalb ihrer Page liegen
// werden ggf. einer anderen Page zugewiesen
// Loeschen aller markierten Objekte
// Logisch- umschliessendes Rect aller markierten Objekte setzen.
// Das das wirklich geschieht ist nicht garantiert, denn eine
// waagerechte Linie hat z.B. immer eine Hoehe von 0.
// Markierte Objekte kopieren und anstelle der alten markieren
// Vereinigen mehrerer Objekte zu einem PolyPolygon:
// - Polylines werden automatisch geschlossen.
// - Die Attribute und der Layer werden vom Ersten der markierten Objekte
//   uebernommen (also vom untersten der Z-Order).
// - Gruppenobjekte werden miteinbezogen, wenn alle! Memberobjekte der
//   Gruppe wandelbar sind. Beinhaltet eine Gruppe also beispielsweise
//   eine Bitmap oder ein OLE-Objekt, wird die gesamte Gruppe nicht
//   beruecksichtigt.
// bNoPolyPoly=TRUE: Alles wird zu einem einzigen Polygon zusammengefasst
// Markierte Polypolygonobjekte in Polygone zerlegen
// Gruppenobjekte werden durchsucht und zerlegt, wenn es sich bei allen
// Memberobjekten um PathObjs handelt.
// bMakeLines=TRUE: alle Polygone werden in einzelne Linien bzw.
// Ein neues bereits fertig konstruiertes Obj einfuegen. Das Obj gehoert
// anschliessend dem Model. Nach dem Einfuegen wird das neue Objekt
// markiert (wenn dies nicht via nOptions unterbunden wird).
// U.U. wird das Obj jedoch nicht eingefuegt, sondern deleted, naemlich
// wenn der Ziel-Layer gesperrt oder nicht sichtbar ist. In diesem Fall
// returniert die Methode mit FALSE.
// Die Methode generiert u.a. auch eine Undo-Action.
// Ein Zeichenobjekt durch ein neues ersetzen. *pNewObj gehoert
// anschliessend mir, *pOldObj wandert ins Undo.
// Sollte in jedem Fall mit einer Undo-Klammerung versehen werden, z.B.:
// Bei der Position wird ein evtl. gesetzter PageOrigin beruecksichtigt.
// - kein StyleSheet an den markierten Objekten gesetzt
// - Bei Mehrfachselektion die markierten Objekte auf unterschiedliche
//   StyleSheets verweisen.
// Alle markierten Objekte zu einer Gruppe zusammenfassen.
// Anschliessend wird die neue Gruppe markiert. Bei einer
// seitenuebergreifenden Markierung wird eine Gruppe je Seite erzeugt.
// Alle erzeugten Gruppen sind anschliessend markiert.
// Ueber pUserGrp kann ein eigenes Gruppenobjekt vorgegeben werden. Dieses
// wird  jedoch nicht direkt verwendet, sondern via Clone kopiert.
// Wird NULL uebergeben, macht sich die Methode SdrObjGroup-Instanzen.
// Alle markierten Objektgruppen werden aufgeloesst (1 Level).
// Anschliessend sind statt der Gruppenobjekte alle ehemaligen
// Memberobjekte der aufgeloesten Gruppen markiert. Waren zum auch Objekte
// markiert, die keine Gruppenobjekte sind, so bleiben diese weiterhin
// zusaetzlich markiert.
// Markierte Objekte in Polygone/Bezierkurven verwandeln. Die bool-
// Funktionen returnen sal_True, wenn wenigstens eins der markierten
// Objekte gewandelt werden kann. Memberobjekte von Gruppenobjekten
// werden ebenfalls gewandelt. Naehere Beschreibung siehe SdrObj.HXX.
// Alle markierten Objekte untereinander ausrichten. Normalerweise werden
// das SnapRect der Obj verwendet. Ist bBoundRects=sal_True, werden stattdessen
// die BoundRects ausgerichtet.
// Markierte Objekte etwas nach "oben" holen
// Markierte Objekte etwas nach "unten" holen
// Markierte Objekte ganz nach "oben" stellen
// Markierte Objekte ganz nach "unten" stellen
// Markierte direkt vor das uebergebene Objekt stellen
// Markierte direkt hinter das uebergebene Objekt stellen
// Z-Order der markierten Objekte vertauschen
// Feststellen, ob nach vorn/hinten stellen moeglich ist
// GetMaxToTop/BtmObj() wird von diesen Methoden nur begrenzt
// beruecksichtigt, d.h. es kann vorkommen dass IsToTopPossible()
// sal_True liefert, MovMarkedToTop() jedoch nichts aendert (z.B. bei
// Mehrfachselektion), weil eine von der abgeleiteten View ueber
// GetMaxToTopObj() auferlegte Restriktion dies verhindert.
// Ueber diese Methoden stellt die View fest, wie weit ein Objekt
// nach vorn bzw. nach hinten gestellt werden darf (Z-Order). Das
// zurueckgegebene Objekt wird dann nicht "ueberholt". Bei Rueckgabe
// von NULL (Defaultverhalten) bestehen keine Restriktionen.
// Folgende Methode wird gerufen, wenn z.B. durch ToTop, ToBtm, ... die
// Reihenfolgen der Objekte geaendert wurde. Der Aufruf erfolgt dann nach
// Falls ein oder mehrere Objekte des Types SdrGrafObj oder SdrOle2Obj
// markiert sind und diese in der Lage sind ein StarView-Metafile zu
// liefern, konvertiert diese Methode das Metafile in Drawingobjekte.
// Die SdrGrafObjs/SdrOle2Objs werden dann durch die neue Objekte ersetzt.
// Wird der Modus VirtualObjectBundling eingeschaltet, werden beim
// ToTop/ToBtm virtuelle Objekte die dasselbe Objekt referenzieren
// in ihrer Z-Order buendig zusammengehalten (Writer).
// Defaulteinstellung ist sal_False=ausgeschaltet.
// von der SdrMarkView ueberladen fuer den internen gebrauch


3 / 435 | libreoffice-4.4.0.3/include/svx/svddef.hxx
//     V2 Range = 1000..1123 (124) (58 neue Whiches)
//     V3 Range = 1000..1140 (141) (17 neue Whiches)
//     V4 Range = 1000..1185 (186) (45 neue Whiches)


26 / 50 | libreoffice-4.4.0.3/include/svx/svdpagv.hxx
// wird
// von
// Menge der sichtbaren Layer
// Menge der nicht editierbaren Layer
// Menge der druckbaren Layer
// Aktuelle Liste, in der Regel die Page.
// Aktuelle Gruppe. NULL=Keine.
// Hilfslinien und -punkte
// Nachsehen, ob AktGroup noch Inserted ist.
// Wird von der PaintView gerufen, wenn Modelaenderungen abgeschlossen sind
// Invalidiert den gesamten Bereich der Page
// rReg bezieht sich auf's OutDev, nicht auf die Page
// Betretene Liste rausreichen
// Betretene Gruppe rausreichen
// Betretene Gruppe und Liste setzen
// PV stellt eine RefPage oder eine SubList eines RefObj dar oder Model ist ReadOnly
// der Origin bezieht sich immer auf die obere linke Ecke der Page
// Liefert sal_True, wenn Layer des Obj sichtbar und nicht gesperrt.
// Beim Gruppenobjekt muss wenigstens ein Member sichtbar sein,
// gesperrt sein darf keiner.
// Betreten (Editieren) einer Objektgruppe. Anschliessend liegen alle
// Memberobjekte der Gruppe im direkten Zugriff. Alle anderen Objekte
// koennen waerendessen nicht bearbeitet werden (bis zum naechsten
// Verlassen einer betretenen Objektgruppe. (wie MsDos chdir ..)
// Verlassen aller betretenen Objektgruppen. (wie MsDos chdir \)
// Feststellen, wie weit hinabgestiegen wurde (0=Root(Page))


2 / 8 | libreoffice-4.4.0.3/include/svx/tabarea.hxx
// kann um weitere Modelle, z.B. HSV erweitert werden
// auch in tab_line.hxx (mitpflegen !!!)


4 / 7 | libreoffice-4.4.0.3/include/svx/sxmtritm.hxx
// Den Text quer zur Masslinie (90deg Drehung nach links)
// Das von mir berechnete TextRect um 180 deg drehen
// Der Text wird dann aber auch auf die andere Seite der
// Masslinie gebracht (wenn nicht Rota90)


1 / 23 | libreoffice-4.4.0.3/include/svx/float3d.hxx
// nach oben (private)


1 / 111 | libreoffice-4.4.0.3/include/svx/gridctrl.hxx
//  zusaetzliche Controls


4 / 13 | libreoffice-4.4.0.3/include/svx/svdovirt.hxx
// Achtung! Das virtuelle Objekt ist noch nicht bis in alle Feinheiten
// durchprogrammiert und getestet. Z.Zt. kommt es nur in abgeleiteter
// beim Writer zum Einsatz.
// Referenziertes Zeichenobjekt


3 / 10 | libreoffice-4.4.0.3/include/svx/sxcaitm.hxx
// sal_True=Winkel durch SdrCaptionAngleItem vorgegeben
// Nur bei Type2, Type3 und Type4
// und nur wenn SdrCaptionIsFixedAngleItem=TRUE


7 / 224 | libreoffice-4.4.0.3/include/svx/svdmodel.hxx
//   MAP_POINT,    Fraction(72,1)    : 1 log Einh = 72 Point   = 1 Inch
//   MAP_POINT,    Fraction(1,20)    : 1 log Einh = 1/20 Point = 1 Twip
//   MAP_TWIP,     Fraction(1,1)     : 1 log Einh = 1 Twip
//   MAP_100TH_MM, Fraction(1,10)    : 1 log Einh = 1/1000mm
//   MAP_MM,       Fraction(1000,1)  : 1 log Einh = 1000mm     = 1m
//   MAP_CM,       Fraction(100,1)   : 1 log Einh = 100cm      = 1m
//   MAP_CM,       Fraction(100000,1): 1 log Einh = 100000cm   = 1km


1 / 4 | libreoffice-4.4.0.3/include/svx/xlnasit.hxx
/*************************************************************************
|*
|* SetItem mit dem ItemSet aller Linienattribute
|*
\************************************************************************/


5 / 11 | libreoffice-4.4.0.3/include/svx/sxcllitm.hxx
// Laenge der ersten Austrittslinie
// Nur bei Type3 und Type4
// Laenge der ersten Austrittslinie automatisch berechnen oder
// Vorgabe (SdrCaptionLineLenItem) verwenden.
// Nur bei Type3 und Type4


5 / 581 | libreoffice-4.4.0.3/include/svx/msdffdef.hxx
// entsprechende BitFlags
// long dash style
// dash short dash
// long dash short dash
// long dash short dash short dash


5 / 26 | libreoffice-4.4.0.3/include/svx/svdograf.hxx
// Werte vom Pool kopieren
// Wenn es sich um einen Link handelt, steht hier der Dateiname drin.
// Zur Beschleunigung von Bitmapausgaben, besonders von gedrehten.
// Und hier noch ein Pointer fuer gelinkte Grafiken
// True bedeutet, die Grafik ist horizontal, d.h. ueber die Y-Achse gespiegelt auszugeben.


8 / 18 | libreoffice-4.4.0.3/include/svx/sxcecitm.hxx
// Relativer Linienaustritt
//     0 =   0.00% = oben bzw. links,
// 10000 = 100.00% = rechts bzw. unten
// nur wenn SdrCaptionEscIsRelItem=TRUE
// Absoluter Linienaustritt
// 0  = oben bzw. links,
// >0 = in Richtung rechts bzw. unten
// nur wenn SdrCaptionEscIsRelItem=FALSE


1 / 4 | libreoffice-4.4.0.3/include/svx/xflasit.hxx
/*************************************************************************
|*
|* SetItem mit dem ItemSet aller Fuellattribute
|*
\************************************************************************/


2 / 12 | libreoffice-4.4.0.3/include/svx/svdouno.hxx
//   Vorausdeklarationen
// kann auch von aussen gesetzt werden


85 / 118 | libreoffice-4.4.0.3/include/svx/svddrgv.hxx
// Automatische Konnektorgenerierung an den Scheitelpunkten
// Automatische Konnektorgenerierung an den Eckpunkten
// TakeDragObjAnchorPos() liefert die Position an der ein Objekt
// beim Draggen einer Einfachselektion ungefaehr landet wenn es
// "losgelassen" wird (EndDrag).
// In der Regel ist das die linke obere Ecke des zu erwartenden neuen
// SnapRects. Ausnahme: CaptionObj. Dort ist es die Position des
// "Schwanzendes".
// Bei Returncode sal_False konnte ich die Position nicht bestimmen
// (z.B. Punktverschiebung, Mehrfachselektion, Schieben der
// Spiegelschse, ...)
// Wird pForcedMeth uebergeben, so wird pHdl, ... nicht ausgewerten, sondern diese
// Drag-Methode verwendet. Die Instanz geht dabei ins Eigentum der View ueber und
// wird zum Ende des Draggings destruiert.
// Wer das beim BegDrag oder mittendrin schon festlegen will.
// (Wird bei jedem BegDrag auf sal_False zurueckgesetzt, also nach
// BegDrag setzen.)
// Interaktives einfuegen eines neuen Punktes. nIdx=0 => vor dem ersten Punkt.
// Fuer die App zum Verwalten des Status. GetPreferredPointer() wird
// spaeter vielleicht einen passenden Pointer dafuer liefern
// Fuer die App zum Verwalten des Status. GetPreferredPointer() wird
// spaeter vielleicht einen passenden Pointer dafuer liefern
// Begrenzungslinien ueber's gesamte Win waehrend des Draggens
// Handles waehrend des Draggens verstecken
// Beim Draggen von Polygonpunkten und Klebepunkten
// die Maus verstecken. Default=FALSE
// Beim Draggen werden i.d.R. die Konturen der markierten Objekte
// als Xor-Polygone dargestellt. Wird dieses Flag hier gesetzt,
// wird (z.B. bei Mehrfachselektion) nur ein Xor-Frame gezeichnet.
// hat diese Einstellung keine Auswirkung.
// Auch waerend des Draggens umschaltbar.
// Uebersteigt die Anzahl der markierten Objekte den hier eingestellten
// Wert, wird implizit (temporaer) auf NoDragPolys geschaltet.
// PolyPolygone etc werden entsprechend als mehrere Objekte gewertet.
// Wie DragXorPolyLimit, jedoch bezogen auf die Gesamtpunktanzahl
// Auf NoDragPolys wird (temporaer) geschaltet, wenn eins der Limits
// ueberstiegen wird.
// Dragging/Creating von Verbindern:
// Verbinder an Objektscheitelpunkte ankleben
// Verbinder an Objektecken ankleben
// Dragging von verbundenen Objekten (Nodes):
// DetailedEdgeDraggingLimit: Wie RubberEdgeDraggingLimit, jedoch bezieht
// sich dieses Limit auf die detalierte Darstellung, d.h. nicht nur
// Gummibaender sondern komplette Neuberechnunen sind beim Draggen sichtbar.
// Diese detalierte Darstellung ist eh nur beim MoveDrag moeglich.
// EdgeDraggingLimit: Sind mehr als nEdgeObjAnz Kanten betroffen, werden
// diese beim interaktiven Draggen nicht mit angezeigt.
// Gemeint sind hier die "Gummibaender", die weniger Rechenzeit benoetigen
// als die kompletten Neuberechnungen beim DetailedEdgeDragging.
// Verbinderhandling also zu deutsch wie folgt (bei Defaulteinstellungen):
// - Sind bis max 10 Verbinder betroffen werden diese bei jedem
// - Sind zwischen 11 und 100 Verbinder betroffen werden die
//   Verbindungen beim Draggen als gerade Linien dargestellt.
// - Bei mehr als 100 betroffenen Verbindern wird beim Draggen nichts
//   mehr gezeichnet was auf Verbinder hinweist.
// Ist ein spezieller Dragmode eingeschaltet, wie Rotate, Mirror oder Crook,
// dann leitet ein Hit auf das markierte Objekt genau dieses Dragging ein.
// Setzt man MarkedHitMovesAlways auf sal_True, so leitet ein Hit auf das
// markierte Objekt immer ein Moven ein, unabhaengig vom gesetzten DragMode.
// Dieses Flag ist persistent und sollte von der App fuer den Anwender
// konfigurierbar sein!
// Beim Draggen der Spiegelachse das Spiegelbild der markierten Objekte
// als Xor darstellen? Persistent. Noch nicht implementiert. Default TRUE.
// Beim Resize die Mitte als Referenz
// Symmetrisches Crook
// Begrenzung des Arbeitsbereichs. Die Begrenzung bezieht sich auf die
// View, nicht auf die einzelnen PageViews. Von der View wird diese
// Begrenzung nur bei Interaktionen wie Dragging und Create ausgewertet.
// Bei von der App algorithmisch oder UI-gesteuerte Aktionen (SetGeoAttr,
// MoveMarkedObj, ...) muss die App dieses Limit selbst beruecksichtigen.
// Ferner ist dieses Limit als Grob-Limit zu sehen. U.U. koennen Objekte
// (z.B. beim Drehen) nicht exakt bis an dieses Limit herangedraggt werden,
// koennen Objekte durch Rundungsfehler doch etwas ueberstehen, ... .
// Default=EmptyRect=keine Begrenzung.
// erst z.T. impl.
// Das DragLimit ist bezogen auf die Page des Objekts.
// (Oder auf die View??? Muss ich mal^^^^recherchieren. Joe.)
// Das Rueckgabe-Rect muss absolute Koordinaten enthalten. Der Maximale
// Dragbereich wird von der View dann so gewaehlt, dass das SnapRect des
// Objekts bis Maximal auf die Kante des LimitRects gemoved bzw. gesized
// wird. Bei Objekten wie Bezierkurven, gedrehten Rechtecken ist zu beachten
// das durch anschliessende Neuberechnung des SnapRects (bei Resize)
// Rundungsfehler auftreten koennen, wodurch das LimitRect minnimal
// ueberschritten werden koennte...
// Implementiert fuer Move und Resize.


1 / 4 | libreoffice-4.4.0.3/include/svx/xgrscit.hxx
/*************************************************************************
|*
|* GradientenSchritte-Item fuer Gradienten-Fuellungen
|*
\************************************************************************/


2 / 35 | libreoffice-4.4.0.3/include/svx/svdotable.hxx
// Gleichzeitig wird der Text in den Outliner gesetzt (ggf.
// der des EditOutliners) und die PaperSize gesetzt.


25 / 53 | libreoffice-4.4.0.3/include/svx/svdtypes.hxx
// Naechster Polygonpunkt, Kreissegment: Naechste Koordinate
// Naechstes Polygon im PolyPolygon
// Ende erzwungen
// Verschieben
// Freies verzerren (Rect in beliebiges Viereck transformieren)
// reines Polygon erzeugen
// Bei der Identifikation eines Layer kann es vorkommen, das dieser nicht
// vorhanden ist. SdrLayerAdmin::GetLayerID(const String&) liefert
// dann diesen Wert:
// Man kann diesen Wert jodoch ohne Bedenken den Methoden des SdrLayerSet
// zuwerfen, bekommt dann jedoch immer sal_False, bzw. tut die Methode nix.
// Unbekannt
// reine Objektlisten:
// Objektliste eines Gruppenobjekts
// Liste ist die Liste der virtuellen Objekte
// Liste ist die Symboltabelle
// Hier haben zur Not noch 12 weitere Listentypen Platz
// Liste ist eine Zeichenseite
// Liste ist eine Masterpage
// Hier haben zur Not noch 8 weitere Pagetypen Platz
// fuer die Surrogate reserviert
// Mit Parameter
// Faktor, Referenz(%) bezogen auf MarkRect
// Drehwinkel, Referenz(%) bezogen auf MarkRect
// Winkel,Faktor, Referenz(%) bezogen auf MarkRect


1 / 37 | libreoffice-4.4.0.3/include/svx/sdr/animation/scheduler.hxx
// scheduler class


1 / 5 | libreoffice-4.4.0.3/include/svl/itemiter.hxx
// falls es diese gibt, returne sie, sonst 0


3 / 14 | libreoffice-4.4.0.3/include/svl/macitem.hxx
//Macro Table, zerstoert die Pointer im DTor!
// loescht alle Eintraege
/*
[Beschreibung]
Dieses Item beschreibt eine Makro-Tabelle.
*/


10 / 21 | libreoffice-4.4.0.3/include/svl/srchitem.hxx
// Vorlagen-Familie
// Kommando (Suchen, Alle Suchen, Ersetzen, Alle Ersetzen)
// Calc-Spezifische Daten
// Suche in Formeln/Werten/Notizen
// Fuer welche Applikation ist der Dialog ueberhaupt
// Suchrichtung Zeilenweise/Spaltenweise
// in alle Tabellen suchen
// Writer-spezifisch
// Suche nach Vorlagen
// Suche im Inhalt


5 / 41 | libreoffice-4.4.0.3/include/svl/style.hxx
// zugehoeriger Pool
// Name der Hilfedatei
// sal_True: Set loeschen im dtor
// Default aus dem Itemset; entweder dem uebergebenen
// oder aus dem per GetItemSet() zurueckgelieferten Set


3 / 135 | libreoffice-4.4.0.3/include/svl/zformat.hxx
// Hilfsstruct fuer die restlichen Infos
// Hilfsfunktion zum Auffuellen der Vor-
// kommazahl auch mit Tausenderpunkt


7 / 12 | libreoffice-4.4.0.3/include/svl/mailenum.hxx
// Mail wurde versendet
// Mail wurde als gelesen gekennzeichnet
// Mail wurde gel"oscht
// alle Mails wurden neu eingelesen
// Sprung zur n"achsten Mail
// Sprung zur vorherigen Mail
// Textformat zum Versenden von Nachrichten ------------------------------


2 / 17 | libreoffice-4.4.0.3/include/svl/poolitem.hxx
//Uno-Konvertierung fuer Massangaben (fuer MemberId)
/*  [Beschreibung]

    Die Werte dieses Enums bezeichnen den Grad der textuellen
    Presentation eines Items nach Aufruf der virtuellen Methode
    <SfxPoolItem::GetPresentation()const>.
*/


2 / 11 | libreoffice-4.4.0.3/include/svl/numuno.hxx
// ueberladen, um Attribute im Dokument anzupassen
// ueberladen, um evtl. neu zu formatieren


1 / 4 | libreoffice-4.4.0.3/include/svl/listener.hxx
// n.i., ist verboten


2 / 6 | libreoffice-4.4.0.3/include/svl/ownlist.hxx
/*  [Beschreibung]

    Enth"alt einen String, welcher das Kommando angibt und eine weiteren
    String, der das Argument des Kommandos bildet. W"urde solch ein
    Kommando "uber die Kommandozeile angegeben werden, s"ahe es wie folgt
    aus: Kommando = Argument.
*/
/*  [Beschreibung]

    Die Liste enth"alt Objekte vom Typ SvCommand. Wird ein Objekt
    eingef"ugt, dann wird es kopiert und das neue Objekt wird
    in die Liste gestellt.
*/


2 / 84 | libreoffice-4.4.0.3/include/svl/filerec.hxx
/*  Startposition des jeweiligen
                                            Contents - nur bei DBG_UTIL
                                            und f"ur Subklassen */
//  jeweilige Anzahl der Contents


1 / 4 | libreoffice-4.4.0.3/include/svl/lstner.hxx
// n.i., ist verboten


1 / 4 | libreoffice-4.4.0.3/include/svl/urlbmk.hxx
/*  [Beschreibung]

    Diese Klasse stellt ein Bookmark dar, welches aus einer URL und
    einem dazuge"horigen Beschreibungstext besteht.

    Es gibt ein eigenes Clipboardformat und Hilfsmethoden zum Kopieren
    und Einf"ugen in und aus Clipboard und DragServer.
*/


1 / 24 | libreoffice-4.4.0.3/include/svtools/ruler.hxx
/*************************************************************************

Description
============

class Ruler

This class is used for displaying a ruler, but it can also be used
for setting or moving tabs and margins.

--------------------------------------------------------------------------

WinBits

WB_HORZ             ruler is displayed horizontally
WB_VERT             ruler is displayed vertically
WB_3DLOOK           3D look
WB_BORDER           border at the bottom/right margin
WB_EXTRAFIELD       Field in the upper left corner for
                    displaying and selecting tabs, origin of coordinates, ...
WB_RIGHT_ALIGNED    Marks the vertical ruler as right aligned

--------------------------------------------------------------------------

All ruler parameters are set in pixel units. This way double conversions
and rounding errors are avoided and the ruler displays the margins
at their actual position in the document. Because of this, the application can,
for example in tables, do its own roundings and the positions on the ruler will
still match those in the document. However, for the ruler to know how the
document is displayed on the screen, some additional values have to be configured

SetWinPos() sets the offset of the ruler's edit window. In doing so,
the width of the window can also be configured. If there is a 0 among the
values passed to the function, the position/width is automatically set to
the width of the ruler.

SetPagePos() sets the offset of the page relative to the edit window and the
width of the page. If there is a 0 among the values passed to the function,
the position/width is automatically set as if the page filled the whole edit window.

SetBorderPos() sets the offset of the border. The position is relative to
the upper/left margin of the window. This is needed when there are a horizontal
and a vertical ruler visible at the same time. Example:
        aHRuler.SetBorderPos( aVRuler.GetSizePixel().Width()-1 );

SetNullOffset() sets the origin relative to the page.

All the other values (margins, indentation, tabs, ...) refer to the origin,
which is set with SetNullOffset().

The values are computed as described below:

- WinPos (if both windows have the same parent)

    Point aHRulerPos = aHRuler.GetPosPixel();
    Point aEditWinPos = aEditWin.GetPosPixel();
    aHRuler.SetWinPos( aEditWinPos().X() - aHRulerPos.X() );

- PagePos

    Point aPagePos = aEditWin.LogicToPixel( aEditWin.GetPagePos() );
    aHRuler.SetPagePos( aPagePos().X() );

- All other values

    Add the logical values, recompute as position and subtract the
    previously saved pixel positions (of PagePos and Null Offset).

--------------------------------------------------------------------------

SetUnit() and SetZoom() configure which unit is used to display
the values on the ruler. The following units are accepted:

    FUNIT_MM
    FUNIT_CM (Default)
    FUNIT_M
    FUNIT_KM
    FUNIT_INCH
    FUNIT_FOOT
    FUNIT_MILE
    FUNIT_POINT
    FUNIT_PICA

--------------------------------------------------------------------------

SetMargin1() sets the upper/left margin and SetMargin2() sets the
bottom/right margin. If these methods are called without arguments,
no margins are displayed. Otherwise, the following arguments can be passed:

    long    nPos            - offset in pixels relative to the origin
    sal_uInt16 nStyle       - bit style:
                                RULER_MARGIN_SIZEABLE
                                margin size can be changed

                                The following bits can be set in addition
                                to these styles:
                                RULER_STYLE_INVISIBLE


SetBorders() sets an array of margins. To do this, an array of type RulerBorder
has to be passed. In the array, the following values have to be initialized:

    long    nPos            - offset in pixels relative to the origin
    long    nWidth          - column spacing in pixels (can also be 0, for example,
                              for table columns)
    sal_uInt16 nStyle       - bit style:
                                RULER_BORDER_SIZEABLE
                                Column spacing can be changed. This flag should
                                only be set if the size of the spacing is changed,
                                not that of a cell.
                                RULER_BORDER_MOVEABLE
                                Column spacing/border can be moved. Whenever
                                table borders are to be moved, this flag should
                                be set instead of SIZEABLE (SIZEABLE indicates
                                that the size of a spacing, not that of a single
                                cell can be changed).
                                RULER_BORDER_VARIABLE
                                Not all of the column spacings are equal
                                RULER_BORDER_TABLE
                                Table border. Whenever this style is set, the column
                                width must be 0.
                                RULER_BORDER_SNAP
                                Auxiliary line. Whenever this style is set, the
                                column width must be 0.
                                RULER_BORDER_MARGIN
                                Margin. Whenever this style is set, the column
                                width must be 0.

                                The following bits can be set in addition
                                to these styles:
                                RULER_STYLE_INVISIBLE

SetIndents() sets an array of indents. This method may only be used for horizontal
rulers. A Ruler Indent must be passed as an argument, with the following values
initialized:

    long    nPos            - offset relative to the origin in pixels
    sal_uInt16 nStyle       - bit style:
                                RULER_INDENT_TOP    (indent of the first line)
                                RULER_INDENT_BOTTOM (left/right indent)
                                RULER_INDENT_BORDER (Vertical line that shows the border distance)
                                The following bits can be set in addition
                                to these styles:
                                RULER_STYLE_DONTKNOW (for old position or for
                                                     ambiguity)
                                RULER_STYLE_INVISIBLE

SetTabs() sets an array of tabs. This method may only be used for horizontal rulers.
An array of type RulerTab must be passed as an argument, with the following values
initialized:

    long    nPos            - offset relative to the origin in pixels
    sal_uInt16 nStyle       - bit style:
                                RULER_TAB_DEFAULT (can't be selected)
                                RULER_TAB_LEFT
                                RULER_TAB_CENTER
                                RULER_TAB_RIGHT
                                RULER_TAB_DECIMAL
                                The following bits can be set in addition
                                to these styles:
                                RULER_STYLE_DONTKNOW (for old position of for
                                                     ambiguity)
                                RULER_STYLE_INVISIBLE

SetLines() displays position lines in the ruler. An array of type RulerLine must be passed, with
the following values initialized:

    long    nPos            - offset relative to the origin in pixels
    sal_uInt16 nStyle       - bit style (has to be 0 currently)

--------------------------------------------------------------------------

If the user should also be able to change the margins tabs, borders, ...
in the ruler, a bit more effort is necessary. In this case, the StartDrag(),
Drag() and EndDrag() methods have to be overridden. For the StartDrag() method
it is possible to prevent dragging by returning FALSE. In the drag handler,
the drag position must be queried and the values must be moved to the new
position. This is done by calling the particular Set methods. While in the
drag handler, the values are just cached and only afterward the ruler is redrawn.
All the handlers can also be set as links with the particular Set..Hdl() methods.

    - StartDrag()
        Is called when dragging is started. If FALSE is returned, the dragging.
        won't be executed. If TRUE is returned, the dragging will be permitted.
        If the handler isn't overridden, FALSE will be returned.

    - EndDrag()
        Is called at the end of dragging.

    - Drag()
        Is called when dragging takes place.

    - Click()
        This handler is called when no element has been clicked on.
        The position can be queried with GetClickPos(). This way it is possible
        to, for example, ser tabs in the ruler. After calling the click handler,
        the drag, if any, is immediately triggered. This makes it possible to
        set a new tab in the click handler and then immediately move it.

    - DoubleClick()
        This handler is called when a double-click has been performed outside
        the special panel. The methods GetClickType(), GetClickAryPos() and
        GetClickPos() can be used to query what has been clicked on.
        This way you can, for example, show the tab dialog when a double-click
        is performed on a tab.

In the drag handler it is possible to query what has been dragged and where
it has been dragged. There are the following query methods:

    - GetDragType()
        Returns what has been dragged.
            RULER_TYPE_MARGIN1
            RULER_TYPE_MARGIN2
            RULER_TYPE_BORDER
            RULER_TYPE_INDENT
            RULER_TYPE_TAB

    - GetDragPos()
        Returns the pixel position to which the user has moved the mouse
        relative to the set zero-offset.

    - GetDragAryPos()
        Liefert den Index im Array zurueck, wenn ein Border, Indent oder ein
        Tab gedragt wird. Achtung: Es wird die Array-Position waehrend des
        gesammten Drag-Vorgangs von dem Item im Array was vor dem Drag gesetzt
        war zurueckgeben. Dadurch ist es zum Beispiel auch moeglich, einen
        Tab nicht mehr anzuzeigen, wenn die Maus nach unten/rechts aus dem
        Lineal gezogen wird.

    - GetDragSize()
        Wenn Borders gedragt werden, kann hierueber abgefragt werden, ob
        die Groesse bzw. welche Seite oder die Position geaendert werden soll.
            RULER_DRAGSIZE_MOVE oder 0      - Move
            RULER_DRAGSIZE_1                - Linke/obere Kante
            RULER_DRAGSIZE_2                - Rechte/untere Kante

    - IsDragDelete()
        Mit dieser Methode kann abgefragt werden, ob beim Draggen die
        Maus unten/rechts aus dem Fenster gezogen wurde. Damit kann
        zum Beispiel festgestellt werden, ob der Benutzer einen Tab
        loeschen will.

    - IsDragCanceled()
        Mit dieser Methode kann im EndDrag-Handler abgefragt werden,
        ob die Aktion abgebrochen wurde, indem der Anwender die
        Maus oben/links vom Fenster losgelassen hat oder ESC gedrueckt
        hat. In diesem Fall werden die Werte nicht uebernommen. Wird
        waehrend des Draggings die Maus oben/links aus dem Fenster
        gezogen, werden automatisch die alten Werte dargestellt, ohne das
        der Drag-Handler gerufen wird.
        Falls der Benutzer jedoch den Wert auf die alte Position
        zurueckgeschoben hat, liefert die Methode trotzdem sal_False. Falls
        dies vermieden werden soll, muss sich die Applikation im StartDrag-
        Handler den alten Wert merken und im EndDrag-Handler den Wert
        vergleichen.

    - GetDragScroll()
        Mit dieser Methode kann abgefragt werden, ob gescrollt werden
        soll. Es wird einer der folgenden Werte zurueckgegeben:
            RULER_SCROLL_NO                 - Drag-Position befindet sich
                                              an keinem Rand und somit
                                              muss nicht gescrollt werden.
            RULER_SCROLL_1                  - Drag-Position befindet sich
                                              am linken/oberen Rand und
                                              somit sollte das Programm evt.
                                              ein Srcoll ausloesen.
            RULER_SCROLL_2                  - Drag-Position befindet sich
                                              am rechten/unteren Rand und
                                              somit sollte das Programm evt.
                                              ein Srcoll ausloesen.

    - GetDragModifier()
        Liefert die Modifier-Tasten zurueck, die beim Starten des Drag-
        Vorgangs gedrueckt waren. Siehe MouseEvent.

    - GetClickPos()
        Liefert die Pixel-Position bezogen auf den eingestellten Null-Offset
        zurueck, wo der Anwender die Maus gedrueckt hat.

    - GetClickType()
        Liefert zurueck, was per DoubleClick betaetigt wird:
            RULER_TYPE_DONTKNOW             (kein Element im Linealbereich)
            RULER_TYPE_OUTSIDE              (ausserhalb des Linealbereichs)
            RULER_TYPE_MARGIN1              (nur Margin1-Kante)
            RULER_TYPE_MARGIN2              (nur Margin2-Kante)
            RULER_TYPE_BORDER               (Border: GetClickAryPos())
            RULER_TYPE_INDENT               (Einzug: GetClickAryPos())
            RULER_TYPE_TAB                  (Tab: GetClickAryPos())

    - GetClickAryPos()
        Liefert den Index im Array zurueck, wenn ein Border, Indent oder ein
        Tab per DoubleClick betaetigt wird.

    - GetType()
        Mit dieser Methode kann man einen HitTest durchfuehren, um
        gegebenenfalls ueber das Abfangen des MouseButtonDown-Handlers
        auch ueber die rechte Maustaste etwas auf ein Item anzuwenden. Als
        Paramter ueber gibt man die Fensterposition und gegebenenfalls
        einen Pointer auf einen sal_uInt16, um die Array-Position eines
        Tabs, Indent oder Borders mitzubekommen. Als Type werden folgende
        Werte zurueckgegeben:
            RULER_TYPE_DONTKNOW             (kein Element im Linealbereich)
            RULER_TYPE_OUTSIDE              (ausserhalb des Linealbereichs)
            RULER_TYPE_MARGIN1              (nur Margin1-Kante)
            RULER_TYPE_MARGIN2              (nur Margin2-Kante)
            RULER_TYPE_BORDER               (Border: GetClickAryPos())
            RULER_TYPE_INDENT               (Einzug: GetClickAryPos())
            RULER_TYPE_TAB                  (Tab: GetClickAryPos())

Wenn der Drag-Vorgang abgebrochen werden soll, kann der Drag-Vorgang
mit CancelDrag() abgebrochen werden. Folgende Methoden gibt es fuer die
Drag-Steuerung:

    - IsDrag()
        Liefert sal_True zurueck, wenn sich das Lineal im Drag-Vorgang befindet.

    - CancelDrag()
        Bricht den Drag-Vorgang ab, falls einer durchgefuehrt wird. Dabei
        werden die alten Werte wieder hergestellt und der Drag und der
        EndDrag-Handler gerufen.

Um vom Dokument ein Drag auszuloesen, gibt es folgende Methoden:

    - StartDocDrag()
        Dieser Methode werden der MouseEvent vom Dokumentfenster und
        was gedragt werden soll uebergeben. Wenn als DragType
        RULER_TYPE_DONTKNOW uebergeben wird, bestimmt das Lineal, was
        verschoben werden soll. Bei den anderen, wird der Drag nur dann
        gestartet, wenn auch an der uebergebenen Position ein entsprechendes
        Element gefunden wurde. Dies ist zun Beispiel dann notwendig, wenn
        zum Beispiel Einzuege und Spalten an der gleichen X-Position liegen.
        Der Rueckgabewert gibt an, ob der Drag ausgeloest wurde. Wenn ein
        Drag ausgeloest wird, uebernimmt das Lineal die normale Drag-Steuerung
        und verhaelt sich dann so, wie als wenn direkt in das Lineal geklickt
        wurde. So captured das Lineal die Mouse und uebernimmt auch die
        Steuerung des Cancel (ueber Tastatur, oder wenn die Mouse ueber
        oder links vom Lineal ruasgeschoben wird). Auch alle Handler werden
        gerufen (inkl. des StartDrag-Handlers). Wenn ein MouseEvent mit
        Click-Count 2 uebergeben wird auch der DoubleClick-Handler
        entsprechend gerufen.

--------------------------------------------------------------------------

Fuer das Extra-Feld kann der Inhalt bestimmt werden und es gibt Handler,
womit man bestimmte Aktionen abfangen kann.

    - ExtraDown()
        Dieser Handler wird gerufen, wenn im Extra-Feld die Maus
        gedrueckt wird.

    - SetExtraType()
        Mit dieser Methode kann festgelegt werden, was im ExtraFeld
        dargestellt werden soll.
            - ExtraType         Was im Extrafeld dargestellt werden soll
                                RULER_EXTRA_DONTKNOW        (Nichts)
                                RULER_EXTRA_NULLOFFSET      (Koordinaaten-Kreuz)
                                RULER_EXTRA_TAB             (Tab)
            - sal_uInt16 nStyle     Bitfeld als Style:
                                    RULER_STYLE_HIGHLIGHT   (selektiert)
                                    RULER_TAB_...           (ein Tab-Style)

    - GetExtraClick()
        Liefert die Anzahl der Mausclicks zurueck. Dadurch ist es zum
        Beispiel auch moeglich, auch durch einen DoubleClick im Extrafeld
        eine Aktion auszuloesen.

    - GetExtraModifier()
        Liefert die Modifier-Tasten zurueck, die beim Klicken in das Extra-
        Feld gedrueckt waren. Siehe MouseEvent.

--------------------------------------------------------------------------

Weitere Hilfsfunktionen:

- static Ruler::DrawTab()
    Mit dieser Methode kann ein Tab auf einem OutputDevice ausgegeben
    werden. Dadurch ist es moeglich, auch in Dialogen die Tabs so
    anzuzeigen, wie Sie im Lineal gemalt werden.

    Diese Methode gibt den Tab zentriert an der uebergebenen Position
    aus. Die Groesse der Tabs kann ueber die Defines RULER_TAB_WIDTH und
    RULER_TAB_HEIGHT bestimmt werden.

--------------------------------------------------------------------------

Tips zur Benutzung des Lineals:

- Bei dem Lineal muss weder im Drag-Modus noch sonst das Setzen der Werte
  in SetUpdateMode() geklammert werden. Denn das Lineal sorgt von sich
  aus dafuer, das wenn mehrere Werte gesetzt werden, diese automatisch
  zusammengefast werden und flackerfrei ausgegeben werden.

- Initial sollten beim Lineal zuerst die Groessen, Positionen und Werte
  gesetzt werden, bevor es angezeigt wird. Dies ist deshalb wichtig, da
  ansonsten viele Werte unnoetig berechnet werden.

- Wenn das Dokumentfenster, in dem sich das Lineal befindet aktiv bzw.
  deaktiv wird, sollten die Methoden Activate() und Deactivate() vom
  Lineal gerufen werden. Denn je nach Einstellungen und System wird die
  Anzeige entsprechend umgeschaltet.

- Zum Beispiel sollte beim Drag von Tabs und Einzuegen nach Moeglichkeit die
  alten Positionen noch mit angezeigt werden. Dazu sollte zusaetzlich beim
  Setzen der Tabs und Einzuege als erstes im Array die alten Positionen
  eingetragen werden und mit dem Style RULER_STYLE_DONTKNOW verknuepft
  werden. Danach sollte im Array die restlichen Werte eingetragen werden.

- Bei mehreren markierten Absaetzen und Tabellen-Zellen, sollten die Tabs
  und Einzuege in grau von der ersten Zelle, bzw. vom ersten Absatz
  angezeigt werden. Dies kann man auch ueber den Style RULER_STYLE_DONTKNOW
  erreichen.

- Die Bemassungspfeile sollten immer dann angezeigt, wenn beim Drag die
  Alt-Taste (WW-Like) gedrueckt wird. Vielleicht sollte diese Einstellung
  auch immer vornehmbar sein und vielleicht beim Drag immer die
  Bemassungspfeile dargestellt werden. Bei allen Einstellung sollten die
  Werte immer auf ein vielfaches eines Wertes gerundet werden, da die
  Bildschirmausloesung sehr ungenau ist.

- DoppelKlicks sollten folgendermassen behandelt werden (GetClickType()):
    - RULER_TYPE_DONTKNOW
      RULER_TYPE_MARGIN1
      RULER_TYPE_MARGIN2
        Wenn die Bedingunden GetClickPos() <= GetMargin1() oder
        GetClickPos() >= GetMargin2() oder der Type gleich
        RULER_TYPE_MARGIN1 oder RULER_TYPE_MARGIN2 ist, sollte
        ein SeitenDialog angezeigt werden, wo der Focus auf dem
        entsprechenden Rand steht
    - RULER_TYPE_BORDER
        Es sollte ein Spalten- oder Tabellen-Dialog angezeigt werden,
        wo der Focus auf der entsprechenden Spalte steht, die mit
        GetClickAryPos() abgefragt werden kann.
    - RULER_TYPE_INDENT
        Es sollte der Dialog angezeigt werden, wo die Einzuege eingestellt
        werden koennen. Dabei sollte der Focus auf dem Einzug stehen, der
        mit GetClickAryPos() ermittelt werden kann.
    - RULER_TYPE_TAB
        Es sollte ein TabDialog angezeigt werden, wo der Tab selektiert
        sein sollte, der ueber GetClickAryPos() abgefragt werden kann.

*************************************************************************/


19 / 26 | libreoffice-4.4.0.3/include/svtools/imap.hxx
// Binaer laden/speichern
// Der Dtor gibt den intern belegten
// Speicher wieder frei;
// Zuweisungsoperator
// Vergleichsoperator (es wird alles auf Gleichheit geprueft)
// In die Map wird ein neues IMap-Obkekt ans Ende eingefuegt
// Zugriff auf einzelne IMapObjekte; die Objekte
// duerfen von aussen _nicht_ zerstoert werden
// Gibt das Objekt zurueck, das zuerst getroffen wurde oder NULL;
// Groessen- und Positionsangaben sind in 1/100mm;
// rTotalSize ist die Originalgroesse des Bildes;
// rDisplaySize die aktuelle Darstellungsgroesse;
// rRelPoint bezieht sich auf die Darstellungsgroesse
// und die linke oebere Ecke des Bildes
// Gibt die Gesamtanzahl der IMap-Objekte zurueck
// Loescht alle internen Objekte
// liefert die aktuelle Versionsnummer
// liefert / setzt den Namen der ImageMap
// skaliert alle Objekte der ImageMap entpr. dem uebergebenen Faktor


3 / 11 | libreoffice-4.4.0.3/include/svtools/rtfkeywd.hxx
// neue Tokens zur 1.5
// SWG spezifische Attribute
// Attribute fuer die freifliegenden Rahmen


1 / 6 | libreoffice-4.4.0.3/include/svtools/imaprect.hxx
// liefert das BoundRect des Rechteck-Objektes in 1/100mm


1 / 171 | libreoffice-4.4.0.3/include/svtools/brwbox.hxx
// neue Handler


1 / 9 | libreoffice-4.4.0.3/include/svtools/wizdlg.hxx
/*************************************************************************

Beschreibung
============

class WizardDialog

This class is the base for WizardDialog. The basic functionality is to
order the Controls. Besides it's a helper method for switching the TabPages.
The dialog orders the Controls when their size changed.

--------------------------------------------------------------------------

SetPageSizePixel() sets the biggest TabPage size. When the dialog
should be displayed, first the dialog size is calculated and set.
If there is no size set with SetPageSizePixel(), max size of the
current TabPage is set as default.

ShowPrevPage()/ShowNextPage() shows the previous/next TabPage.
First the Deactivate-Handler is called by dialog and if the return
value is sal_True the Active-Handler is called by dialog and the
corresponding TabPage is showed. Finnish() can only be called
if the Finnish-Button is activated. Then the Deactivate-Page-Handler
is called by dialog and by the current TabPage. Now the dialog ends
(Close() or EndDialog()).

Mit AddPage()/RemovePage()/SetPage() koennen die TabPages dem Wizard
bekannt gemacht werden. Es wird immer die TabPage des aktuellen Levels
angezeigt, wenn fuer den aktuellen Level keine TabPage zugewiesen
ist, wird die TabPages des hoechsten Levels angezeigt. Somit kann auch
immer die aktuelle TabPage ausgetauscht werden, wobei zu
beruecksichtigen ist, das im Activate-Handler die aktuelle TabPage
nicht zerstoert werden darf.

Mit SetPrevButton()/SetNextButton() werden der Prev-Button und der
Next-Button dem Dialog bekannt gemacht. In dem Fall loest der
Dialog bei Ctr+Tab, Shift+Ctrl+Tab den entsprechenden Click-Handler
am zugewiesenen Button aus. Die Button werden nicht vom WizardDialog
disablte. Eine entsprechende Steuerung muss der Benutzer dieses
Dialoges selber programieren.

Mit AddButton()/RemoveButton() koennen Buttons dem Wizard bekannt
gemacht werden, die in der Reihenfolge der Hinzufuegung angeordnet
werden. Die Buttons werden unabhengig von ihrem sichtbarkeitsstatus
angeordnet, so das auch spaeter ein entsprechender Button angezeigt/
gehidet werden kann. Der Offset wird in Pixeln angegeben und bezieht
sich immer auf den nachfolgenden Button. Damit der Abstand zwischen
den Buttons bei allen Dialogen gleich ist, gibt es das Define
WIZARDDIALOG_BUTTON_STDOFFSET_X, welches als Standard-Offset genommen
werden sollte.

Mit SetViewWindow() und SetViewAlign() kann ein Control gesetzt werden,
welches als Preview-Window oder fuer die Anzeige von schoenen Bitmaps
genutzt werden kann.

--------------------------------------------------------------------------

Der ActivatePage()-Handler wird gerufen, wenn eine neue TabPages
angezeigt wird. In diesem Handler kann beispielsweise die neue
TabPage erzeugt werden, wenn diese zu diesem Zeitpunkt noch nicht
erzeugt wurde. Der Handler kann auch als Link gesetzt werden. Mit
GetCurLevel() kann die aktuelle ebene abgefragt werden, wobei
Level 0 die erste Seite ist.

Der DeactivatePage()-Handler wird gerufen, wenn eine neue TabPage
angezeigt werden soll. In diesem Handler kann noch eine Fehler-
ueberprufung stattfinden und das Umschalten gegebenenfalls verhindert
werden, indem sal_False zurueckgegeben wird. Der Handler kann auch als
Link gesetzt werden. Die Defaultimplementierung ruft den Link und
gibt den Rueckgabewert des Links zurueck und wenn kein Link gesetzt
ist, wird sal_True zurueckgegeben.

--------------------------------------------------------------------------

Beispiel:

MyWizardDlg-Ctor
----------------

// add buttons
AddButton( &maHelpBtn, WIZARDDIALOG_BUTTON_STDOFFSET_X );
AddButton( &maCancelBtn, WIZARDDIALOG_BUTTON_STDOFFSET_X );
AddButton( &maPrevBtn );
AddButton( &maNextBtn, WIZARDDIALOG_BUTTON_STDOFFSET_X );
AddButton( &maFinnishBtn );
SetPrevButton( &maPrevBtn );
SetNextButton( &maNextBtn );

// SetHandler
maPrevBtn.SetClickHdl( LINK( this, MyWizardDlg, ImplPrevHdl ) );
maNextBtn.SetClickHdl( LINK( this, MyWizardDlg, ImplNextHdl ) );

// Set PreviewWindow
SetViewWindow( &maPreview );

// Call ActivatePage, because the first page should be created an activated
ActivatePage();


MyWizardDlg-ActivatePage-Handler
--------------------------------

void MyWizardDlg::ActivatePage()
{
    WizardDialog::ActivatePage();

    // Test, if Page is created already
    if ( !GetPage( GetCurLevel() ) )
    {
        // Create and add new page
        TabPage* pNewTabPage;
        switch ( GetCurLevel() )
        {
            case 0:
                pNewTabPage = CreateIntroPage();
                break;
            case 1:
                pNewTabPage = CreateSecondPage();
                break;
            case 2:
                pNewTabPage = CreateThirdPage();
                break;
            case 3:
                pNewTabPage = CreateFinnishedPage();
                break;

        }
        AddPage( pNewTabPage );
    }
}


MyWizardDlg-Prev/Next-Handler
-----------------------------

IMPL_LINK( MyWizardDlg, ImplPrevHdl, PushButton*, pBtn )
{
    ShowPrevPage();
    if ( !GetCurLevel() )
        pBtn->Disable();
    return 0;
}

IMPL_LINK( MyWizardDlg, ImplNextHdl, PushButton*, pBtn )
{
    ShowNextPage();
    if ( GetCurLevel() < 3 )
        pBtn->Disable();
    return 0;
}

*************************************************************************/


1 / 11 | libreoffice-4.4.0.3/include/svtools/headbar.hxx
/*************************************************************************

Beschreibung
============

class HeaderBar

Diese Klasse dient zur Anzeige einer Ueberschiftszeile. Diese kann Texte,
Images oder beides anzeigen. Man kann die Items in der Groesse aendern,
verschieben oder anklicken. In vielen Faellen macht es zum Beispiel Sinn,
dieses Control mit einer SvTabListBox zu verbinden.

--------------------------------------------------------------------------

WinBits

WB_BORDER           Oben und unten wird ein Border gezeichnet
WB_BOTTOMBORDER     Unten wird ein Border gezeichnet
WB_BUTTONSTYLE      Die Items sehen aus wie Buttons, ansonsten sind sie flach
WB_3DLOOK           3D-Darstellung
WB_DRAG             Items koennen verschoben werden
WB_STDHEADERBAR     WB_BUTTONSTYLE | WB_BOTTOMBORDER

--------------------------------------------------------------------------

ItemBits

HIB_LEFT            Inhalt wird im Item linksbuendig ausgegeben
HIB_CENTER          Inhalt wird im Item zentriert ausgegeben
HIB_RIGHT           Inhalt wird im Item rechtsbuendig ausgegeben
HIB_TOP             Inhalt wird im Item an der oberen Kante ausgegeben
HIB_VCENTER         Inhalt wird im Item vertikal zentiert ausgegeben
HIB_BOTTOM          Inhalt wird im Item an der unteren Kante ausgegeben
HIB_LEFTIMAGE       Bei Text und Image, wird Image links vom Text ausgegeben
HIB_RIGHTIMAGE      Bei Text und Image, wird Image rechts vom Text ausgegeben
HIB_FIXED           Item laesst sich nicht in der Groesse aendern
HIB_FIXEDPOS        Item laesst sich nicht verschieben
HIB_CLICKABLE       Item laesst sich anklicken
                    (Select-Handler wird erst bei MouseButtonUp gerufen)
HIB_FLAT            Item wird flach dargestellt, auch wenn WB_BUTTONSTYLE gesetzt ist
HIB_DOWNARROW       Es wird ein Pfeil nach unter hinter dem Text ausgegeben,
                    welcher zum Beispiel angezeigt werden sollte, wenn nach
                    diesem Item eine dazugehoerende Liste absteigend sortiert
                    ist. Der Status des Pfeils kann mit SetItemBits()
                    gesetzt/zurueckgesetzt werden.
HIB_UPARROW         Es wird ein Pfeil nach oben hinter dem Text ausgegeben,
                    welcher zum Beispiel angezeigt werden sollte, wenn nach
                    diesem Item eine dazugehoerende Liste aufsteigend sortiert
                    ist.Der Status des Pfeils kann mit SetItemBits()
                    gesetzt/zurueckgesetzt werden.
HIB_USERDRAW        Zu diesem Item wird auch der UserDraw-Handler gerufen.
HIB_STDSTYLE        (HIB_LEFT | HIB_LEFTIMAGE | HIB_VCENTER | HIB_CLICKABLE)

--------------------------------------------------------------------------

Handler

Select()            Wird gerufen, wenn Item angeklickt wird. Wenn
                    HIB_CLICKABLE beim Item gesetzt ist und nicht HIB_FLAT,
                    wird der Handler erst im MouseButtonUp-Handler gerufen,
                    wenn die Maus ueber dem Item losgelassen wurde. Dann
                    verhaellt sich der Select-Handler wie bei einem
                    ToolBox-Button.
DoubleClick()       Dieser Handler wird gerufen, wenn ein Item
                    doppelt geklickt wird. Ob das Item oder der
                    Trenner angeklickt wurden, kann mit IsItemMode()
                    abgefragt werden. Wenn ein Trenner doppelt angeklickt
                    wird, sollte normalerweise die optimale Spaltenbreite
                    berechnet werden und diese gesetzt werden.
StartDrag()         Dieser Handler wird gerufen, wenn Draggen gestartet
                    wird, bzw. wenn ein Item angeklickt wurde.
                    In diesem Handler sollte spaetestens mit SetDragSize()
                    die Groesse der Size-Linie gesetzt werden, wenn
                    IsItemMode() sal_False zurueckliefert.
Drag()              Dieser Handler wird gerufen, wenn gedraggt wird. Wenn
                    mit SetDragSize() keine Groesse gesetzt wird, kann
                    dieser Handler dafuer benutzt werden, um die
                    Linie im angrenzenden Fenster selber zu zeichnen. Mit
                    GetDragPos() kann die aktuelle Drag-Position abgefragt
                    werden. Mit IsItemMode() sollte in diesem Fall
                    abgefragt werden, ob auch ein Trenner gedraggt wird.
EndDrag()           Dieser Handler wird gerufen, wenn ein Drag-Vorgang
                    beendet wurde. Wenn im EndDrag-Handler GetCurItemId()
                    0 zurueckliefert, wurde der Drag-Vorgang abgebrochen.
                    Wenn dies nicht der Fall ist und IsItemMode() sal_False
                    zurueckliefert, sollte von dem gedraggten Item
                    die neue Groesse mit GetItemSize() abgefragt werden
                    und entsprechend im dazugehoerigem Control uebernommen
                    werden. Wenn IsItemMode() sal_True, GetCurItemId() eine Id
                    und IsItemDrag() sal_True zurueckliefert, wurde dieses
                    Item verschoben. Es sollte dann mit GetItemPos() die
                    neue Position abgefragt werden und auch die Daten
                    im dazugehoerigem Control angepasst werden. Ansonsten
                    koennte auch mit GetItemDragPos() die Position abgefragt
                    werden, an welche Stelle das Item verschoben wurde.


Weitere Methoden, die fuer die Handler wichtig sind.

GetCurItemId()      Liefert die Id vom Item zurueck, fuer welches gerade
                    der Handler gerufen wurde. Liefert nur eine gueltige
                    Id in den Handlern Select(), DoubleClick(), StartDrag(),
                    Drag() und EndDrag(). Im EndDrag-Handler leifert
                    diese Methode die Id vom gedraggten Item zurueck oder
                    0, wenn der Drag-Vorgang abgebrochen wurde.
GetItemDragPos()    Liefert die Position zurueck, an der ein Item verschoben
                    wird bzw. wurde. HEADERBAR_ITEM_NOTFOUND wird
                    zurueckgeliefert, wenn der Vorgang abgebrochen wurde
                    oder wenn kein ItemDrag aktiv ist.
IsItemMode()        Mit dieser Methode kann abgefragt werden, ob fuer ein
                    Item oder einen Trenner der Handler gerufen wurde.
                    sal_True    - Handler wurde fuer das Item gerufen
                    sal_False   - Handler wurde fuer den Trenner gerufen
IsItemDrag()        Mit dieser Methode kann abgefragt werden, ob ein
                    Item gedragt oder selektiert wurde.
                    sal_True    - Item wird verschoben
                    sal_False   - Item wird selektiert
SetDragSize()       Mit dieser Methode wird gesetzt, wir gross der
                    Trennstrich sein soll, der vom Control gemalt wird.
                    Dies sollte so gross sein, wie das angrenzende Fenster
                    hoch ist. Die Hoehe vom HeaderBar wird automatisch
                    dazugerechnet.

--------------------------------------------------------------------------

Weitere Methoden

SetOffset()             Mit dieser Methode wird der Offset gesetzt, ab dem
                        die Items ausgegeben werden. Dies wird benoetigt,
                        wenn das dazugehoerige Fenster gescrollt wird.
CalcWindowSizePixel()   Mit dieser Methode kann man die Hoehe des Fensters
                        berechnen, damit der Inhalt der Items ausgegeben
                        werden kann.

--------------------------------------------------------------------------

Tips und Tricks:

1) KontextMenu
Wenn ein kontextsensitives PopupMenu anzeigt werden soll, muss der
Command-Handler ueberlagert werden. Mit GetItemId() und bei
Uebergabe der Mausposition kann ermittelt werden, ob der Mausclick
ueber einem bzw. ueber welchem Item durchgefuehrt wurde.

2) Letztes Item
Wenn man ButtonStyle gesetzt hat, sieht es besser aus, wenn man am
Ende noch ein leeres Item setzt, was den restlichen Platz einnimmt.
Dazu fuegt man ein Item mit einem leeren String ein und uebergibt als
Groesse HEADERBAR_FULLSIZE. Bei diesem Item sollte man dann auch
nicht HIB_CLICKABLE setzen und dafuer HIB_FIXEDPOS.

*************************************************************************/


1 / 6 | libreoffice-4.4.0.3/include/svtools/imapcirc.hxx
// liefert das BoundRect des Kreis-Objektes in 1/100mm


1 / 18 | libreoffice-4.4.0.3/include/svtools/tabbar.hxx
/*

Erlaubte StyleBits
------------------

WB_SCROLL       - Die Tabs koennen ueber ein Extra-Feld gescrollt werden
WB_MINSCROLL    - Die Tabs koennen ueber 2 zusaetzliche Buttons gescrollt werden
WB_RANGESELECT  - Zusammenhaengende Bereiche koennen selektiert werden
WB_MULTISELECT  - Einzelne Tabs koennen selektiert werden
WB_BORDER       - Oben und unten wird ein Strich gezeichnet
WB_TOPBORDER    - Oben wird ein Border gezeichnet
WB_3DTAB        - Die Tabs und der Border werden in 3D gezeichnet
WB_DRAG         - Vom TabBar wird ein StartDrag-Handler gerufen, wenn
                  Drag and Drop gestartet werden soll. Es wird ausserdem
                  im TabBar mit EnableDrop() Drag and Drop eingeschaltet.
WB_SIZEABLE     - Vom TabBar wird ein Split-Handler gerufen, wenn der Anwender
                  den TabBar in der Breite aendern will
WB_STDTABBAR    - WB_BORDER

Wenn man den TabBar zum Beispiel als Property-Bar benutzen moechte, sollten
die WinBits WB_TOPBORDER und WB_3DTAB anstatt WB_BORDER gesetzt werden.


Erlaubte PageBits
-----------------

TPB_SPECIAL     - Andere Darstellung des TabTextes, zum Beispiel fuer
                  Szenario-Seiten.


Handler
-------

Select          - Wird gerufen, wenn eine Tab selektiert oder
                  deselektiert wird
DoubleClick     - Wird gerufen, wenn ein DoubleClick im TabBar ausgeloest
                  wurde. Innerhalb des Handlers liefert GetCurPageId() die
                  angeklickte Tab zurueck oder 0, wenn keine Tab angeklickt
                  wurde
ActivatePage    - Wird gerufen, wenn eine andere Seite aktiviert wird.
                  GetCurPageId() gibt die aktivierte Seite zurueck.
DeactivatePage  - Wird gerufen, wenn eine Seite deaktiviert wird. Wenn
                  eine andere Seite aktiviert werden darf, muss sal_True
                  zurueckgegeben werden, wenn eine andere Seite von
                  der Aktivierung ausgeschlossen werden soll, muss
                  sal_False zurueckgegeben werden. GetCurPageId() gibt die
                  zu deaktivierende Seite zurueck.



Drag and Drop
-------------

Fuer Drag and Drop muss das WinBit WB_DRAG gesetzt werden. Ausserdem
muss der Command-, QueryDrop-Handler und der Drop-Handler ueberlagert
werden. Dabei muss in den Handlern folgendes implementiert werden:

Command         - Wenn in diesem Handler das Dragging gestartet werden
                  soll, muss StartDrag() gerufen werden. Diese Methode
                  selektiert dann den entsprechenden Eintrag oder gibt
                  sal_False zurueck, wenn das Dragging nicht durchgefuhert
                  werden kann.

QueryDrop       - Dieser Handler wird von StarView immer dann gerufen, wenn
                  bei einem Drag-Vorgang die Maus ueber das Fenster gezogen
                  wird (siehe dazu auch SV-Doku). In diesem Handler muss
                  festgestellt werden, ob ein Drop moeglich ist. Die
                  Drop-Position kann im TabBar mit ShowDropPos() angezeigt
                  werden. Beim Aufruf muss die Position vom Event uebergeben
                  werden. Wenn sich die Position am linken oder rechten
                  Rand befindet, wird automatisch im TabBar gescrollt.
                  Diese Methode gibt auch die entsprechende Drop-Position
                  zurueck, die auch fuer ein Drop gebraucht wird. Wenn das
                  Fenster beim Drag verlassen wird, kann mit HideDropPos()
                  die DropPosition wieder weggenommen werden. Es ist dadurch
                  auch moeglich, ein von ausserhalb des TabBars ausgeloestes
                  Drag zu verarbeiten.

Drop            - Im Drop-Handler muessen dann die Pages verschoben werden,
                  oder die neuen Pages eingefuegt werden. Die entsprechende
                  Drop-Position kann mit ShowDropPos() ermittelt werden.

Folgende Methoden werden fuer Drag and Drop gebraucht und muessen von
den Handlern gerufen werden:

StartDrag       - Muss aus dem Commnad-Handler gerufen werden. Als Parameter
                  muss der CommandEvent uebergeben werden und eine Referenz
                  auf eine Region. Diese vcl::Region muss dann bei ExecuteDrag()
                  uebergeben werden, wenn der Rueckgabewert sagt, das
                  ExecuteDrag durchgefuehrt werden soll. Falls der Eintrag
                  nicht selektiert ist, wird er vorher als aktueller
                  Eintrag gesetzt. Es ist daher darauf zu achten, das aus
                  dieser Methode heraus der Select-Handler gerufen werden
                  kann.

ShowDropPos     - Diese Methode muss vom QueryDrop-Handler gerufen werden,
                  damit der TabBar anzeigt, wo die Tabs eingefuegt werden.
                  Diese Methode kann auch im Drop-Handler benutzt werden,
                  um die Position zu ermitteln wo die Tabs eingefuegt werden
                  sollen. In der Methode muss die Position vom Event
                  uebergeben werden. Diese Methode gibt die Position zurueck,
                  wo die Tabs eingefuegt werden sollen.

HideDropPos     - Diese Methode nimmt die vorher mit ShowDropPos() angezeigte
                  DropPosition wieder zurueck. Diese Methode sollte dann
                  gerufen werden, wenn bei QueryDrop() das Fenster verlassen
                  wird oder der Dragvorgang beendet wurde.

Folgende Methoden koennen eingesetzt werden, wenn bei D&D die Seiten
umgeschaltet werden sollen:

SwitchPage      - Diese Methode muss vom QueryDrop-Handler gerufen werden,
                  wenn die Seite ueber der sich der Mousepointer befindet,
                  umgeschaltet werden soll. Diese Methode sollte jedesmal
                  gerufen werden, wenn der QueryDrop-Handler gerufen wird.
                  Das umschalten der Seite passiert zeitverzoegert (500 ms)
                  und wird automatisch von dieser Methode verwaltet.
                  In der Methode muss die Position vom Event uebergeben
                  werden. Diese Methode gibt sal_True zurueck, wenn die Page
                  umgeschaltet wurde.

EndSwitchPage   - Diese Methode setzt die Daten fuer das umschalten der
                  Seiten zurueck. Diese Methode sollte dann gerufen werden,
                  wenn bei QueryDrop() das Fenster verlassen wird oder
                  der Dragvorgang beendet wurde.

IsInSwitching   - Mit dieser Methode kann im ActivatePage()/DeactivatePage()
                  abgefragt werden, ob dies durch SwitchPage() veranlasst
                  wurde. So kann dann beispielsweise in DeactivatePage()
                  das Umschalten ohne eine Fehlerbox verhindert werden.


Fenster-Resize
--------------

Wenn das Fenster vom Anwender in der Breite geaendert werden kann, dann
muss das WinBit WB_SIZEABLE gesetzt werden. In diesem Fall muss noch
folgender Handler ueberlagert werden:

Split           - Wenn dieser Handler gerufen wird, sollte das Fenster
                  auf die Breite angepasst werden, die von GetSplitSize()
                  zurueckgegeben wird. Dabei wird keine minimale und
                  maximale Breite beruecksichtig. Eine minimale Breite
                  kann mit GetMinSize() abgefragt werden und die maximale
                  Breite muss von der Anwendung selber berechnet werden.
                  Da nur Online-Resize unterstuetzt wird, muss das Fenster
                  innerhalb dieses Handlers in der Breite geaendert
                  werden und eventuell abhaengige Fenster ebenfalls. Fuer
                  diesen Handler kann auch mit SetSplitHdl() ein
                  Link gesetzt werden.

Folgende Methoden liefern beim Splitten weitere Informationen:

GetSplitSize()  - Liefert die Breite des TabBars zurueck, auf die der
                  Anwender das Fenster resizen will. Dabei wird keine
                  minimale oder maximale Breite beruecksichtigt. Es wird
                  jedoch nie eine Breite < 5 zurueckgeliefert. Diese Methode
                  liefert nur solange richtige Werte, wie Splitten aktiv
                  ist.

GetMinSize()    - Mit dieser Methode kann eine minimale Fensterbreite
                  abgefragt werden, so das min. etwas eines Tabs sichtbar
                  ist. Jedoch kann der TabBar immer noch schmaler gesetzt
                  werden, als die Breite, die diese Methode zurueckliefert.
                  Diese Methode kann auch aufgerufen werden, wenn kein
                  Splitten aktiv ist.


Edit-Modus
----------

Der Tabbar bietet auch Moeglichkeiten, das der Anwender in den Tabreitern
die Namen aendern kann.

EnableEditMode  - Damit kann eingestellt werden, das bei Alt+LeftClick
                  StartEditMode() automatisch vom TabBar gerufen wird.
                  Im StartRenaming()-Handler kann dann das Umbenennen
                  noch abgelehnt werden.
StartEditMode   - Mit dieser Methode wird der EditModus auf einem
                  Tab gestartet. sal_False wird zurueckgegeben, wenn
                  der Editmodus schon aktiv ist, mit StartRenaming()
                  der Modus abgelehnt wurde oder kein Platz zum
                  Editieren vorhanden ist.
EndEditMode     - Mit dieser Methode wird der EditModus beendet.
SetEditText     - Mit dieser Methode kann der Text im AllowRenaming()-
                  Handler noch durch einen anderen Text ersetzt werden.
GetEditText     - Mit dieser Methode kann im AllowRenaming()-Handler
                  der Text abgefragt werden, den der Anwender eingegeben
                  hat.
IsInEditMode    - Mit dieser Methode kann abgefragt werden, ob der
                  Editmodus aktiv ist.
IsEditModeCanceled      - Mit dieser Methode kann im EndRenaming()-
                          Handler abgefragt werden, ob die Umbenenung
                          abgebrochen wurde.
GetEditPageId   - Mit dieser Methode wird in den Renaming-Handlern
                  abgefragt, welcher Tab umbenannt wird/wurde.

StartRenaming() - Dieser Handler wird gerufen, wenn ueber StartEditMode()
                  der Editmodus gestartet wurde. Mit GetEditPageId()
                  kann abgefragt werden, welcher Tab umbenannt werden
                  soll. sal_False sollte zurueckgegeben werden, wenn
                  der Editmodus nicht gestartet werden soll.
AllowRenaming() - Dieser Handler wird gerufen, wenn der Editmodus
                  beendet wird (nicht bei Cancel). In diesem Handler
                  kann dann getestet werden, ob der Text OK ist.
                  Mit GetEditPageId() kann abgefragt werden, welcher Tab
                  umbenannt wurde.
                  Es sollte einer der folgenden Werte zurueckgegeben
                  werden:
                  TAB_RENAMING_YES
                  Der Tab wird umbenannt.
                  TAB_RENAMING_NO
                  Der Tab wird nicht umbenannt, der Editmodus bleibt
                  jedoch aktiv, so das der Anwender den Namen
                  entsprechent anpassen kann.
                  TAB_RENAMING_CANCEL
                  Der Editmodus wird abgebrochen und der alte
                  Text wieder hergestellt.
EndRenaming()   - Dieser Handler wird gerufen, wenn der Editmodus
                  beendet wurde. Mit GetEditPageId() kann abgefragt
                  werden, welcher Tab umbenannt wurde. Mit
                  IsEditModeCanceled() kann abgefragt werden, ob der
                  Modus abgebrochen wurde und der Name dadurch nicht
                  geaendert wurde.


Maximale Pagebreite
-------------------

Die Pagebreite der Tabs kann begrenzt werden, damit ein einfacheres
Navigieren ueber diese moeglich ist. Wenn der Text dann nicht komplett
angezeigt werden kann, wird er mit ... abgekuerzt und in der Tip-
oder der aktiven Hilfe (wenn kein Hilfetext gesetzt ist) wird dann der
ganze Text angezeigt. Mit EnableAutoMaxPageWidth() kann eingestellt
werden, ob die maximale Pagebreite sich nach der gerade sichtbaren
Breite richten soll (ist der default). Ansonsten kann auch die
maximale Pagebreite mit SetMaxPageWidth() (in Pixeln) gesetzt werden
(die AutoMaxPageWidth wird dann ignoriert).


KontextMenu
-----------

Wenn ein kontextsensitives PopupMenu anzeigt werden soll, muss der
Command-Handler ueberlagert werden. Mit GetPageId() und bei
Uebergabe der Mausposition kann ermittelt werden, ob der Mausclick
ueber einem bzw. ueber welchem Item durchgefuehrt wurde.
*/


1 / 6 | libreoffice-4.4.0.3/include/svtools/imappoly.hxx
// liefert das BoundRect des Polygon-Objektes in 1/100mm


3 / 10 | libreoffice-4.4.0.3/include/svtools/treelistentry.hxx
// Flags, die am Model haengen
// wird gesetzt, wenn RequestingChildren keine Children gestzt hat
// Eintrag hatte oder hat Kinder


3 / 16 | libreoffice-4.4.0.3/include/svtools/svlbitm.hxx
// Indizes siehe Konstanten BMP_ ....
// weil Buttons nicht von LinkHdl abgeleitet sind
// zum Loeschen von UNCHECKED,CHECKED,TRISTATE


41 / 66 | libreoffice-4.4.0.3/include/svtools/parhtml.hxx
// Wert einer HTML-Option
// und der dazugehoerige Wert eines Enums
// Repraesentation einer HTML-Option (=Atrribut in einem Start-Tag)
// Die Werte der Optionen werden immer als String gespeichert.
// Die Methoden GetNumber, ... duerfen nur aufgerufen werden, wenn
// die Option auch numerisch, ... ist.
// der Wert der Option (immer als String)
// der Name der Option als String
// und das entsprechende Token
// der Wert der Option ...
// ... als Zahl
// ... als Zahl
// ... als Zahlen
// ... als Farbe
// ... als Enum pOptEnums ist ein HTMLOptionEnum-Array
// ... und als ein par spezielle Enums
// die Optionen des Start-Tags
// neues Doc lesen ?
// scanne Header-Bereich
// scanne Body-Bereich
// Lesen von <SCRIPT>
// Lesen von <STYLE>
// </SCRIPT> oder </STYLE> gefunden
// Flags fuers lesen von PRE-Absaetzen
// Pos in der Line im PRE-Tag
// das gelesene Tag als String
// scanne das naechste Token,
// Aufruf des Parsers
// PRE-/LISTING oder XMP-Modus starten/beenden oder Tags entsprechend
// Das aktuelle Token dem aktuellen Modus (PRE, XMP, ...) entsprechend
// Filtern und die Flags setzen. Wird von Continue aufgerufen, bevor
// NextToken gerufen wird. Wer eigene Schleifen implementiert bzw.
// selbst NextToken aufruft, sollte diese Methode vorher rufen.
// Scannen eines Scripts beenden (sollte nur unmittelbar nach dem
// Lesen eines <SCRIPT> aufgerufen werden
// Token ohne \-Sequenzen
// Ermitteln der Optionen. pNoConvertToken ist das optionale Token
// einer Option, fuer die CR/LFs nicht aus dem Wert der Option
// fuers asynchrone lesen aus dem SvStream
// Einen Kommentar um den Inhalt von <SCRIPT> oder <STYLE> entfernen
// Bei 'bFull' wird ggf. die gesammte Zeile hinter einem "<!--"


25 / 34 | libreoffice-4.4.0.3/include/svtools/htmlkywd.hxx
// diese werden nur eingeschaltet
// diese werden wieder abgeschaltet
// die Namen fuer alle Zeichen
// Attribute mit einem String als Wert
// Attribute mit einem SGML-Identifier als Wert
// Attribute mit einem URI als Wert
// Attribute mit einer Farbe als Wert (alle Netscape)
// Attribute mit einem numerischen Wert
// Attribute mit Enum-Werten
// Attribute mit Script-Code als Wert
// Attribute mit Kontext-abhaengigen Werten
// Werte von <INPUT TYPE=...>
// Werte von <TABLE FRAME=...>
// Werte von <TABLE RULES=...>
// Werte von <P, H?, TR, TH, TD ALIGN=...>
// Werte von <TR VALIGN=...>, <IMG ALIGN=...>
// Werte von <AREA SHAPE=...>
// ein par Werte fuer unser StarBASIC-Support
// Werte von <FORM METHOD=...>
// Werte von <META CONTENT/HTTP-EQUIV=...>
// Werte von <UL TYPE=...>
// Werte von <FRAMESET SCROLLING=...>
// Werte von <MULTICOL TYPE=...>
// Werte von <MARQUEE BEHAVIOUR=...>
// Werte von <MARQUEE LOOP=...>


3 / 35 | libreoffice-4.4.0.3/include/svtools/rtftoken.h
// suche die TokenID zu dem Token
// !!! kann hinein verodert werden (Border/Background) !!!!
// !!! kann hinein verodert werden (Border/Tab) !!!!


2 / 6 | libreoffice-4.4.0.3/include/svtools/htmlout.hxx
// der 3. Parameter ist ein Array von HTMLOutEvents, das mit einem
// nur aus 0 bestehen Eintrag terminiert ist.


1 / 10 | libreoffice-4.4.0.3/include/svtools/sfxecode.hxx
//Dies und das


21 / 209 | libreoffice-4.4.0.3/include/svtools/htmltokn.h
// suche das Char zu dem CharNamen
// suche die TokenID zu dem Token
// suche die TokenId zu einemm Attribut-Token
// suche die 24-bit-Farbe zu einem Farbnamen (nicht gefunden = ULONG_MAX)
// beginnen immer ab 256, groesser als ein char
// diese werden nur eingeschaltet
// Netscape 2.0            </EMBED> ignorieren
// Netscape 3.0b5      // </SPACER> ignorieren
// Tokens, die ueber HTML-Charakter erkannt werden
// diese werden wieder abgeschaltet,
//  der off-Wert liegt immer dahinter (+1) !!
// beginnen immer ab 256, groesser als ein char
// Attribute mit einem String als Wert
// Attribute mit einem SGML-Identifier als Wert
// Attribute mit einem URI als Wert
// Attribute mit einer Farbe als Wert (alle Netscape)
// Attribute mit einem numerischen Wert
// Attribute mit Enum-Werten
// Attribute mit Script-Code als Wert
// Attribute mit Kontext-abhaengigen Werten
// eine unbekannte Option


1 / 5 | libreoffice-4.4.0.3/include/svtools/stdmenu.hxx
/*************************************************************************

Beschreibung
============

class FontNameMenu

Beschreibung

Erlaubt die Auswahl von Fonts. Das Menu wird ueber Fill mit den FontNamen
gefuellt. Fill sortiert automatisch die FontNamen (inkl. aller Umlaute und
sprachabhaengig). Mit SetCurName()/GetCurName() kann der aktuelle Fontname
gesetzt/abgefragt werden. Wenn SetCurName() mit einem leeren String
aufgerufen wird, wird kein Eintrag als aktueller angezeigt (fuer DontKnow).
Vor dem Selectaufruf wird der ausgewaehlte Name automatisch als aktueller
gesetzt und wuerde beim naechsten Aufruf auch als aktueller Name angezeigt
werden. Deshalb sollte vor PopupMenu::Execute() gegebenenfalls mit
SetCurName() der aktuelle Fontname gesetzt werden.

Da die Id's und der interne Aufbau des Menus nicht bekannt ist, muss ein
Select-Handler gesetzt werden, um die Auswahl eines Namens mitzubekommen.

In dieses Menu koennen keine weiteren Items eingefuegt werden.

Spaeter soll auch das Menu die gleichen Bitmaps anzeigen, wie die
FontNameBox. Auf den Systemen, wo Menues nicht automatisch scrollen,
wird spaeter wohl ein A-Z Menu ziwschengeschaltet. Da ein Menu bei vielen
installierten Fonts bisher schon immer lange gebraucht hat, sollte dieses
Menu schon jetzt nur einmal erzeugt werden (da sonst das Kontextmenu bis
zu 10-Sekunden fuer die Erzeugung brauchen koennte).

Querverweise

FontList; FontSizeMenu; FontNameBox

--------------------------------------------------------------------------

class FontSizeMenu

Beschreibung

Erlaubt die Auswahl von Fontgroessen. Ueber Fill wird das FontSizeMenu
gefuellt und ueber GetCurHeight() kann die ausgewaehlte Fontgroesse
abgefragt werden. Mit SetCurHeight()/GetCurHeight() kann die aktuelle
Fontgroesse gesetzt/abgefragt werden. Wenn SetCurHeight() mit 0 aufgerufen
wird, wird kein Eintrag als aktueller angezeigt (fuer DontKnow). Vor dem
Selectaufruf wird die ausgewaehlte Groesse automatisch als aktuelle gesetzt
und wuerde beim naechsten Aufruf auch als aktuelle Groesse angezeigt werden.
Deshalb sollte vor PopupMenu::Execute() gegebenenfalls mit SetCurHeight()
die aktuelle Groesse gesetzt werden. Da die Groessen vom ausgewaehlten Font
abhaengen, sollte nach einer Aenderung des Fontnamen das Menu mit Fill mit
den Groessen des Fonts neu gefuellt werden.

Da die Id's und der interne Aufbau des Menus nicht bekannt ist, muss ein
Select-Handler gesetzt werden, um die Auswahl einer Groesse mitzubekommen.

Alle Groessen werden in 10tel Point angegeben.

In dieses Menu koennen keine weiteren Items eingefuegt werden.

Spaeter soll das Menu je nach System die Groessen anders darstelllen. Zum
Beispiel koennte der Mac spaeter vielleicht einmal die Groessen als Outline
darstellen, die als Bitmap-Fonts vorhanden sind.

Querverweise

FontList; FontNameMenu; FontSizeBox

*************************************************************************/


27 / 55 | libreoffice-4.4.0.3/include/svtools/svparser.hxx
// gescanntes Token
// akt. Zeilen Nummer
// akt. Spalten Nummer
// zusaetzlicher Wert (RTF)
// Status auch in abgl. Klassen
// Akt. Zeichen fuer die "lex"
// sal_True: Es wird gerade ein externes
//       ignoriert werden.
// Wenn keibes der folgenden
// Flags gesetzt ist, wird der
// aber als CharSet DONTKNOW
// zurueckgegeben.
// oder als big-endian UCS2
// Umschalten des ist erlaubt
// scanne das naechste Token:
//  Tokenstack abarbeiten und ggfs. _GetNextToken() rufen. Diese
//  ist fuers erkennen von neuen Token verantwortlich
// wird fuer jedes Token gerufen, das in CallParser erkannt wird
// zu Zeiten der SvRefBase-Ableitung darf nicht jeder loeschen
// Aufruf des Parsers
// fuers asynchrone lesen aus dem SvStream
// Darf der Zeichensatz auf UCS/2 umgeschaltet werden, wenn
// in den ersten beiden Zeichen im Stream eine BOM steht?
// Aus wie vielen Bytes betseht ein Zeichen
// Aufbau einer Which-Map 'rWhichMap' aus einem Array von
// 'pWhichIds' von Which-Ids. Es hat die Lange 'nWhichIds'.
// Die Which-Map wird nicht geloescht.


3 / 7 | libreoffice-4.4.0.3/include/svtools/parrtf.hxx
// scanne das naechste Token,
// Aufruf des Parsers
// fuers asynchrone lesen aus dem SvStream


4 / 9 | libreoffice-4.4.0.3/include/sot/object.hxx
// Ist Proxy, dann TRUE wenn andere Seite SV ist
// TRUE, im DoClose
// Nur damit die Makros in So3 nicht ganz ausufern
// Kopieren und Zuweisen dieses Objekttyps ist nicht erlaubt


8 / 20 | libreoffice-4.4.0.3/include/sot/storage.hxx
// Zeiger auf den eigenen Stream
// aKey.Len != 0  -> Verschluesselung
// eigener Datenbereich
// Typ der Daten im Storage
// Stream mit Verbindung zu Storage erzeugen,
// in etwa eine Parent-Child Beziehung
// Abfrage auf Storage oder Stream
// Element loeschen


1 / 8 | libreoffice-4.4.0.3/include/sot/factory.hxx
// Anzahl der Superklassen


2 / 9 | libreoffice-4.4.0.3/include/sot/filelist.hxx
// Liste loeschen;
// Zuweisungsoperator


1 / 171 | libreoffice-4.4.0.3/include/basic/sbxdef.hxx
// Property oder Methode unbekannt


1 / 144 | libreoffice-4.4.0.3/include/i18nlangtag/lang.h
/* AKA K'iche', West Central Quiche,  */


1 / 9 | libreoffice-4.4.0.3/include/editeng/brushitem.hxx
// wird nur von Create benutzt


1 / 18 | libreoffice-4.4.0.3/include/editeng/lrspitem.hxx
// Die "Layout-Schnittstelle":


1 / 9 | libreoffice-4.4.0.3/include/editeng/cmapitem.hxx
// MS VC4.0 kommt durcheinander


1 / 39 | libreoffice-4.4.0.3/include/editeng/editdata.hxx
// MyEDITDATA, wegen exportiertem EditData


1 / 31 | libreoffice-4.4.0.3/include/toolkit/controls/unocontrolmodel.hxx
// setValue-Methoden ueberladen, um die Einzelproperties des FontDescriptors abzufangen


2 / 7 | libreoffice-4.4.0.3/include/toolkit/controls/unocontrolbase.hxx
// XLayoutConstrains (nur wenn das Control es unterstuetzt!)
// XTextLayoutConstrains (nur wenn das Control es unterstuetzt!)


2 / 119 | libreoffice-4.4.0.3/include/tools/stream.hxx
// Puffer-Verwaltung
// pRWBuf + nBufActualPos


1 / 22 | libreoffice-4.4.0.3/include/unotools/textsearch.hxx
//      - weighted Levenshtein distance


1 / 33 | libreoffice-4.4.0.3/include/unotools/configitem.hxx
//                      "de"        "Mein Name"


1 / 24 | libreoffice-4.4.0.3/include/vcl/seleng.hxx
// wird im Ctor eingeschaltet


1 / 36 | libreoffice-4.4.0.3/include/vcl/button.hxx
// - Control-Layer fuer alten Code -


1 / 13 | libreoffice-4.4.0.3/include/vcl/lstbox.hxx
// Bei MultiListBox nicht erlaubt...


1 / 73 | libreoffice-4.4.0.3/include/vcl/menu.hxx
// Liste mit den MenuItems


1 / 9 | libreoffice-4.4.0.3/include/vcl/vclenum.hxx
//!!! bei Aenderungen /basic/source/runtime/methods.cxx msgbox anpassen


1 / 6 | libreoffice-4.4.0.3/include/vcl/spinfld.hxx
// noch nicht angebunden...


1 / 8 | libreoffice-4.4.0.3/include/vcl/textview.hxx
// aus dem protected Teil hierher verschoben


1 / 9 | libreoffice-4.4.0.3/include/vcl/status.hxx
// - Progress-Ausgabe -


5 / 9 | libreoffice-4.4.0.3/include/sfx2/zoomitem.hxx
// GetValue() ist kein besonderer prozentualer Wert
// GetValue() entspricht der optimalen Gr"o\se
// GetValue() entspricht der ganzen Seite
// GetValue() entspricht der Seitenbreite
// erlaubte Werte (siehe #defines unten)


1 / 16 | libreoffice-4.4.0.3/include/sfx2/docfile.hxx
// Diese Protokolle liefern MIME Typen


4 / 593 | libreoffice-4.4.0.3/include/filter/msfilter/escherex.hxx
// long dash style
// dash short dash
// long dash short dash
// long dash short dash short dash


1 / 10 | libreoffice-4.4.0.3/include/filter/msfilter/msocximex.hxx
// das einzige Formular


1 / 20 | libreoffice-4.4.0.3/include/oox/drawingml/lineproperties.hxx
/// Preset dash (OOXML token).


1 / 49 | libreoffice-4.4.0.3/include/oox/vml/vmlformatting.hxx
///< Gradient rotation angle.


1 / 6 | libreoffice-4.4.0.3/include/framework/bmkmenu.hxx
// Synchrones Laden der Eintraege


1 / 13 | libreoffice-4.4.0.3/avmedia/source/opengl/oglwindow.cxx
// Limit zooming in orbit mode


1 / 108 | libreoffice-4.4.0.3/cui/source/tabpages/numfmt.cxx
// UpdateOptions_Impl() als Seiteneffekt


2 / 139 | libreoffice-4.4.0.3/cui/source/tabpages/tpline.cxx
// Miter
// Miter


1 / 29 | libreoffice-4.4.0.3/cui/source/tabpages/tplneend.cxx
// Flag fuer modifiziert setzen


1 / 18 | libreoffice-4.4.0.3/cui/source/tabpages/labdlg.cxx
//Keine gueltige View Uebergeben!


1 / 42 | libreoffice-4.4.0.3/cui/source/dialogs/iconcdlg.cxx
/* darf 0 sein */


1 / 59 | libreoffice-4.4.0.3/cui/source/options/personalization.cxx
// NE_SSL_UNTRUSTED being set in verify_callback in neon/src/ne_openssl.c


1 / 8 | libreoffice-4.4.0.3/odk/examples/cpp/complextoolbarcontrols/MyListener.h
/**
 * Registriert sich in der Office Konfiguration als Job.
 * Dieser wird dann fÃ¼r alle neu geÃ¶ffneten Dokumente automatisch
 * gerufen. Man bekommt eine Reference auf das geÃ¶ffnete Dokument
 * Ã¼berreicht und kann dann prÃ¼fen, ob es ein unterstÃ¼tztes Format
 * hat. (Wir interessieren uns ja schlieÃlich nur fÃ¼r Writer/Calc Dokumente.)
 *
 * @see CalcListener
 * @see WriterListener
 */


1 / 36 | libreoffice-4.4.0.3/slideshow/source/engine/activitiesqueue.cxx
// maCurrentActivitiesReinsert list


2 / 12 | libreoffice-4.4.0.3/slideshow/source/engine/animationnodes/setactivity.hxx
// discharge end event:
// don't reinsert


2 / 194 | libreoffice-4.4.0.3/xmloff/inc/txtflde.hxx
/// omit zero-length durat.
/// omit zero-length durations


1 / 211 | libreoffice-4.4.0.3/xmloff/source/style/xmlnumfe.cxx
// element written in FinishTextElement_Impl


1 / 149 | libreoffice-4.4.0.3/xmloff/source/core/xmlexp.cxx
// export dash-styles


1 / 324 | libreoffice-4.4.0.3/xmloff/source/text/txtflde.cxx
// Initalen oder voller Name?


1 / 52 | libreoffice-4.4.0.3/xmloff/source/xforms/xformsexport.cxx
// schemas


1 / 18 | libreoffice-4.4.0.3/xmloff/source/xforms/SchemaRestrictionContext.cxx
// second, type-dependent suffix + converter


1 / 10 | libreoffice-4.4.0.3/unotools/source/streaming/streamwrap.cxx
// Wenn gelesene Zeichen < MaxLength, css::uno::Sequence anpassen


1 / 20 | libreoffice-4.4.0.3/unotools/source/i18n/textsearch.cxx
// Parameters for weighted Levenshtein distance


5 / 12 | libreoffice-4.4.0.3/rsc/inc/rscconst.hxx
// Wert der Konstante
// Zeiger auf das Feld mit Konstanten
// Anzahle der Eintraege im Feld
// Die erlaubten Werte werden gesetzt
// Position der Konstanten im Array


5 / 13 | libreoffice-4.4.0.3/rsc/inc/rsctree.hxx
// einen binaeren Baum um
// Wandelt einen binaeren Baum in eine doppelt
// verkettete Liste um
// pCmp ist Zeiger auf Namen
// return ist neue Root


2 / 9 | libreoffice-4.4.0.3/rsc/inc/rscstr.hxx
// Zeiger auf String
// Der zulaessige Bereich wird gesetzt


4 / 12 | libreoffice-4.4.0.3/rsc/inc/rscflag.hxx
// Ist das Flag gesetzt
//Klasse die als Server benutzt wird
//Id des zu setzenden Wertes
// Eine Zuweisung an eine Variable


17 / 26 | libreoffice-4.4.0.3/rsc/inc/rscrange.hxx
// nValue = Ausgangswert - nMin
// Minimum des Bereiches
// Maximum des Bereiches
// Der zulaessige Bereich wird gesetzt
// Gibt die Groesse der Klasse in Bytes
// Eine Zuweisung an eine Variable
// nValue = Ausgangswert - nMin
// Minimum des Bereiches
// Maximum des Bereiches
// Der zulaessige Bereich wird gesetzt
// Gibt die Groesse der Klasse in Bytes
// Eine Zuweisung an eine Variable
// Minimum des Bereiches
// Maximum des Bereiches
// Der zulaessige Bereich wird gesetzt
//cUnused wird fuer Defaultkennung verwendet
// Der zulaessige Bereich wird gesetzt


8 / 17 | libreoffice-4.4.0.3/rsc/inc/rscclass.hxx
// Maskierungsbit
// Beginn der Instanzdaten
// Zeiger auf DefaultDaten
//Name fuer Fremddatenbereich
// Groesse der Instanzdaten dieser Klasse
// mit Superklassen
// Eintraege in pVarTypeList
// Gibt die Groesse der Klasse in Bytes


6 / 10 | libreoffice-4.4.0.3/rsc/inc/rscarray.hxx
/* Der Baum wird ueber die Werte des Enums sortiert, nicht ueber
    seine HashId.
*/
// Typ der Eintraege
// Groesse der Instanzdaten dieser Klasse
// mit Superklassen
// Offset auf eigen Instanzdaten
// Gibt die Groesse der Klasse in Bytes


35 / 46 | libreoffice-4.4.0.3/rsc/inc/rsctop.hxx
/* Auch die Ableitung einer Klasse kann angegeben werden */
// Klassenaufruf ohne Typen bis ResId
// Klassenaufruf ohne Typen ab ResId
// Klassenaufruf mit Typen
// Gibt den Typidentifier zurueck
// Gibt die Oberklasse zurueck
// Vorbereitung auf den dtor aufruf
// Da die Klassen gegenseitige Abhaengigkeiten
// aufweisen koennen, kann man im dtor nicht davon
// ausgehen, dass alle Klassenzeiger noch gueltig sind
// Gibt die Groesse der Klasse in Bytes
// Gibt die Referenz zurueck
// Gibt die Referenz zurueck
// Zaehlt alle Variablen auf
// pData, pClass im return koennen NULL sein
// Liefert Instanz aus einem Feld zurueck
// pGetInst im return kann NULL sein
// Liefert Instanz aus einem Feld zurueck
// pGetInst im return kann NULL sein
// Liefert Instanz aus einem Feld zurueck
// pGetInst im return kann NULL sein
// verschiebt eine Instanz
// an der Position zurueck
// Anzahl der Eintraege
// Eine Zuweisung an eine Variable
// Eine Zuweisung an eine Variable
// Eine Zuweisung an eine Variable
// Eine Zuweisung an eine Variable
// prueft auf konsistenz
// Alles auf Default setzen
// Ist Eingabe = Default
// Gleiche Werte auf Default setzen
// Instanz auf Default setzen
// Default zu einer Variablen holen
// Schreibt den Kopf und das Ende einer Resource


14 / 20 | libreoffice-4.4.0.3/rsc/inc/rscpar.hxx
// Erster Fehler
// Zeile des ersten Fehlers
// Position des ersten Fehlers
// Zeile in der Eingabedatei
// Index auf Eingabedatei
// Index auf Basisdatei
// Eingabedatei
// Position im Lesepuffer
// Ende im Lesepuffer
// Zeile
//Lange des Zeilenpuffres
// Position in der Zeile
// ctor initialisieren
// Fehlerbehandlung


6 / 20 | libreoffice-4.4.0.3/rsc/inc/rscrsc.hxx
// Steuerbits
// Name der Srs-Ausgabedatei
// String und Id-Verwalter
// Kommandozeile
// Ausgabedatei fuer Listings
// bei Abbruch muss diese Datei geschlossen werden


7 / 11 | libreoffice-4.4.0.3/rsc/inc/rsccont.hxx
// Typ der Eintraege
// Zwei verschiedene Typen moeglich
// Keine Identifier
// Groesse der Instanzdaten dieser Klasse
// mit Superklassen
// Offset auf eigen Instanzdaten
// Gibt die Groesse der Klasse in Bytes


12 / 28 | libreoffice-4.4.0.3/rsc/inc/rscall.h
// Zeiger auf die Daten einer Klasse
// Hilfe anzeigen
// kein Preprozesor
// keine Syntaxanalyse
// nicht linken
// keine .res-Datei erzeugen
// es wurde Definitionen angegeben
// der Include-Pfad wurde erweitert
// Syntax ausgeben
// immer der Default geschrieben
// ueberprueft nicht die Richtigkeit von (bmp, ico, cur)
// Klasse des Eintrages


2 / 18 | libreoffice-4.4.0.3/rsc/inc/rscclobj.hxx
// Dateischluessel
// Zeiger auf Objektbaum


3 / 8 | libreoffice-4.4.0.3/rsc/inc/rsckey.hxx
//soll bei jedem einfuegen sortiert werden?
//Anzahl der Eintr"age
// true, wurde gefunden


3 / 30 | libreoffice-4.4.0.3/rsc/inc/rscerror.h
// Anzahl der Fehler
// Dieser Fehler sollte nur im Compilermodus auftreten,
// das Programm wird mit exit() verlassen


15 / 27 | libreoffice-4.4.0.3/rsc/inc/rscdb.hxx
// Tabelle fuer Systemabhaengige Resourcen
// Globaler Maschinentyp
// Intel oder
// Suchen der Bitmap, Icon, Pointer
// eindeutiger Id fuer Systemresourcen
// Position in der Datei ( MTF )
// eindeutiger Id fuer PM-Rseourcefile
// muss groesser als RSC_VERSIONCONTROL_ID sein
// Zeiger auf die Wurzel vom Typenbaum
// Liste der einfachen Resourceklasse
// Initialisiert Klassen und Tabelle
// Fehlerhandler
//Ordnet Resourcetypen und Id's einen Id zu
//(unter PM), oder eine Dateiposition (MTF)
// loescht alle Resourceobjekte diese Datei


2 / 10 | libreoffice-4.4.0.3/rsc/inc/rsclex.hxx
// forward Deklaration fuer erzeugte Funktion
// forward Deklaration fuer erzeugte Funktion


12 / 29 | libreoffice-4.4.0.3/rsc/inc/rscdef.hxx
// false, bei den Namenoperation nur Zahlen
// Zahl, Define oder Ausdruck
// Gibt den Namen des Defines zurueck
// zu welcher Datei gehoert das Define
// Wieviele Referenzen auf dieses Objekt
// pExpression wird auf jedenfall Eigentum der Liste
// Tabelle die alle Dateinamen enthaelt
// Ist es eine Include-Datei
// Ist die Datei geladen
// Wurde Datei nach Inclide abgesucht
// Pfad und Name der Datei
// Alle Defines die in dieser Datei Definiert sind loeschen


1 / 8 | libreoffice-4.4.0.3/rsc/inc/rsctools.hxx
// Zeichensatz


6 / 19 | libreoffice-4.4.0.3/rsc/source/prj/start.cxx
// Kommandozeile
// Kommandozeile
// Kommandozeile
// kein Preprozessor
// Hilfe anzeigen
// Eingabedatei


1 / 4 | libreoffice-4.4.0.3/rsc/source/prj/gui.cxx
// wird durch InitRscCompiler erzeugt


1 / 17 | libreoffice-4.4.0.3/rsc/source/rscpp/cppdef.h
/* NWORK wg. grooossen Makros in *.src erhoeht,
 da wir bald 10 Sprachen haben werden gleich ordentlich reingehauen.. */


2 / 118 | libreoffice-4.4.0.3/rsc/source/rscpp/cpp.h
/* in cpp1.c: file-pointer auf stdout oder file */
/* fuer die cpp.lib muss main() geandert werden */


2 / 117 | libreoffice-4.4.0.3/rsc/source/rscpp/cpp1.c
/* einzige Moeglichkeit unter BC Stack und Heap festzusetzen */
/* in der LIB-Version muessen alle Variablen initialisiert werden */


4 / 62 | libreoffice-4.4.0.3/rsc/source/rscpp/cpp3.c
/*
 * Kontext: GenMake
 * Unter DOS wird nun auch die Environment-Variable INCLUDE ausgewetet.
 * Es kommt erschwerend hinzu, dass alle Eintraege, die mit ';' getrennt
 * sind, mit in die Liste aufenommen werden muessen.
 * Dies wird mit der Funktion strtok() realisiert.
 * Vorsicht bei der Benutzung von malloc !!!
 * In savestring wird naemlich getmem() verwendet. Vermutlich kommen sich
 * die beiden Funktion in die Quere. Als ich malloc statt savestring
 * verwendete knallte es in strcpy() !
 */
/* Pointer auf INCLUDE   */
/* Kontext: Erweiterung des INCLUDE-Services
 * Bislang konnte der cpp keine Include-Angaben in der Kommandozeile
 * vertragen, bei denen die directries mit ';' getrennt wurden.
 * Dies ist auch verstaendlich, da dieses cpp fuer UNIX-Systeme
 * massgeschneidert wurde und in UNI die ';' als Zeichen zum Abschluss
 * von Kommandos gilt.
 */
/* wandert zum naechsten */


27 / 37 | libreoffice-4.4.0.3/rsc/source/res/rscclass.cxx
// Objekt loeschen
// Speicher freigeben
// Bereich fuer Default zu klein
// Default Instanz generieren
// mit dem Variablen-Default besetzen
// Wird ueber Zeiger angegeben
// auf nicht Default setzen
// mit Variablen Default initialiaieren
// Variablen ohne eigenen Speicher werden vom "Datenserver"
// auf Default gesetzt
// alles auf Default
// Variablen ohne eigenen Speicher werden vom "Datenserver"
// auf Default untersucht
//sie haben auch die gleiche Klasse
//sie haben nicht die gleiche Klasse
//In Superklasse nach Variable suchen
// Hack wegen Position und Dimensiuon
// ein Wert ist nicht Default
//_X, _Y oder _Width, Height ueberlesen
// Sprach Delta holen
// Offset um Maskenfeld zu addressieren
// Wenn eine Variable Maskierung hat, dann Maskenfeld
// Nur an Variable Extradata bExtra nicht auf false
// Nur an Variable Extradata bExtra nicht auf false
//Instanz mit dem Dateinamen "FILENAME" holen
// Identifier schreiben
// nur wenn es eigen Klasse ist


4 / 8 | libreoffice-4.4.0.3/rsc/source/res/rscstr.cxx
// Sind die Referenzidentifier gleich
// nach \ mindesten 3 Zeichen wegeb \xa7
//nocht nicht zu ende
//Erhoehen und abfragen um Endlosrekusion zu vermeiden


1 / 5 | libreoffice-4.4.0.3/rsc/source/res/rscrange.cxx
//cUnused wird fuer Defaultkennung verwendet


5 / 8 | libreoffice-4.4.0.3/rsc/source/res/rscarray.cxx
//Baum rekursiv loeschen
// nicht gefunden
// nicht gefunden
// nur einen Wert schreiben
// Eigenen Typ schreiben


6 / 16 | libreoffice-4.4.0.3/rsc/source/res/rsccont.cxx
// Eintrag gefunden
// Instanz mit CreateInst-Daten initialisieren
// Richtung der for-Schleife bestimmen
// Zuweisung Quelle auf Ziel
// auf doppelten Id Testen und Reihenfolge beibehalten
// Nur Subresourcen schreiben, wenn bExtra == true


8 / 14 | libreoffice-4.4.0.3/rsc/source/res/rscmgr.cxx
//Erhoehen und abfragen um Endlosrekusion zu vermeiden
// RscClass wird uebersprungen
/*
            // Definition der Struktur, aus denen die Resource aufgebaut ist
            struct RSHEADER_TYPE{
                RESOURCE_TYPE   nRT;        // Resource Typ
                sal_uInt32          nRT;        // Resource Typ
                sal_uInt32          nGlobOff;   // Globaler Offset
                sal_uInt32          nLocalOff;  // Lokaler Offset
            };
            */
// Referenziertes Objekt holen
// Referenzierte Objekt gefunden ?
//aTmpI.IsInst() wird false, Schleife beenden
// vorher eintragen,
// sonst Fehler bei rekursion


13 / 19 | libreoffice-4.4.0.3/rsc/source/tools/rscdef.cxx
// Programmuebergreifende Includes.
// Eventuellen Fehler ignorieren
// linken und rechten Zweig auswerten
// Ausgabeoptimierung
// linken Zweig auswerten
// rechten Zweig auswerten
//von hinten nach vorne ist besser wegen der Abhaengigkeiten
//Objekte zerstoeren sich, wenn Referenzzaehler NULL
// Current-Zeiger steht auf letztem Element
//letztes Element muss immer letztes bleiben
// Abhaengigkeit vor der letzten Position eintragen
//Macros in den Expressions sind definiert ?
// pExp wird immer Eigentum und muss, wenn es nicht benoetigt wird


8 / 23 | libreoffice-4.4.0.3/rsc/source/tools/rsctree.cxx
// rechten Zeiger auf Null
// linken Zeiger auf Null
// linke Liste rechter Knoten
// Ein Knoten wird in den Baum eingefuegt
// Gibt es einen Knoten mit dem gleichen Namen, dann return false
// sonst return true. Der Knoten wird auf jeden Fall eingefuegt.
// pSearch ist ein Zeiger auf sal_uInt32
// pSearch ist ein Zeiger auf const char *


3 / 7 | libreoffice-4.4.0.3/rsc/source/parser/erscerr.cxx
// Fehlerposition anzeigen
//Zeilennummern beachten
// Keine Warning erzeugen


17 / 101 | libreoffice-4.4.0.3/rsc/source/parser/rscicpx.cxx
// Clientvariablen einfuegen
// Die Klasse RscSysDepend behandelt die Variablen
// Variable einfuegen
// Variable einfuegen
// Variable einfuegen
// Variable einfuegen
// Variable einfuegen
// Clientvariablen einfuegen
// Variable einfuegen
// Variable einfuegen
// Clientvariablen einfuegen
// weiss noch nich
// Variable einfuegen
// Variable einfuegen
// Clientvariablen einfuegen
// Variable einfuegen
// Variable einfuegen


3 / 6 | libreoffice-4.4.0.3/rsc/source/parser/rsckey.cxx
// Schluesselwort Feld sortieren
// Suche nach dem Schluesselwort
// Schluesselwort gefunden


9 / 30 | libreoffice-4.4.0.3/rsc/source/parser/rscinit.cxx
/* Werte fuer Aufzaehlungstypen */
// String als Referenzklasse des Basisstrings einsetzen
// pClassAccel ist erst hier definiert
// pClassMenu ist erst hier definiert
// Clientvariablen einfuegen
// Mehrfachvererbung von Hand
// Mehrfachvererbung von Hand
// Mehrfachvererbung von Hand
// Mehrfachvererbung von Hand


3 / 11 | libreoffice-4.4.0.3/rsc/source/parser/rscibas.cxx
// Clientvariablen einfuegen
// Clientvariablen einfuegen
// Clientvariablen einfuegen


19 / 30 | libreoffice-4.4.0.3/rsc/source/parser/rscdb.cxx
//mindestens einen groesser
// Alle Unterbaeume loeschen
// Alle Klassen noch gueltig, jeweilige Instanzen freigeben
// Zusammengesetzte Typen
/*  [Beschreibung]

        Sucht eine Basistyp nId;
    */
// Enthaelt den ersten Fehler
// AusgabeDatei
// Definition der Struktur, aus denen die Resource aufgebaut ist
// Tabelle wird entsprechend gefuellt
// kommt immmer als letztes
//Anzahl speichern
// Schluessel schreiben
// Objekt Id oder Position schreiben
// Groesse hinten Speichern
//Dateioffset neu setzen
//Position wurde vorher in Tabelle geschrieben
//mindestens einen groesser
// Resourceinstanzen loeschen
// Defines loeschen


10 / 26 | libreoffice-4.4.0.3/rsc/source/parser/rsclex.cxx
// War letztes Symbol INCLUDE
//Oberstes bit gegebenenfalls abschneiden;
// Kommentare und Leerzeichen ueberlesen
//Zuruecksetzten
// Suche nach dem Schluesselwort
// Schluesselwort gefunden
// Datenkontainer setzten
// Anfangszeichen initialisieren
// Fileschluessel
// yyparser gibt 0 zurueck, wenn erfolgreich


5 / 10 | libreoffice-4.4.0.3/rsc/source/parser/rscpar.cxx
//Status: Zeiger am Ende des Lesepuffers
//immer eine Zeile lesen
// einen dazu fuer '\0'
// cr lf, lf cr, lf oder cr wird '\0'
// Abbruch ueber EOF


15 / 49 | libreoffice-4.4.0.3/rsc/source/rsc/rsc.cxx
// Linken, keine Syntax und kein Prepro
// erzeugt kein .res-file
// Alle Resourcen mit Preload
// Byte Ordnung beim Schreiben
// Byte Ordnung beim Schreiben
// Bitmap, Pointers, Icons nicht ueberpruefen
// Eingabedatei
// Currentzeiger richtig setzen
// kopiere von TMP auf richtigen Namen
// Zieldatei loeschen
// ?T 281091MM nur eine Src-Datei
// Include-Pfad durchsuchen
// Kein Pfad und Include Datei
//bei Fehler nicht geladenen
//Resourceobjekte loeschen


4 / 21 | libreoffice-4.4.0.3/vcl/inc/jobset.h
// Papierformat wird wenn PAPER_USER im unabhaengigen Teil automatisch aus
// Papierbreite/hoehe berechnet
// Papierbreite/hoehe wird wenn 0 im unabhaengigen Teil automatisch aus
// Papierformat berechnet, wenn dieses ungleich PAPER_USER ist


1 / 5 | libreoffice-4.4.0.3/vcl/inc/idlemgr.hxx
// Timer* kann auch NULL sein


10 / 163 | libreoffice-4.4.0.3/vcl/inc/svdata.hxx
// HotKey-Verwaltung
// Letzte FaceColor fuer CheckImage
// Letzte WindowColor fuer CheckImage
// Letzte WindowTextColor fuer CheckImage
// Letzte LightColor fuer CheckImage
// Letzte FaceColor fuer RadioImage
// Letzte WindowColor fuer RadioImage
// Letzte LightColor fuer RadioImage
// Zeiger auf ersten Config-Block
// true: Es muessen noch Timer abgearbeitet werden


3 / 59 | libreoffice-4.4.0.3/vcl/inc/ilstbox.hxx
// VScroll an oder aus
// HScroll an oder aus
// AutoHScroll an oder aus


1 / 15 | libreoffice-4.4.0.3/vcl/inc/image.h
// Um Warning zu umgehen


2 / 14 | libreoffice-4.4.0.3/vcl/inc/win/salobj.h
// Child-Window, welches als letztes den Focus hatte
// Naechstes ClipRegion-Rect


6 / 52 | libreoffice-4.4.0.3/vcl/inc/win/salframe.h
// innerhalb eines Show-Aufrufs
// Move-Message wird verarbeitet
// Size-Message wird verarbeitet
// TRUE: WindowState darf umgesetzt werden
// TRUE: Wir behandeln nur einige IME-Messages
// TRUE: Wir befinden uns im Candidate-Modus


1 / 22 | libreoffice-4.4.0.3/vcl/inc/win/salprn.h
// Sortierte Kopien


4 / 13 | libreoffice-4.4.0.3/vcl/inc/win/wincomp.hxx
// Anpassungen fuer TypeChecking
// - ZMouse Erweiterungen -
// - SystemAgent Erweiterungen -
// - 5.0-Erweiterungen -


1 / 100 | libreoffice-4.4.0.3/vcl/inc/win/salgdi.h
// Linienbreite


1 / 9 | libreoffice-4.4.0.3/vcl/win/source/app/salshl.cxx
// Unsere DLL-Initialisierung


3 / 42 | libreoffice-4.4.0.3/vcl/win/source/window/salobj.cxx
// Dazugehoerenden Frame suchen
// Nur 0-9 und A-Z
// Window-Instanz am Windowhandle speichern


1 / 14 | libreoffice-4.4.0.3/vcl/headless/svpprn.cxx
// Neuen Eintrag anlegen


1 / 42 | libreoffice-4.4.0.3/vcl/unx/kde/fpicker/kdefilepicker.cxx
// From Martin Kretzschmar:


1 / 5 | libreoffice-4.4.0.3/vcl/qa/cppunit/graphicfilter/filters-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 91 | libreoffice-4.4.0.3/vcl/generic/print/genprnpsp.cxx
// Neuen Eintrag anlegen


1 / 8 | libreoffice-4.4.0.3/vcl/source/app/idlemgr.cxx
// Liste loeschen


1 / 35 | libreoffice-4.4.0.3/vcl/source/app/help.cxx
// Welche Position vom Rechteck?


1 / 7 | libreoffice-4.4.0.3/vcl/source/app/dbggui.cxx
// Daten speichern


1 / 6 | libreoffice-4.4.0.3/vcl/source/edit/textdat2.hxx
// fuer geschickte Formatierung/Ausgabe


1 / 38 | libreoffice-4.4.0.3/vcl/source/edit/vclmedit.cxx
// Es gibt kein Notify bei Breiten-Aenderung...


2 / 21 | libreoffice-4.4.0.3/vcl/source/opengl/OpenGLHelper.cxx
// Compile Vertex Shader
// Check Vertex Shader


1 / 179 | libreoffice-4.4.0.3/vcl/source/fontsubset/sft.cxx
/* MS Wansung           */


1 / 153 | libreoffice-4.4.0.3/vcl/source/font/PhysicalFontCollection.cxx
// TODO: calculate name matching score using e.g. Levenstein distance


2 / 218 | libreoffice-4.4.0.3/vcl/source/filter/sgvtext.cxx
/* ^S extra-character, separates e.g. "schiff-fahrt"  */
// Justify muss spaetestens am Anfang des Absatzes stehen


1 / 242 | libreoffice-4.4.0.3/vcl/source/filter/sgvspln.cxx
/*      upper    ) overwritten                                        */


1 / 50 | libreoffice-4.4.0.3/vcl/source/gdi/bitmap.cxx
// ggf. noch mittlere Zeile horizontal spiegeln


1 / 713 | libreoffice-4.4.0.3/vcl/source/gdi/pdfwriter_impl.cxx
// emit encoding dict


1 / 8 | libreoffice-4.4.0.3/vcl/source/gdi/octree.cxx
// ggf. neuen Knoten erzeugen


1 / 48 | libreoffice-4.4.0.3/vcl/source/gdi/pngwrite.cxx
// 0 oder 4;


1 / 198 | libreoffice-4.4.0.3/vcl/source/window/winproc.cxx
// FocusWindow umsetzen


2 / 60 | libreoffice-4.4.0.3/vcl/source/window/menufloatingwindow.cxx
// ggf. gescrollt.
// nRet != 0, wenn es waerend Activate() abgeschossen wurde...


1 / 435 | libreoffice-4.4.0.3/vcl/source/window/window.cxx
// Flags fuer GetFocus()-Aufruf


1 / 44 | libreoffice-4.4.0.3/vcl/source/window/window2.cxx
// Bei Button-Repeat muessen wir den Timeout umsetzen


2 / 22 | libreoffice-4.4.0.3/vcl/source/window/cursor.cxx
// Ist Cursor aktuell sichtbar
// Zugeordnetes Windows


1 / 11 | libreoffice-4.4.0.3/vcl/source/window/wrkwin.cxx
// Ist es das Applikationsfenster, dann beende die Applikation


1 / 426 | libreoffice-4.4.0.3/vcl/source/window/toolbox.cxx
// Item suchen, das geklickt wurde


1 / 31 | libreoffice-4.4.0.3/vcl/source/window/split.cxx
// Start-Positon ermitteln


12 / 125 | libreoffice-4.4.0.3/vcl/source/control/edit.cxx
// - Bei Tracking-Cancel DefaultSelection wieder herstellen
// loeschen moeglich?
// beides negativ...
// dann nicht sichtbar...
// Range wird in ImplSetSelection geprueft...
// Wegen vertikaler Zentrierung...
// Inhalt
// Nur das SubEdit hat den BEAM...
// Kein Mehrfach D&D
// Nur wenn Maus in der Selektion...
// Vor D&D Tracking ausschalten
// Alten Cursor wegzeichnen...


4 / 128 | libreoffice-4.4.0.3/vcl/source/control/button.cxx
// kein Image-RadioButton
// TabStop-Flag richtig mitfuehren
// TabStop-Flag richtig mitfuehren
/* da ansonsten im Writer die Control zu weit oben haengen
        aSize.Width() += 2;
        aSize.Height() += 2;
*/


1 / 64 | libreoffice-4.4.0.3/vcl/quartz/salbmp.cxx
//  || maContextBuffer.get() && (maUserBuffer.get() != maContextBuffer.get()) )


1 / 289 | libreoffice-4.4.0.3/sfx2/source/doc/objstor.cxx
// Name vor ConvertFrom setzen, damit GetSbxObject() schon funktioniert


1 / 16 | libreoffice-4.4.0.3/sfx2/source/doc/new.cxx
// erfragt werden


1 / 83 | libreoffice-4.4.0.3/sfx2/source/appl/newhelp.cxx
// found keyword -> open it


1 / 20 | libreoffice-4.4.0.3/sfx2/source/appl/shutdowniconunx.cxx
//rpm --upgrade and libs being overwritten


1 / 51 | libreoffice-4.4.0.3/sfx2/source/appl/appserv.cxx
// aus verschachtelten Requests nach 100ms nochmal probieren


1 / 16 | libreoffice-4.4.0.3/sfx2/source/appl/linksrc.cxx
// Secure against being destroyed in Handler


2 / 8 | libreoffice-4.4.0.3/sfx2/source/appl/appdispatchprovider.cxx
// Gruppe anw"ahlen ( Gruppe 0 ist intern )
// Gruppe anw"ahlen ( Gruppe 0 ist intern )


1 / 34 | libreoffice-4.4.0.3/sfx2/source/appl/linkmgr2.cxx
// being destroyed at re-connection.


2 / 23 | libreoffice-4.4.0.3/sfx2/source/appl/appinit.cxx
// Subklasse initialisieren
// App-Dispatcher aufbauen


1 / 100 | libreoffice-4.4.0.3/sfx2/source/view/ipclient.cxx
/*DisableReschedule*/


3 / 128 | libreoffice-4.4.0.3/sfx2/source/view/viewsh.cxx
// Jetzt schon DONE aufrufen, da die Argumente evtl. einen Pool
// benutzen, der demn"achst weg ist
// ausfuehren


1 / 137 | libreoffice-4.4.0.3/sfx2/source/dialog/templdlg.cxx
// automatisch


1 / 91 | libreoffice-4.4.0.3/sfx2/source/dialog/tabdlg.cxx
// Tab Page schon da?


1 / 11 | libreoffice-4.4.0.3/sfx2/source/dialog/styfitem.cxx
// Implementierung des Resource-Konstruktors


1 / 160 | libreoffice-4.4.0.3/sfx2/source/control/dispatch.cxx
// don't consider shells if "Hidden" oder "Quiet"


1 / 83 | libreoffice-4.4.0.3/sfx2/source/menu/virtmenu.cxx
// ggf. Pick-Menu erzeugen


1 / 16 | libreoffice-4.4.0.3/sfx2/source/bastyp/frmhtmlw.cxx
// Titel (auch wenn er leer ist)


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-ppm-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-tga-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-tiff-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-pcx-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-met-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-psd-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-eps-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-pict-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-pcd-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-dxf-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


1 / 5 | libreoffice-4.4.0.3/filter/qa/cppunit/filters-ras-test.cxx
/**
     * Ensure CVEs remain unbroken
     */


3 / 159 | libreoffice-4.4.0.3/filter/source/msfilter/util.cxx
// Output ppNext (if ppNext != 0) Suchbeginn fuer naechsten Parameter bzw. 0
//             ansonsten Anfang des Paramters bzw. der Zeichenkette
// { "fontwork-triangle-down", "textTriangleInverted" },


3 / 630 | libreoffice-4.4.0.3/filter/source/msfilter/msdffimp.cxx
// Vertical, non-@, oben -> unten
// Import-Record-Liste ergaenzen
// 3-d Visions Corp / Peter Hirsch / 310-325-1339


10 / 407 | libreoffice-4.4.0.3/filter/source/msfilter/svdfppt.cxx
// Vertical, non-@, oben -> unten
// follow master colorscheme?
// resgister current color scheme
//sal_uLong nEscherObjectEnd = aEscherObjectHd.GetRecEndFilePos();
//DffRecordHeader aEscherPropertiesHd;
// Zeichenattribute
// Exception: Template 5, 6 (MasterTitle Title und SubTitle)
// Vertical, non-@, above -> below
// Textverankerung lesen
// Textverankerung lesen


4 / 249 | libreoffice-4.4.0.3/filter/source/msfilter/escherex.cxx
// case GFX_LINK_TYPE_NATIVE_BMP : p_EscherBlibEntry->meBlibType = DIB; break;
// nRule =  0 ->Top         0 ->Top         nRule = Index auf ein (Poly)Polygon Punkt
// Zeiger auf innere sequences holen
// record header wird spaeter geschrieben


1 / 189 | libreoffice-4.4.0.3/filter/source/graphicfilter/epict/epict.cxx
// Source-Rectangle schreiben:


1 / 20 | libreoffice-4.4.0.3/filter/source/graphicfilter/eras/eras.cxx
//=================== Methoden von RASWriter ==============================


3 / 160 | libreoffice-4.4.0.3/filter/source/graphicfilter/eps/eps.cxx
//========================== Methoden von PSWriter ==========================
// PostScript kennt kein FontAlignment
//================== GraphicExport - die exportierte Funktion ================


1 / 165 | libreoffice-4.4.0.3/filter/source/graphicfilter/idxf/dxfentrd.hxx
// ENDBLK, ENDSEC oder EOF (of group 0).


1 / 7 | libreoffice-4.4.0.3/filter/source/graphicfilter/idxf/idxf.cxx
//================== GraphicImport - die exportierte Funktion ================


2 / 18 | libreoffice-4.4.0.3/filter/source/graphicfilter/idxf/dxfblkrd.hxx
//---------------- Ein Block (= Menge von Entities) --------------------------
//---------------- Eine Menge von Bloecken -----------------------------------


1 / 35 | libreoffice-4.4.0.3/filter/source/graphicfilter/idxf/dxfgrprd.hxx
// Max Stringlaenge (ohne die 0)


1 / 24 | libreoffice-4.4.0.3/filter/source/graphicfilter/egif/egif.cxx
// alles rausschreiben


4 / 433 | libreoffice-4.4.0.3/filter/source/graphicfilter/eos2met/eos2met.cxx
// Nanu! witziger-weise fehlt obiger Abschnitt in den Metadateien. Also lassen wir ihn auch weg
// (wobei die Sache ggf. in mehrere 'Graphics Data Fields' aufgeteilt
// wird, per Methode WillWriteOrder(..))
// Und schreiben


1 / 308 | libreoffice-4.4.0.3/filter/source/graphicfilter/ipict/ipict.cxx
// Initial number format von pPict.


1 / 61 | libreoffice-4.4.0.3/filter/source/graphicfilter/ipsd/ipsd.cxx
// Die einzulesende PSD-Datei


3 / 49 | libreoffice-4.4.0.3/filter/source/graphicfilter/itga/itga.cxx
//=================== Methoden von TGAReader ==============================
// Kopf einlesen:
//================== GraphicImport - die exportierte Funktion ================


1 / 13 | libreoffice-4.4.0.3/filter/source/graphicfilter/eppm/eppm.cxx
// Die auszugebende PPM-Datei


1 / 13 | libreoffice-4.4.0.3/filter/source/graphicfilter/epgm/epgm.cxx
//=================== Methoden von PGMWriter ==============================


8 / 26 | libreoffice-4.4.0.3/filter/source/graphicfilter/iras/iras.cxx
// Die einzulesende RAS-Datei
//=================== Methoden von RASReader ==============================
// Kopf einlesen:
// RAW Colormap wird geskipped
// RGB koennen wir auslesen
// alles andere ist kein standard
// Bitmap-Daten einlesen
//================== GraphicImport - die exportierte Funktion ================


1 / 119 | libreoffice-4.4.0.3/filter/source/graphicfilter/itiff/itiff.cxx
// Schleife ueber Tags:


1 / 17 | libreoffice-4.4.0.3/filter/source/graphicfilter/expm/expm.cxx
//=================== Methoden von XPMWriter ==============================


2 / 18 | libreoffice-4.4.0.3/filter/source/graphicfilter/icgm/cgm.hxx
// Ausgabe Groesse in 1/100TH mm
// auf das gemappt wird


1 / 130 | libreoffice-4.4.0.3/filter/source/svg/svgreader.cxx
// children processing done


1 / 150 | libreoffice-4.4.0.3/filter/source/svg/svgwriter.cxx
// superscript, subscript, list item numbering


1 / 54 | libreoffice-4.4.0.3/filter/source/t602/t602filter.hxx
// 0     formatting dash


1 / 52 | libreoffice-4.4.0.3/chart2/inc/ChartModel.hxx
//comprehends XCloseBroadcaster


1 / 7 | libreoffice-4.4.0.3/chart2/source/view/inc/AbstractShapeFactory.hxx
// <rsc/rsc-vcl-shared-types.hxx>


1 / 76 | libreoffice-4.4.0.3/chart2/source/view/main/VLegend.cxx
// ::com::sun::star::chart::ChartLegendExpansion_BALANCED


1 / 160 | libreoffice-4.4.0.3/chart2/source/view/charttypes/Splines.cxx
/** @descr this function corresponds to the algorithm 4.76 in [2] and
        theorem 5.3.7 in [3]

        [2] Engeln-MÃ¼llges, Gisela: Numerik-Algorithmen: Verfahren, Beispiele, Anwendungen
            Springer, Berlin; Auflage: 9., Ã¼berarb. und erw. A. (8. Dezember 2004)
            Section 4.10.2, page 175

        [3] Hanrath, Wilhelm: Mathematik III / Numerik, Vorlesungsskript zur
            Veranstaltung im WS 2007/2008
            Fachhochschule Aachen, 2009-09-19
            Numerik_01.pdf, downloaded 2011-04-19 via
            http://www.fh-aachen.de/index.php?id=11424&no_cache=1&file=5016&uid=44191
            Section 5.3, page 129
    */


7 / 119 | libreoffice-4.4.0.3/chart2/source/view/axes/ScaleAutomatism.cxx
//scaling dependent
//scaling dependent
//scaling dependent
//scaling dependent
//scaling dependent
//scaling dependent
//scaling dependent


1 / 105 | libreoffice-4.4.0.3/chart2/source/controller/main/ChartController_Window.cxx
// default 1 mm in each direction


9 / 50 | libreoffice-4.4.0.3/chart2/source/controller/itemsetwrapper/SchWhichPairs.hxx
//     3 -     3  sch/schattr.hxx
/*  3994 -  4037  editeng/eeitem.hxx */
/*     1 -     2  sch/schattr.hxx*/
/*    59 -    68  sch/schattr.hxx*/
/*    94          sch/schattr.hxx*/
/*    97          sch/schattr.hxx*/
/*    69          sch/schattr.hxx*/
//    45 -    52  sch/schattr.hxx
//    45 -    52  sch/schattr.hxx


1 / 29 | libreoffice-4.4.0.3/oox/source/drawingml/lineproperties.cxx
// convert preset dash or custom dash


1 / 9 | libreoffice-4.4.0.3/oox/source/drawingml/textcharacterproperties.cxx
// symbolfont, will now be ... textrun.cxx ... ausgewertet !!!i#113673


1 / 22 | libreoffice-4.4.0.3/oox/source/drawingml/linepropertiescontext.cxx
// CT_PresetLineDashProperties


2 / 13 | libreoffice-4.4.0.3/oox/source/vml/vmlshapecontainer.cxx
// search deep in child shapes
// search deep in child shapes


1 / 67 | libreoffice-4.4.0.3/basctl/source/basicide/moduldlg.cxx
// Nur Lib selektiert


1 / 76 | libreoffice-4.4.0.3/drawinglayer/source/primitive2d/polygonprimitive2d.cxx
// add shaft


1 / 309 | libreoffice-4.4.0.3/drawinglayer/source/processor2d/vclmetafileprocessor2d.cxx
// copy dash array


2 / 169 | libreoffice-4.4.0.3/drawinglayer/source/processor2d/vclpixelprocessor2d.cxx
// hatch painting, use decomposition
// get hatch style


1 / 46 | libreoffice-4.4.0.3/framework/inc/helper/statusindicatorfactory.hxx
/** enable/disable rescheduling. Default=enabled*/


1 / 710 | libreoffice-4.4.0.3/framework/source/services/frame.cxx
/*DisableReschedule*/


1 / 22 | libreoffice-4.4.0.3/framework/source/services/dispatchhelper.cxx
// search dispatcher


1 / 30 | libreoffice-4.4.0.3/framework/source/uielement/controlmenucontroller.cxx
// das entsprechende Image dran


1 / 80 | libreoffice-4.4.0.3/framework/source/uiconfiguration/uiconfigurationmanager.cxx
// commit element type storage


1 / 111 | libreoffice-4.4.0.3/framework/source/uiconfiguration/moduleuiconfigurationmanager.cxx
// commit element type storage


2 / 68 | libreoffice-4.4.0.3/framework/source/uiconfiguration/imagemanagerimpl.cxx
// Commit user image storage
// Commit user image storage


1 / 8 | libreoffice-4.4.0.3/extensions/workben/pythontest.cxx
// Methoden von XInterface


1 / 7 | libreoffice-4.4.0.3/extensions/test/ole/EventListenerSample/EventListener/EvtListener.h
// EvtListener.h : Deklaration von CEvtListener


1 / 5 | libreoffice-4.4.0.3/extensions/test/ole/EventListenerSample/EventListener/EvtListener.cpp
// EvtListener.cpp : Implementierung von CEvtListener


1 / 13 | libreoffice-4.4.0.3/extensions/source/bibliography/toolbar.cxx
// vor SetDropMode (SetDropMode ruft SetItemImage)


1 / 9 | libreoffice-4.4.0.3/extensions/source/plugin/inc/plugin/unx/plugcon.hxx
/* Standard Name-String definitions*/


1 / 17 | libreoffice-4.4.0.3/extensions/source/plugin/unx/unxmgr.cxx
//       ~/.netscape/plugins und NPX_PLUGIN_PATH


1 / 206 | libreoffice-4.4.0.3/extensions/source/propctrlr/formcomponenthandler.cxx
// Auslesen des ListSourceTypes


1 / 63 | libreoffice-4.4.0.3/codemaker/source/javamaker/classfile.cxx
// invokeinterface <indexbyte1> <indexbyte2> <nargs> 0:


1 / 222 | libreoffice-4.4.0.3/starmath/source/visitors.cxx
// auf Pixelkoordinaten runden


1 / 135 | libreoffice-4.4.0.3/starmath/source/dialog.cxx
//! aufpassen: richtig runden!


1 / 7 | libreoffice-4.4.0.3/sd/qa/unit/filters-test.cxx
// Ensure CVEs remain unbroken


1 / 48 | libreoffice-4.4.0.3/sd/source/core/stlsheet.cxx
// Hole Wert aus ItemSet


15 / 266 | libreoffice-4.4.0.3/sd/source/filter/eppt/epptso.cxx
// oben, links, rechts, unten ????
// mpPptEscherEx->EnterGroup( 0,0 );
// nGroupLevel = mpPptEscherEx->GetGroupLevel();
// mpPptEscherEx->EnterGroup( &maRect,0 );
// mpPptEscherEx->EnterGroup( 0,0 );
// nGroupLevel = mpPptEscherEx->GetGroupLevel();
// mpPptEscherEx->EnterGroup( 0,0 );
// nGroupLevel = mpPptEscherEx->GetGroupLevel();
// mpPptEscherEx->EnterGroup( 0,0 );
// nGroupLevel = mpPptEscherEx->GetGroupLevel();
// mpPptEscherEx->EnterGroup( 0,0 );
// nGroupLevel = mpPptEscherEx->GetGroupLevel();
// mpPptEscherEx->SetGroupSnapRect( nGroupLevel, maRect );
// mpPptEscherEx->SetGroupLogicRect( nGroupLevel, maRect );
// mpPptEscherEx->LeaveGroup();


1 / 23 | libreoffice-4.4.0.3/sd/source/ui/inc/fupoor.hxx
// Mouse- & Key-Events; Returnwert=sal_True: Event wurde bearbeitet


1 / 84 | libreoffice-4.4.0.3/sd/source/ui/dlg/navigatr.cxx
// Nur normale Seiten


2 / 26 | libreoffice-4.4.0.3/sd/source/ui/dlg/dlgfield.cxx
// Die, 13.Februar 1996
// Dienstag, 13.Februar 1996


2 / 29 | libreoffice-4.4.0.3/sd/source/ui/app/sdpopup.cxx
// Die, 13.Februar 1996
// Dienstag, 13.Februar 1996


2 / 15 | libreoffice-4.4.0.3/sd/source/ui/remotecontrol/ImagePreparer.cxx
//     OUStringBuffer aStrBuffer;
//     ::sax::Converter::encodeBase64( aStrBuffer, aTemp );


1 / 205 | libreoffice-4.4.0.3/sd/source/ui/remotecontrol/mDNSResponder/dns_sd.h
/* Kitchen sink (experimental) */


3 / 257 | libreoffice-4.4.0.3/sd/source/ui/remotecontrol/mDNSResponder/DebugServices.c
// generating decimal numbers, hexdecimal numbers, IP addresses, domain name strings, etc.
// Mach Errors
// Mach OSReturn Errors


1 / 41 | libreoffice-4.4.0.3/sd/source/ui/func/fuinsfil.cxx
// einlesen wie im Zeichenmodus


4 / 107 | libreoffice-4.4.0.3/sd/source/ui/func/fusel.cxx
// Scroll nach oben
// Scroll nach unten
// Scroll nach links
// Scroll nach rechts


4 / 33 | libreoffice-4.4.0.3/sd/source/ui/func/fuediglu.cxx
// Scroll nach oben
// Scroll nach unten
// Scroll nach links
// Scroll nach rechts


1 / 58 | libreoffice-4.4.0.3/sd/source/ui/view/viewshe2.cxx
// kompatibel zum SdrOle2Obj


1 / 79 | libreoffice-4.4.0.3/sd/source/ui/view/sdview3.cxx
// (wg. Selection Manager bei Trustet Solaris)


1 / 110 | libreoffice-4.4.0.3/sd/source/ui/view/DocumentRenderer.cxx
// Untertitel vorhanden?


1 / 64 | libreoffice-4.4.0.3/sd/source/ui/slideshow/slideshow.cxx
// not overwritten.


1 / 27 | libreoffice-4.4.0.3/sd/source/ui/docshell/docshell.cxx
// setzt Filter zurueck


1 / 74 | libreoffice-4.4.0.3/sd/source/ui/slidesorter/view/SlideSorterView.cxx
// background buffer.


1 / 30 | libreoffice-4.4.0.3/sd/source/ui/sidebar/MasterPageContainerQueue.cxx
//===== MasterPageContainerQueue::RequestQueue ================================


1 / 185 | libreoffice-4.4.0.3/shell/source/win32/shlxthandler/util/utilities.cxx
// German (Liechtenstein)


1 / 176 | libreoffice-4.4.0.3/sal/qa/osl/socket/osl_StreamSocket.cxx
//t_print("# read buffer content: %s\n", pReadBuffer );


1 / 381 | libreoffice-4.4.0.3/sal/qa/osl/socket/osl_Socket.cxx
//t_print("# read buffer content: %s\n", pReadBuffer );


1 / 242 | libreoffice-4.4.0.3/sal/qa/osl/process/osl_Thread.cxx
// class schedule


1 / 15 | libreoffice-4.4.0.3/sal/rtl/strbuf.cxx
/*************************************************************************
 *  rtl_stringbuffer_newFromStringBuffer
 */


5 / 9 | libreoffice-4.4.0.3/sal/workben/testpip2.cxx
// eindeutiger Name fÃ¼r die Pipe
// erzeuge die Pipe
// empfange Daten vom Server
// Sende die Daten wieder zurÃ¼ck.
// schliesse die Pipe


5 / 8 | libreoffice-4.4.0.3/sal/workben/clipboardwben/testviewer/StdAfx.cpp
// stdafx.cpp : Quelltextdatei, die nur die Standard-Includes einbindet
//  TestWin32.pch ist die vorkompilierte Header-Datei
//  stdafx.obj enthält die vorkompilierte Typinformation
// ZU ERLEDIGEN: Verweis auf alle zusätzlichen Header-Dateien, die Sie in STDAFX.H
// und nicht in dieser Datei benötigen


7 / 14 | libreoffice-4.4.0.3/sal/workben/clipboardwben/testviewer/StdAfx.h
// stdafx.h : Include-Datei fÃ¼r Standard-System-Include-Dateien,
//  oder projektspezifische Include-Dateien, die hÃ¤ufig benutzt, aber
//      in unregelmÃ¤Ãigen AbstÃ¤nden geÃ¤ndert werden.
// Selten benutzte Teile der Windows-Header nicht einbinden
// Header-Dateien der C-Laufzeit
// ZU ERLEDIGEN: Verweisen Sie hier auf zusÃ¤tzliche Header-Dateien, die Ihr Programm benÃ¶tigt
// Microsoft Visual C++ fÃ¼gt zusÃ¤tzliche Deklarationen unmittelbar vor der vorherigen Zeile ein.


5 / 8 | libreoffice-4.4.0.3/sal/workben/clipboardwben/testpaste/StdAfx.cpp
// stdafx.cpp : Quelltextdatei, die nur die Standard-Includes einbindet
//  TestWin32.pch ist die vorkompilierte Header-Datei
//  stdafx.obj enthält die vorkompilierte Typinformation
// ZU ERLEDIGEN: Verweis auf alle zusätzlichen Header-Dateien, die Sie in STDAFX.H
// und nicht in dieser Datei benötigen


7 / 14 | libreoffice-4.4.0.3/sal/workben/clipboardwben/testpaste/StdAfx.h
// stdafx.h : Include-Datei fÃ¼r Standard-System-Include-Dateien,
//  oder projektspezifische Include-Dateien, die hÃ¤ufig benutzt, aber
//      in unregelmÃ¤Ãigen AbstÃ¤nden geÃ¤ndert werden.
// Selten benutzte Teile der Windows-Header nicht einbinden
// Header-Dateien der C-Laufzeit
// ZU ERLEDIGEN: Verweisen Sie hier auf zusÃ¤tzliche Header-Dateien, die Ihr Programm benÃ¶tigt
// Microsoft Visual C++ fÃ¼gt zusÃ¤tzliche Deklarationen unmittelbar vor der vorherigen Zeile ein.


7 / 14 | libreoffice-4.4.0.3/sal/workben/clipboardwben/testcopy/StdAfx.h
// stdafx.h : Include-Datei fÃ¼r Standard-System-Include-Dateien,
//  oder projektspezifische Include-Dateien, die hÃ¤ufig benutzt, aber
//      in unregelmÃ¤ssigen AbstÃ¤nden geandert werden.
// Selten benutzte Teile der Windows-Header nicht einbinden
// Header-Dateien der C-Laufzeit
// ZU ERLEDIGEN: Verweisen Sie hier auf zusÃ¤tzliche Header-Dateien, die Ihr Programm benÃ¶tigt
// Microsoft Visual C++ fÃ¼gt zusÃ¤tzliche Deklarationen unmittelbar vor der vorherigen Zeile ein.


1 / 90 | libreoffice-4.4.0.3/sal/textenc/tencinfo.cxx
/* Parttrenner gefunden */


3 / 81 | libreoffice-4.4.0.3/sal/textenc/textenc.cxx
/* 1-Byte, 0x00-0x7F ASCII ohne Ausnahme */
/* 1-Byte, 0x00-0x7F ASCII ohne Ausnahme, 0x80-0x9F Control-Caracter wie in Unicode */
/* 1-Byte, 0x00-0x7F ASCII ohne Ausnahme */


1 / 103 | libreoffice-4.4.0.3/sal/osl/unx/process.cxx
/* nice value + 15 (kernel scheduling prio)*/


2 / 233 | libreoffice-4.4.0.3/sal/osl/unx/socket.cxx
/* osl_Socket_OptionSndBuf      */
/* osl_Socket_OptionRcvBuf      */


1 / 106 | libreoffice-4.4.0.3/sal/osl/w32/thread.c
/* osl_scheduleThread */


2 / 386 | libreoffice-4.4.0.3/sal/osl/w32/socket.cxx
/* osl_Socket_OptionSndBuf */
/* osl_Socket_OptionRcvBuf */


1 / 4 | libreoffice-4.4.0.3/sal/osl/w32/secimpl.h
/* ts: Erweiterung um Fileserver-login */


1 / 65 | libreoffice-4.4.0.3/bridges/test/testcomp.cxx
// erst registrieren


1 / 13 | libreoffice-4.4.0.3/desktop/unx/source/pagein.c
/* do_pagein */


1 / 59 | libreoffice-4.4.0.3/desktop/unx/source/start.c
/* pagein */


1 / 12 | libreoffice-4.4.0.3/desktop/unx/source/args.c
/* pagein bits */


1 / 132 | libreoffice-4.4.0.3/desktop/source/deployment/registry/package/dp_package.cxx
// patch description:


1 / 178 | libreoffice-4.4.0.3/desktop/source/deployment/manager/dp_manager.cxx
//XExtensionManager.reinstallDeployedExtensions


1 / 259 | libreoffice-4.4.0.3/writerfilter/source/dmapper/ThemeTable.cxx
// lidGermanLiechtenstein


1 / 12 | libreoffice-4.4.0.3/sw/inc/fmturl.hxx
// URL, ServerMap und ClientMap


1 / 39 | libreoffice-4.4.0.3/sw/inc/modcfg.hxx
//Revision/TextDisplay/Insert/Attribute  // Redlining: Author-Zeichenattribute


2 / 30 | libreoffice-4.4.0.3/sw/inc/pagedesc.hxx
///< Because of grid alignment (Registerhaltigkeit).
///< For grid alignment (Registerhaltigkeit).


1 / 85 | libreoffice-4.4.0.3/sw/inc/tox.hxx
// Absatzlayout beachten


1 / 12 | libreoffice-4.4.0.3/sw/inc/fmtftn.hxx
///< Automatische Nummerierung


1 / 91 | libreoffice-4.4.0.3/sw/inc/swtable.hxx
// steht. rBoxes auch als Return-Wert, um es gleich weiter zu benutzen


1 / 25 | libreoffice-4.4.0.3/sw/inc/viscrs.hxx
// For Table- und normal cursors.


1 / 53 | libreoffice-4.4.0.3/sw/inc/dcontact.hxx
/// virtuelle Methoden von SwClient


1 / 49 | libreoffice-4.4.0.3/sw/inc/format.hxx
/** Das Doc wird jetzt am SwAttrPool gesetzt. Dadurch hat man es immer
       im Zugriff. */


2 / 145 | libreoffice-4.4.0.3/sw/inc/fesh.hxx
/// Get FlyFrameFormat; fuer UI Macro Anbindung an Flys
//Sortieren.


1 / 11 | libreoffice-4.4.0.3/sw/qa/core/filters-test.cxx
// Ensure CVEs remain unbroken


1 / 60 | libreoffice-4.4.0.3/sw/qa/extras/ooxmlexport/ooxmlexport5.cxx
//            "xmlns:ns0='http://purl.org/dc/elements/1.1/' xmlns:ns1='http://schemas.openxmlformats.org/package/2006/metadata/core-properties'");


1 / 180 | libreoffice-4.4.0.3/sw/qa/extras/ooxmlexport/ooxmlsdrexport.cxx
// fourth shape: wireframe


1 / 68 | libreoffice-4.4.0.3/sw/source/core/undo/rolbck.cxx
//  - NoLineBreak, NoHypen, Inserted, Deleted


1 / 4 | libreoffice-4.4.0.3/sw/source/core/inc/unofldmid.h
//Abbildung der Properties auf den Descriptor


1 / 4 | libreoffice-4.4.0.3/sw/source/core/inc/noteurl.hxx
// globale Variable, in NoteURL.Cxx angelegt


1 / 4 | libreoffice-4.4.0.3/sw/source/core/inc/swfntcch.hxx
// AttributSet/Font-Cache, globale Variable, in FontCache.Cxx angelegt


1 / 39 | libreoffice-4.4.0.3/sw/source/core/inc/swblocks.hxx
// Name eines Textblocks:


3 / 7 | libreoffice-4.4.0.3/sw/source/core/inc/pamtyp.hxx
// Funktions-Deklarationen fuer die Move/Find-Methoden vom SwPaM
// Funktionsdefinitionen fuer die SwCrsrShell
// Funktionsdefinitionen fuers Suchen


1 / 103 | libreoffice-4.4.0.3/sw/source/core/doc/docredln.cxx
// Inhalt wurde eingefuegt


5 / 474 | libreoffice-4.4.0.3/sw/source/core/doc/DocumentContentOperationsManager.cxx
// dann nur den Content anpassen
//JP 06.01.98: MUSS noch optimiert werden!!!
//JP 06.01.98: MUSS noch optimiert werden!!!
//JP 06.01.98: MUSS noch optimiert werden!!!
//JP 06.01.98: MUSS noch optimiert werden!!!


2 / 281 | libreoffice-4.4.0.3/sw/source/core/docnode/nodes.cxx
// EndNode loeschen
// SttNode loeschen


1 / 157 | libreoffice-4.4.0.3/sw/source/core/unocore/unofield.cxx
// oder so


1 / 146 | libreoffice-4.4.0.3/sw/source/core/unocore/unotext.cxx
//SectionNodes ueberspringen


1 / 18 | libreoffice-4.4.0.3/sw/source/core/unocore/unosrch.cxx
//  bInSel: 1;  // wie geht das?


2 / 55 | libreoffice-4.4.0.3/sw/source/core/unocore/unosect.cxx
//das muss jetzt true liefern
// Undo-Klammerung hier beenden


2 / 201 | libreoffice-4.4.0.3/sw/source/core/edit/autofmt.cxx
// das wars
// beachte: Sonderfall Symbolfonts !!!


1 / 62 | libreoffice-4.4.0.3/sw/source/core/edit/editsh.cxx
// einfach Selection -> Text ueberpruefen


1 / 35 | libreoffice-4.4.0.3/sw/source/core/edit/edfld.cxx
// Gleiche ResId -> Index erhoehen


2 / 26 | libreoffice-4.4.0.3/sw/source/core/edit/edtab.cxx
// setze die DDE-Tabelle
// Keine Arme keine Kekse


19 / 30 | libreoffice-4.4.0.3/sw/source/core/text/porexp.cxx
// Nicht etwa: return 0 != rTxt.Len();
// Weil: leere Felder ersetzen CH_TXTATR gegen einen Leerstring
// 5010: Exp und Tabs
// So komisch es aussieht, die Abfrage auf GetLen() muss wegen der
// false returnen wegen SetFull ...
// nicht Init(), weil wir Hoehe und Ascent brauchen
// 5497: Es gibt schon Gemeinheiten auf der Welt...
// Wenn eine Zeile voll mit HardBlanks ist und diese ueberlaeuft,
// dann duerfen keine Underflows generiert werden!
// Komplikationen bei Flys...
// Nur noch BlankPortions unterwegs
// Wenn vor uns ein Blank ist, brauchen wir kein Underflow ausloesen,
// wenn hinter uns ein Blank ist, brauchen wir kein Underflow weiterreichen
//Hier wird ueberprueft, ob es in dieser Zeile noch sinnvolle Umbrueche
//gibt, Blanks oder Felder etc., wenn nicht, kein Underflow.
//Wenn Flys im Spiel sind, lassen wir das Underflow trotzdem zu.
// 7771: Underflows weiterreichen und selbst ausloesen!
// Nicht zu fassen: PostIts sind immer zu sehen.
// 32749: PostIts sollen keine Auswirkung auf Zeilenhoehe etc. haben


1 / 224 | libreoffice-4.4.0.3/sw/source/core/text/txtfly.cxx
// Optimierung


5 / 88 | libreoffice-4.4.0.3/sw/source/core/text/txtdrop.cxx
// Und zwar immer, und nie mit dem bestehenden ClipRect
// verrechnen, weil dies auf die Zeile eingestellt sein koennte.
// Das machen, was man sonst nur macht ...
// Alte Stelle wiederfinden!
// MarginPortion und Adjustment!


35 / 396 | libreoffice-4.4.0.3/sw/source/core/text/itrform2.cxx
// Flies + Initialen werden nicht beim Underflow mitgenommen
// Wenn der Text an den Fly gestossen ist, oder wenn
// der Fly als erstes drankommt, weil er ueber dem linken
// Wenn IsFull() und kein GetFly() vorhanden ist, gibt's
// naturgemaesz eine 0.
// Ein fieser Sonderfall: ein Rahmen ohne Umlauf kreuzt den
// Ftn-Bereich. Wir muessen die Ftn-Portion als Zeilenrest
// bekanntgeben, damit SwTxtFrm::Format nicht abbricht
// (die Textmasse wurde ja durchformatiert).
// Wenn die naechste Zeile mit einem Rest eines Feldes beginnt,
// jetzt aber kein Rest mehr anliegt,
// muss sie auf jeden Fall neu formatiert werden!
// 5010: Tabs und Felder
/* Wir holen uns nocheinmal cChar, um sicherzustellen, dass das
             * Tab jetzt wirklich ansteht und nicht auf die naechste Zeile
             * gewandert ist ( so geschehen hinter Rahmen ).
             * Wenn allerdings eine FldPortion im Rest wartet, muessen wir
             * das cChar natuerlich aus dem Feldinhalt holen, z.B. bei
             * DezimalTabs und Feldern (22615)
            */
// Der Font wird im Outputdevice eingestellt,
// der Ascent und die Hoehe werden berechnet.
// In CalcFlyWidth wird Width() verkuerzt, wenn eine FlyPortion vorliegt.
// Man darf nicht vergessen, dass pCurr als GetLast() vernuenftige
// Werte bereithalten muss:
// Recycling muss bei geaenderter Zeilenhoehe unterdrueckt werden
// und auch bei geaendertem Ascent (Absenken der Grundlinie).
// Hier folgt bald die Unterlaufpruefung.
// bBuild entscheidet, ob noch eine Ehrenrunde gedreht wird
//geaenderte Zeilenhoehe => kein Recycling
// alle weiteren Zeilen muessen gepaintet und, wenn Flys im Spiel sind
// auch formatiert werden.
// Das Dummyflag besitzen Zeilen, die nur Flyportions enthalten, diese
// sollten kein Register etc. beachten. Dummerweise hat kann es eine leere
// Zeile am Absatzende geben (bei leeren Abs?tzen oder nach einem
// Shift-Return), die das Register durchaus beachten soll.
// 50% ist das Minimum, bei 0% schalten wir auf
// den Defaultwert 100% um ...
// 3260, 3860: Fly auf jeden Fall loeschen!
// ????: Blank in der letzten Masterzeile (blocksat.sdw)
// Schon wieder ein Sonderfall: unsichtbare SoftHyphs


4 / 56 | libreoffice-4.4.0.3/sw/source/core/text/porfly.cxx
// Da die FlyCnt nicht an der Seite haengen, wird ihr
// GetCrsrOfst() nicht gerufen. Um die Layoutseite
// von unnoetiger Verwaltung zu entlasten, ruft der Absatz
// das GetCrsrOfst des FlyFrm, wenn es erforderlich ist.


119 / 181 | libreoffice-4.4.0.3/sw/source/core/text/txtftn.cxx
// Sucht innerhalb einer Master-Follow-Kette den richtigen TxtFrm zum SwTxtFtn
// Ermittelt die max. erreichbare Hoehe des TxtFrm im Ftn-Bereich.
// Sie wird eingeschraenkt durch den unteren Rand der Zeile mit
// der Ftn-Referenz.
// So komisch es aussehen mag: Die erste Ftn auf der Seite darf sich
// nicht mit der Ftn-Referenz beruehren, wenn wir im Ftn-Bereich Text
// eingeben.
//Hoehe innerhalb des Cont, die ich mir 'eh noch genehmigen darf.
//Wachstumspotential den Containers.
// Erstmal feststellen, ob wir in einem FtnFrm stehen:
// Zum Vorgaenger-FtnFrm
// Wir loeschen nicht, sondern wollen die Ftn verschieben.
// Drei Faelle koennen auftreten:
// 1) Es gibt weder Follow noch PrevFollow
//    -> RemoveFtn()  (vielleicht sogar ein OSL_ENSURE(wert)
// 2) nStart > GetOfst, ich habe einen Follow
// 3) nStart < GetOfst, ich bin ein Follow
// beide muessen auf einer Seite/in einer Spalte stehen.
//Nicht ummelden sondern immer Moven.
// Wir bringen die Oszillation zum stehen:
// Folgendes Problem: Aus dem FindBreak heraus wird das RemoveFtn aufgerufen,
// weil die letzte Zeile an den Follow abgegeben werden soll. Der Offset
// des Follows ist aber veraltet, er wird demnaechst gesetzt. CalcFntFlag ist
// auf einen richtigen Follow-Offset angewiesen. Deshalb wird hier kurzfristig
// der Follow-Offset manipuliert.
// false, wenn irgendetwas schief gegangen ist.
// Es gibt eigentlich nur zwei Moeglichkeiten:
// a) Die Ftn ist bereits vorhanden
// => dann wird sie gemoved, wenn ein anderer pSrcFrm gefunden wurde
// b) Die Ftn ist nicht vorhanden
// => dann wird sie fuer uns angelegt.
// Ob die Ftn schliesslich auf unserer Spalte/Seite landet oder nicht,
// spielt in diesem Zusammenhang keine Rolle.
// Optimierungen bei Endnoten.
// Noch ein Problem: wenn die Deadline im Ftn-Bereich liegt, muss die
// Ftn verschoben werden.
// Wir brauchen immer einen Boss (Spalte/Seite)
//Ftn kann beim Follow angemeldet sein.
// Es wurde ueberhaupt keine Ftn gefunden.
// Ref und Ftn sind auf der selben Seite/Spalte.
//Wenn die Fussnote bei einem Follow angemeldet ist, so ist
//es jetzt an der Zeit sie umzumelden.
//Es steht Platz zur Verfuegung, also kann die Fussnote evtl.
//wachsen.
//Damit uns nix durch die Lappen geht.
// Ref und Ftn sind nicht auf einer Seite, Move-Versuch ist noetig.
// Wenn unser Boss in einem spaltigen Bereich sitzt, es aber auf
// der Seite schon einen FtnContainer gibt, hilft nur die brutale
// Die brutale Loesung: Fussnote entfernen und appenden.
// Es muss SetFtnDeadLine() gerufen werden, weil nach
// RemoveFtn die nMaxFtnHeight evtl. besser auf unsere Wuensche
// eingestellt werden kann.
// In spaltigen Bereichen, die noch nicht bis zum Seitenrand gehen,
// ist kein RearrangeFtns sinnvoll, da der Fussnotencontainer noch
// nicht kalkuliert worden ist.
// Umgebung validieren, um Oszillationen zu verhindern.
// pFtnFrm kann sich durch Calc veraendert haben ...
// Die Portion fuer die Ftn-Referenz im Text
//6995: Wir frischen nur auf. Das Connect tut fuer diesen Fall nix
//Brauchbares, sondern wuerde stattdessen fuer diesen Fall meist die
//Ftn wegwerfen und neu erzeugen.
// Wir erkundigen uns, ob durch unser Append irgendeine
// Fussnote noch auf der Seite/Spalte steht. Wenn nicht verschwindet
// auch unsere Zeile. Dies fuehrt zu folgendem erwuenschten
// Verhalten: Ftn1 pass noch auf die Seite/Spalte, Ftn2 nicht mehr.
// Also bleibt die Ftn2-Referenz auf der Seite/Spalte stehen. Die
// Fussnote selbst folgt aber erst auf der naechsten Seite/Spalte.
// Ausnahme: Wenn keine weitere Zeile auf diese Seite/Spalte passt,
// so sollte die Ftn2-Referenz auch auf die naechste wandern.
// Wenn der Boss in einem Bereich liegt, kann es sich nur um eine
// Spalte dieses Bereichs handeln. Wenn dies nicht die erste Spalte
// ist, duerfen wir ausweichen
// Es darf keine Fussnotencontainer in spaltigen Bereichen und
// gleichzeitig auf der Seite/Seitenspalte geben
// liegt unser Container in einem (spaltigen) Bereich?
// Ist dies die letzte passende Zeile?
// Wir sind in der letzte Zeile und die Fussnote
// ist auf eine andere Seite gewandert, dann wollen
// wir mit ...
// Endlich: FtnPortion anlegen und raus hier...
// Die Portion fuer die Ftn-Nummerierung im Ftn-Bereich
// Aha, wir sind also im Fussnotenbereich
// Wir koennen nicht davon ausgehen, dass wir ein Follow sind
// 7983: GetIdx() nicht nStart
// Aha, wir sind also im Fussnotenbereich
// Wenn der QuoVadis auf der selben (spaltigen) Seite steht
// Wenn der ErgoSum auf der selben Seite steht
// Ein Wort zu QuoVadis/ErgoSum:
// Fuer diese Texte wird der am Absatz eingestellte Font verwendet.
// Wir initialisieren uns also:
// Ein fieser Sonderfall: Flyfrms reichen in die Zeile und stehen
// natuerlich da, wo wir unseren Quovadis Text reinsetzen wollen.
// Erst mal sehen, ob es so schlimm ist:
// Das alte Spiel: wir wollen, dass die Zeile an einer bestimmten
// Stelle umbricht, also beeinflussen wir die Width.
// nLastLeft ist jetzt quasi der rechte Rand.
// Es kann durchaus sein, dass am Ende eine Marginportion steht,
// die beim erneuten Aufspannen nur Aerger bereiten wuerde.
// Luxus: Wir sorgen durch das Aufspannen von Glues dafuer,
// dass der QuoVadis-Text rechts erscheint:
// Jetzt aber: die QuoVadis-Portion wird angedockt:
// Und noch einmal adjustieren wegen des Adjustment und nicht zu Letzt
// wegen folgendem Sonderfall: In der Zeile hat der DummUser durchgaengig
// einen kleineren Font eingestellt als der vom QuoVadis-Text ...
// MakeDummyLine() erzeugt eine Line, die bis zum unteren Seitenrand
// reicht. DummyLines bzw. DummyPortions sorgen dafuer, dass Oszillationen
// zum stehen kommen, weil Rueckflussmoeglichkeiten genommen werden.
// Sie werden bei absatzgebundenen Frames in Fussnoten und bei Ftn-
// Oszillationen verwendet.
// SwFont zurueckstellen
// erster Versuch, vielleicht passt der Text
// zweiter Versuch, wir kuerzen den String:
// dritter Versuch, es langt: jetzt wird gestaucht:
// 8317: keine mehrzeiligen Felder bei QuoVadis und ErgoSum
// Wir wollen _immer_ per DrawStretchText ausgeben,
// weil nErgo schnell mal wechseln kann.
// 7773: sinnvolle Massnahme: ein Blank Abstand zum Text
// 8317: keine mehrzeiligen Felder bei QuoVadis und ErgoSum
// Wird im SwTxtFrm::Prepare() gerufen


1 / 29 | libreoffice-4.4.0.3/sw/source/core/text/frminf.cxx
// Fonts: CharSet, SYMBOL und DONTKNOW


1 / 105 | libreoffice-4.4.0.3/sw/source/core/text/portxt.cxx
// Vorsicht !


33 / 70 | libreoffice-4.4.0.3/sw/source/core/text/txthyph.cxx
// 5298: IsParaLine() (ex.IsFirstLine) fragt auf GetParaPortion() ab.
// wir muessen gleiche Bedingungen schaffen: in der ersten
// Zeile formatieren wir SwParaPortions...
// Man muss immer im Hinterkopf behalten, dass es z.B.
// Felder gibt, die aufgetrennt werden koennen ...
// Wir muessen uns darauf einstellen, dass in der Zeile
// FlyFrms haengen, an denen auch umgebrochen werden darf.
// Wir suchen also die erste HyphPortion in dem angegebenen
// Bereich.
// Entweder wir liegen drueber oder wir laufen gerade auf eine
// Hyphportion die am Ende der Zeile oder vor einem Flys steht.
// Wenn pPos 0 ist, wurde keine Trennstelle ermittelt.
// Das alte LineLayout wird wieder eingestellt ...
// nWrdStart bezeichnet nun die Position im String, der
// fuer eine Trennung zur Debatte steht.
// Start() hangelt sich zum End()
// Wir suchen vorwaerts
//!! rHyphInf.SetHyphWord( ... ) mu??? hier geschehen
// Mehrzeilige Felder duerfen nicht interaktiv getrennt werden.
// Wir stehen zwar im const, aber nViewWidth sollte erst im letzten
// Moment errechnet werden:
/*  Faelle:
 *  1) SoftHyph steht in der Zeile, ViewOpt aus.
 *     -> unsichtbar, Nachbarn unveraendert
 *  2) SoftHyph steht in der Zeile, ViewOpt an.
 *     -> sichtbar, Nachbarn veraendert
 *  3) SoftHyph steht am Zeilenende, ViewOpt aus/an.
 *     -> immer sichtbar, Nachbarn unveraendert
 */
/* Die endgueltige Breite erhalten wir im FormatEOL().
 * In der Underflow-Phase stellen wir fest, ob ueberhaupt ein
 * alternatives Spelling vorliegt. Wenn ja ...
 *
 * Fall 1: "Au-to"
 * 1) {Au}{-}{to}, {to} passt nicht mehr => Underflow
 * 2) {-} ruft Hyphenate => keine Alternative
 * 3) FormatEOL() und bFull = true
 *
 * Fall 2: "Zuc-ker"
 * 1) {Zuc}{-}{ker}, {ker} passt nicht mehr => Underflow
 * 2) {-} ruft Hyphenate => Alternative!
 * 3) Underflow() und bFull = true
 * 4) {Zuc} ruft Hyphenate => {Zuk}{-}{ker}
 */
// default-maessig besitzen wir keine Breite, aber eine Hoehe
// 5964: alte Werte muessen wieder zurueckgesetzt werden.
// 6976: Eine truebe Sache: Wir werden erlaubterweise breiter,
// aber gleich wird noch ein Fly verarbeitet, der eine korrekte
// X-Position braucht.
// - wenn die Sonderzeichen sichtbar sein sollen
// - wenn wir am Ende der Zeile stehen.
// - wenn wir vor einem (echten/emuliertem) Zeilenumbruch stehen
// Bug oder feature?:
// {Zu}{k-}{ker}, {k-} wird grau statt {-}


2 / 26 | libreoffice-4.4.0.3/sw/source/core/text/itrtxt.cxx
// Wenn sich nichts getan hat, dann gibt es nur noch Dummys
// 1170: beruecksichtigt Mehrdeutigkeiten:


27 / 91 | libreoffice-4.4.0.3/sw/source/core/text/itrpaint.cxx
// nPaintOfst wurde exakt auf das Ende eingestellt, deswegen <=
// nPaintOfst ist dokumentglobal, deswegen nLeftMar aufaddieren
// 8310: painten von LineBreaks in leeren Zeilen.
// 7529 und 4757: nicht <= nPaintOfst
// 7529: bei PostIts auch pLast returnen.
// Es gibt zwei Moeglichkeiten bei transparenten Font auszugeben:
// 1) DrawRect auf die ganze Zeile und die DrawText hinterher
//    (objektiv schnell, subjektiv langsam).
// 2) Fuer jede Portion ein DrawRect mit anschliessendem DrawText
//    ausgefuehrt (objektiv langsam, subjektiv schnell).
// Da der User in der Regel subjektiv urteilt, wird die 2. Methode
// als Default eingestellt.
// Adjustierung ggf. nachholen
// 6882: Leerzeilen duerfen nicht wegoptimiert werden bei Paragraphzeichen.
// bDrawInWindow entfernt, damit DropCaps auch gedruckt werden
// Das Ganze muss vor der Retusche stehen
// Wenn TopLeft oder BottomLeft der Line ausserhalb liegen,
// muss geclippt werden. Die Ueberpruefung auf Right() erfolgt
// in der folgenden Ausgabeschleife...
// Baseline-Ausgabe auch bei nicht-TxtPortions (vgl. TabPor mit Fill)
// Ein Sonderfall sind GluePortions, die Blanks ausgeben.
// 6168: Der Rest einer FldPortion zog sich die Attribute der naechsten
// Portion an, dies wird durch SeekAndChgBefore vermieden:
// Wenn das Ende der Portion hinausragt, wird geclippt.
// Es wird ein Sicherheitsabstand von Height-Halbe aufaddiert,
// damit die TTF-"f" nicht im Seitenrand haengen...
// reset underline font


43 / 140 | libreoffice-4.4.0.3/sw/source/core/text/porfld.cxx
// 8653: in keinem Fall nur SetLen(0);
// Der Text wird ausgetauscht...
// 8674: Laenge muss 0 sein, bei bFull nach Format ist die Laenge
// gesetzt und wird in nRest uebertragen. Ansonsten bleibt die
// Laenge erhalten und wuerde auch in nRest einfliessen!
// So komisch es aussieht, die Abfrage auf GetLen() muss wegen der
// false returnen wegen SetFull ...
// nicht Init(), weil wir Hoehe und Ascent brauchen
// Das Zeichen wird in der ersten Portion gehalten.
// Unbedingt nach Format!
// aExpand ist noch nicht gekuerzt worden, der neue Ofst
// ergibt sich durch nRest.
// In nNextOffset steht bei einem neuangelegten Feld zunaechst
// der Offset, an dem es selbst im Originalstring beginnt.
// Wenn beim Formatieren ein FollowFeld angelegt wird, wird
// der Offset dieses FollowFelds in nNextOffset festgehalten.
// Dies ist eine freizuegige Auslegung der Hintergrundbelegung ...
// Nicht auf IsHidden() abfragen !
// 5010: Wir sind in der Lage, mehrzeilige NumFelder anzulegen!
// 3689: Fies ist, wenn man in der Dialogbox soviel Davor-Text
// eingibt, bis die Zeile ueberlaeuft.
// Man muss die Fly-Ausweichmanoever beachten!
// Der Textteil hinter der Numerierung sollte immer
// mindestens beim linken Rand beginnen.
// 2739: Numerierung weicht Fly aus, kein nDiff in der zweiten Runde
// fieser Sonderfall: FlyFrm liegt in dem Bereich,
// den wir uns gerade unter den Nagel reissen wollen.
// Die NumberPortion wird als verborgen markiert.
/*  Ein FormatEOL deutet daraufhin, dass der folgende Text
 *  nicht mit auf die Zeile passte. Damit die Numerierung mitwandert,
 *  wird diese NumberPortion verborgen.
 */
/*  Eine verborgene NumberPortion wird nicht angezeigt, es sei denn, es gibt
 *  Textportions in dieser Zeile oder es gibt ueberhaupt nur eine einzige Zeile.
 */
// Der Textteil hinter der Numerierung sollte immer
// mindestens beim linken Rand beginnen.
// 2739: Numerierung weicht Fly aus, kein nDiff in der zweiten Runde
// fieser Sonderfall: FlyFrm liegt in dem Bereich,
// den wir uns gerade unter den Nagel reissen wollen.
// Die NumberPortion wird als verborgen markiert.
/*  Eine verborgene NumberPortion wird nicht angezeigt, es sei denn, es gibt
 *  Textportions in dieser Zeile oder es gibt ueberhaupt nur eine einzige Zeile.
 */
// wenn ich genauso gross bin wie die Zeile, brauche ich mich
// nicht an der Zeile nicht weiter ausrichten, ich lasse
// dann auch den max. Ascent der Zeile unveraendert
// Die Numerierungsportion sitzt immer vor dem ersten Zeichen,
// deshalb koennen wir abbrechen, sobald wir eine Portion mit
// einer Laenge > 0 erreicht haben.


4 / 211 | libreoffice-4.4.0.3/sw/source/core/text/itrcrsr.cxx
// einen goennen wir uns immer
// keine BULLETs!
// keine BULLETs!
// keine BULLETs!


2 / 27 | libreoffice-4.4.0.3/sw/source/core/text/porglue.cxx
// Die GluePortion wird ausgesogen und weggespuelt ...
// Wir erwarten ein framelokales SwRect !


6 / 10 | libreoffice-4.4.0.3/sw/source/core/text/porlin.cxx
// der Lebensretter
// Es werden alle nachfolgenden Portions geloescht.
// Es wird immer hinter uns eingefuegt.
// An das Ende wandern und pLinPortion an den letzten haengen ...
// Nur Portions mit echter Breite koennen ein true zurueckliefern
// Notizen beispielsweise setzen niemals bFull==true


1 / 44 | libreoffice-4.4.0.3/sw/source/core/text/redlnitr.cxx
// der einzig moegliche Kandidat


1 / 132 | libreoffice-4.4.0.3/sw/source/core/crsr/crstrvl.cxx
// steht in einer Tabelle


2 / 180 | libreoffice-4.4.0.3/sw/source/core/frmedt/fecopy.cxx
// das wars.
// nicht ueberspringen!!


3 / 161 | libreoffice-4.4.0.3/sw/source/core/frmedt/fetab.cxx
//!!!GetCurMouseTabColNum() mitpflegen!!!!
//!!!GetCurTabColNum() mitpflegen!!!!
// aender eine  Zellenbreite/-Hoehe/Spaltenbreite/Zeilenhoehe


1 / 208 | libreoffice-4.4.0.3/sw/source/core/frmedt/feshview.cxx
// update der Statuszeile


1 / 244 | libreoffice-4.4.0.3/sw/source/core/frmedt/tblsel.cxx
//erstmal die Zeile ueberspr.


1 / 14 | libreoffice-4.4.0.3/sw/source/core/frmedt/fedesc.cxx
// wir haben ihn den Schlingel


7 / 39 | libreoffice-4.4.0.3/sw/source/core/txtnode/swfont.cxx
// Hintergrundbrush setzen, z.B. bei Zeichenvorlagen
/*
 Escapement:
    frEsc:  Fraction, Grad des Escapements
    Esc = resultierendes Escapement
    A1 = Original-Ascent            (nOrgAscent)
    A2 = verkleinerter Ascent       (nEscAscent)
    Ax = resultierender Ascent      (GetAscent())
    H1 = Original-Hoehe             (nOrgHeight)
    H2 = verkleinerter Hoehe        (nEscHeight)
    Hx = resultierender Hoehe       (GetHeight())
    Bx = resultierende Baseline fuer die Textausgabe (CalcPos())
         (Vorsicht: Y - A1!)

    Escapement:
        Esc = H1 * frEsc;

    Hochstellung:
        Ax = A2 + Esc;
        Hx = H2 + Esc;
        Bx = A1 - Esc;

    Tiefstellung:
        Ax = A1;
        Hx = A1 + Esc + (H2 - A2);
        Bx = A1 + Esc;
*/
// nEsc ist der Prozentwert
// Robust: Eigentlich sollte der Font bereits eingestellt sein, aber
// sicher ist sicher ...
// 15142: Ein Wort laenger als eine Zeile, beim Zeilenumbruch
//        hochgestellt, muss seine effektive Hoehe melden.


3 / 6 | libreoffice-4.4.0.3/sw/source/core/txtnode/swfntcch.cxx
// aus atrstck.cxx
// globale Variablen, werden in SwFntCch.Hxx bekanntgegeben
// Der FontCache wird in TxtInit.Cxx _TXTINIT erzeugt und in _TXTEXIT geloescht


6 / 51 | libreoffice-4.4.0.3/sw/source/core/txtnode/fntcap.cxx
// Es wird vorausgesetzt, dass rPos bereits kalkuliert ist!
// 4023: Kapitaelchen und Kerning.
// Optimierung:
// Es wird vorausgesetzt, dass rPos bereits kalkuliert ist!
// Wir basteln uns einen Font fuer die Grossbuchstaben:
// Aufraeumen:


1 / 6 | libreoffice-4.4.0.3/sw/source/core/txtnode/atrref.cxx
// Attribut fuer Inhalts-/Positions-Referenzen im Text


1 / 12 | libreoffice-4.4.0.3/sw/source/core/txtnode/txtatr2.cxx
// erfrage vom Modify Informationen


25 / 70 | libreoffice-4.4.0.3/sw/source/core/txtnode/atrftn.cxx
// returnt den anzuzeigenden String der Fuss-/Endnote
// dann ist die Nummer von Interesse, also ueber die Info diese
// Zwei Dinge muessen erledigt werden:
// 1) Die Fussnoten muessen bei ihren Seiten abgemeldet werden
// 2) Die Fussnoten-Sektion in den Inserts muss geloescht werden.
//JP 27.01.97: der sw3-Reader setzt einen StartNode aber das
//              Attribut ist noch nicht im TextNode verankert.
//              Wird es geloescht (z.B. bei Datei einfuegen mit
//              Ftn in einen Rahmen), muss auch der Inhalt
// Wir duerfen die Fussnotennodes nicht loeschen
// und brauchen die Fussnotenframes nicht loeschen, wenn
// wir im ~SwDoc() stehen.
// 1) Die Section fuer die Fussnote wird beseitigt
// Es kann sein, dass die Inserts schon geloescht wurden.
// Werden die Nodes nicht geloescht mussen sie bei den Seiten
// abmeldet (Frms loeschen) werden, denn sonst bleiben sie
// stehen (Undo loescht sie nicht!)
// loesche die Fussnote noch aus dem Array am Dokument
// gibt noch weitere Fussnoten
// Es koennen ja auch Grafiken in der Fussnote stehen ...
// Die Fussnoten duplizieren
// lege eine neue leere TextSection fuer diese Fussnote an
// Nun verpassen wir dem TxtNode noch die Fussnotenvorlage.
//JP 13.05.97: falls das Layout vorm loeschen der Fussnoten entfernt
//              wird, sollte man das ueber die Fussnote selbst tun


9 / 53 | libreoffice-4.4.0.3/sw/source/core/txtnode/ndhints.cxx
// Sortierreihenfolge: Start, Ende (umgekehrt!), Which-Wert (umgekehrt!),
//                     als letztes die Adresse selbst
// Zuerst nach Ende danach nach Ptr
// 1) gleiche Anzahl in beiden Arrays
// 3a) Stimmt die Start-Sortierung?
// 3b) Stimmt die End-Sortierung?
// --- Ueberkreuzungen ---
// 5) gleiche Pointer in beiden Arrays
// 6) gleiche Pointer in beiden Arrays


29 / 42 | libreoffice-4.4.0.3/sw/source/core/txtnode/atrflyin.cxx
/*
 * An dieser Stelle soll einmal der Gesamtzusammenhang bei der Erzeugung
 * eines neuen SwTxtFlyCnt erlaeutert werden.
 * Das MakeTxtHint() wird z.B. im SwTxtNode::Copy() gerufen.
 * Fuer die komplette Verdopplung sind folgende Schritte notwendig:
 * 1) Duplizieren des pFmt incl. Inhalt, Attributen etc.
 * 2) Setzen des Ankers
 * 3) Benachrichtigung
 * Da fuer die Bewaeltigung der Aufgaben nicht immer alle Informationen
 * bereitstehen und darueber hinaus bestimmte Methoden erst zu einem
 * spaeteren Zeitpunkt gerufen werden duerfen (weil nocht nicht alle
 * Nodeinformationen vorliegen), verteilt sich der Ablauf.
 * ad 1) MakeTxtHint() wird durch den Aufruf von SwDoc::CopyLayout()
 * der das neue FlyFrmFmt erzeugt und mit dem duplizierten Inhalt des
 * FlyFrm verbunden.
 * ad 2) SetAnchor() wird von SwTxtNode::Insert() gerufen und sorgt fuer das
 * setzen des Ankers (die SwPosition des Dummy-Zeichens wird dem FlyFrmFmt
 * per SetAttr bekannt gegeben). Dies kann nicht im MakeTxtHint erledigt
 * werden, da der Zielnode unbestimmt ist.
 * ad 3) _GetFlyFrm() wird im Formatierungsprozess vom LineIter gerufen
 * und sucht den FlyFrm zum Dummyzeichen des aktuellen CntntFrm. Wird keiner
 * gefunden, so wird ein neuer FlyFrm angelegt.
 * Kritisch an diesem Vorgehen ist, dass das pCntnt->AppendFly() eine
 * sofortige Neuformatierung von pCntnt anstoesst. Die Rekursion kommt
 * allerdings durch den Lockmechanismus in SwTxtFrm::Format() nicht
 * zu stande.
 * Attraktiv ist der Umstand, dass niemand ueber die vom Node abhaengigen
 * CntntFrms iterieren braucht, um die FlyInCntFrm anzulegen. Dies geschieht
 * bei der Arbeit.
 */
// Das FlyFrmFmt muss dupliziert werden.
// In CopyLayoutFmt (siehe doclay.cxx) wird das FlyFrmFmt erzeugt
// und der Inhalt dupliziert.
// JP 03.06.96: dann sorge dafuer, das der koperierte Anker auf
//              gueltigen Content zeigt! Die Umsetzung auf die
// SetAnchor() wird von SwTxtNode::Insert() gerufen und sorgt fuer das
// setzen des Ankers (die SwPosition des Dummy-Zeichens wird dem FlyFrmFmt
// per SetAttr bekannt gegeben). Dies kann nicht im MakeTxtHint erledigt
// werden, da der Zielnode unbestimmt ist.
// fuers Undo muss der neue Anker schon bekannt sein !
// Wir ermitteln den Index im Nodesarray zum Node
// beim Ankerwechsel werden immer alle FlyFrms vom Attribut geloescht
// JP 25.04.95: wird innerhalb des SplitNodes die Frames verschoben
//              koennen die Frames erhalten bleiben.
// stehen wir noch im falschen Dokument ?
// nur den Anker neu setzen
// nur den Anker neu setzen
// Fuer jeden CntFrm wird ein SwFlyInCntFrm angelegt.
// _GetFlyFrm() wird im Formatierungsprozess vom LineIter gerufen
// und sucht den FlyFrm zum Dummyzeichen des aktuellen CntntFrm. Wird keiner
// gefunden, so wird ein neuer FlyFrm angelegt.
// Wir haben keinen passenden FlyFrm gefunden, deswegen wird ein
// neuer angelegt.
// Dabei wird eine sofortige Neuformatierung von pCurrFrm angestossen.
// Die Rekursion wird durch den Lockmechanismus in SwTxtFrm::Format()
// abgewuergt.
// 7922: Wir muessen dafuer sorgen, dass der Inhalt des FlyInCnt
// nach seiner Konstruktion stramm durchformatiert wird.


105 / 394 | libreoffice-4.4.0.3/sw/source/core/txtnode/thints.cxx
// pass 4: handle overwritten hints
// erst hier wird das Frame-Format kopiert (mit Inhalt) !!
// Kopie von einem Text-Attribut
// loesche das Text-Attribut (muss beim Pool abgemeldet werden!)
// einige Sachen muessen vorm Loeschen der "Format-Attribute" erfolgen
// siehe auch die Anmerkung "Loeschen von Formaten
// zeichengebundener Frames" in fesh.cxx, SwFEShell::DelFmt()
// vom Undo auf 0 gesetzt ??
// Wenn wir ein HiddenParaField sind, dann muessen wir
// ggf. fuer eine Neuberechnung des Visible-Flags sorgen.
//JP 06-08-95: DDE-Felder bilden eine Ausnahme
// bestimmte Felder mussen am Doc das Calculations-Flag updaten
// Wir muessen zuerst einfuegen, da in SetAnchor()
// dem FlyFrm GetStart() uebermittelt wird.
//JP 11.05.98: falls das Anker-Attribut schon richtig
// gesetzt ist, dann korrigiere dieses nach dem Einfuegen
// des Zeichens. Sonst muesste das immer  ausserhalb
// erfolgen (Fehleranfaellig !)
// Format-Pointer kann sich im SetAnchor geaendert haben!
// (Kopieren in andere Docs!)
// das soll nicht meoglich sein; hier verhindern
// Der Dtor des TxtHints loescht nicht das Zeichen.
// Wenn ein CH_TXTATR_.. vorliegt, dann muss man
// dieses explizit loeschen
// loesche das Zeichen aus dem String !
// Fussnoten, man kommt an alles irgendwie heran.
// CntntNode erzeugen und in die Inserts-Section stellen
// FussNote in nicht Content-/Redline-Bereich einfuegen ??
// das soll nicht meoglich sein; hier verhindern
// Der Dtor des TxtHints loescht nicht das Zeichen.
// Wenn ein CH_TXTATR_.. vorliegt, dann muss man
// dieses explizit loeschen
// loesche das Zeichen aus dem String !
// wird eine neue Fussnote eingefuegt ??
// loesche alle Frames der Section, auf die der StartNode zeigt
// Wir muessen zuerst einfuegen, da sonst gleiche Indizes
// entstehen koennen und das Attribut im _SortArr_ am
// Dokument nicht eingetrage wird.
// Wir tragen uns am FtnIdx-Array des Docs ein ...
// eine alte Ftn wird umgehaengt (z.B. SplitNode)
// neuen Index zuweisen, dafuer aus dem SortArray
// loeschen und neu eintragen
// wenn ueber Undo der StartNode gesetzt wurde, kann
// der Index noch gar nicht in der Verwaltung stehen !!
// fuers Update der Nummern und zum Sortieren
// muss der Node gesetzt sein.
// FussNote im Redline-Bereich NICHT ins FtnArray einfuegen!
// fuer HiddenParaFields Benachrichtigungsmechanismus
// Fuer SwTxtHints ohne Endindex werden CH_TXTATR_..
// eingefuegt, aStart muss danach um einen zurueckgesetzt werden.
// Wenn wir im SwTxtNode::Copy stehen, so wurde das Zeichen bereits
// mitkopiert. In solchem Fall ist SETATTR_NOTXTATRCHR angegeben worden.
// 4263: AttrInsert durch TextInsert => kein Adjust
// den MsgHint jetzt fuettern, weil gleich sind
// Start und End weg.
// Das CalcVisibleFlag bei HiddenParaFields entfaellt,
// da dies das Feld im Dtor selbst erledigt.
// gefunden, loeschen,
// setze diese Attribute am TextNode. Wird der gesamte Bereich umspannt,
// dann setze sie nur im AutoAttrSet (SwCntntNode:: SetAttr)
// teil die Sets auf (fuer Selektion in Nodes)
// gesamter Bereich
// sind am Node schon Zeichenvorlagen gesetzt, muss man diese Attribute
// (rSet) immer als TextAttribute setzen, damit sie angezeigt werden.
// aufnehmen als MergeWert (falls noch nicht gesetzt neu setzen!)
/* wenn mehrere Attribute ueberlappen gewinnt der letze !!
 z.B
            1234567890123456789
              |------------|        Font1
                 |------|           Font2
                    ^  ^
                    |--|        Abfragebereich: -> Gueltig ist Font2
*/
// erfrage die Attribute vom TextNode ueber den Bereich
/* stelle erstmal fest, welche Text-Attribut in dem Bereich gueltig
         * sind. Dabei gibt es folgende Faelle:
         *  UnEindeutig wenn: (wenn != Format-Attribut)
         *      - das Attribut liegt vollstaendig im Bereich
         *      - das Attributende liegt im Bereich
         *      - der Attributanfang liegt im Bereich:
         * Eindeutig (im Set mergen):
         *      - das Attrib umfasst den Bereich
         * nichts tun:
         *      das Attribut liegt ausserhalb des Bereiches
         */
// dann besorge mal die Auto-(Fmt)Attribute
// kein Bereich:
// ueber den Bereich hinaus
// es ist ein Bereich definiert
// ueber den Bereich hinaus
// vor oder genau Start
// liegt davor
// hinter oder genau Ende
// reicht in den Bereich
// uneindeutig ?
// hinter oder genau Ende
// aus dem Format-Set alle entfernen, die im TextSet auch gesetzt sind
// jetzt alle zusammen "mergen"
// dann besorge mal die Auto-(Fmt)Attribute
// Felder bilden eine Ausnahme:
// 2) Wenn zwei Felder genau aneinander liegen,
//    sollen sie nicht zu einem verschmolzen werden.
// Wir koennen also auf die while-Schleife verzichten
// was fuer ein Feld ist es denn ??
// bestimmte Felder mussen am Doc das Calculations-Flag updaten
// gehts ins normale Nodes-Array?
// bevor die ReferenzNummer gesetzt wird, sollte
// das Feld am richtigen FeldTypen haengen!
// SwTxtAttrs ohne Ende werden sonderbehandelt:
// Sie werden natuerlich in das Array insertet, aber sie werden nicht
// in die pPrev/Next/On/Off-Verkettung aufgenommen.
// Der Formatierer erkennt diese TxtHints an dem CH_TXTATR_.. im Text !
// ... und die Abhaengigen benachrichtigen
// Ab hier gibt es nur noch pHint mit einem EndIdx !!!
// Wir drehen den Quatsch einfach um:
// ... und die Abhaengigen benachrichtigen
// Ist der Hint schon bekannt, dann suche die Position und loesche ihn.
// Ist er nicht im Array, so gibt es ein OSL_ENSURE(!!
// ist der Attribut-Anfang schon groesser als der Idx ?
// Ueberlappt das Attribut den Bereich?
// Umfasst das Attribut den Bereich komplett?
// partielle Ueberlappung, der 1. gewinnt


2 / 44 | libreoffice-4.4.0.3/sw/source/core/txtnode/fmtatr2.cxx
// weiterleiten an das TextAttribut
// weiterleiten an das TextAttribut


21 / 276 | libreoffice-4.4.0.3/sw/source/core/txtnode/txtedt.cxx
// Wir ersparen uns in Hyphenate ein GetFrm()
// Achtung: in edlingu.cxx stehen die Variablen!
// Wir suchen immer von links nach rechts, es wird also das Wort
// vor nPos gesucht. Es sei denn, wir befinden uns am Anfang des
// Absatzes, dann wird das erste Wort zurueckgeliefert.
// Wenn dieses erste Wort nur aus Whitespaces besteht, returnen wir
// einen leeren String.
// Die Aehnlichkeiten zu SwTxtFrm::_AutoSpell sind beabsichtigt ...
// ACHTUNG: Ev. Bugs in beiden Routinen fixen!
// Die Aehnlichkeiten zu SwTxtNode::Spell sind beabsichtigt ...
// ACHTUNG: Ev. Bugs in beiden Routinen fixen!
// Die Aehnlichkeiten zu SwTxtNode::Spell sind beabsichtigt ...
// ACHTUNG: Ev. Bugs in beiden Routinen fixen!
// Wird vom CollectAutoCmplWords gerufen
/** Findet den TxtFrm und sucht dessen CalcHyph */
// Abkuerzung: am Absatz ist keine Sprache eingestellt:
// 4935: Seit der Trennung ueber Sonderbereiche sind Faelle
// moeglich, in denen kein Frame zum Node vorliegt.
// Das Layout ist nicht robust gegen "Direktformatierung"
// Ist das Wrong-Feld auf invalid?
// die ACompl-Liste muss angepasst werden


3 / 242 | libreoffice-4.4.0.3/sw/source/core/txtnode/fntcache.cxx
// Wer beim Leading luegt, luegt moeglicherweise auch beim
// Ascent/Descent, deshalb wird hier ggf. der Font ein wenig
// tiefergelegt, ohne dabei seine Hoehe zu aendern.


14 / 57 | libreoffice-4.4.0.3/sw/source/core/txtnode/atrfld.cxx
// DB-Feldtypen zerstoeren sich selbst
// bei einige FeldTypen muessen wir den FeldTypen noch loeschen
// vorm loeschen erstmal austragen
// "Farbe hat sich geaendert !"
// GetReferenz-Felder aktualisieren
// Je nach DocPos aktualisieren (SwTxtFrm::Modify())
// Bei Seitennummernfeldern
// Die Hints stehen in unterschiedlichen Dokumenten,
// der Feldtyp muss im neuen Dokument angemeldet werden.
// Z.B: Kopieren ins ClipBoard.
// Sonderbehandlung fuer DDE-Felder
// Tabellenfelder auf externe Darstellung
// erzeuge aus der internen (fuer CORE) die externe (fuer UI) Formel
// steht in einer Tabelle


147 / 493 | libreoffice-4.4.0.3/sw/source/core/txtnode/ndtxt.cxx
// schade, das wars
// werden FlyFrames mit verschoben, so muessen diese nicht ihre
// Frames zerstoeren. Im SwTxtFly::SetAnchor wird es abgefragt!
//Ersten Teil des Inhalts in den neuen Node uebertragen und
//im alten Node loeschen.
// alle zeichengebundenen Rahmen, die im neuen Absatz laden
// muessen aus den alten Frame entfernt werden:
// JP 01.10.96: alle leeren und nicht zu expandierenden
//              Attribute loeschen
// Benachrichtigungen wieder freischalten
// dann sage den Frames noch, das am Ende etwas "geloescht" wurde
// neue Frames anlegen.
// JP 01.10.96: alle leeren und nicht zu expandierenden
//              Attribute loeschen
// neue Frames anlegen.
//Hint fuer Pagedesc versenden. Das mueste eigntlich das Layout im
//Paste der Frames selbst erledigen, aber das fuehrt dann wiederum
//zu weiteren Folgefehlern, die mit Laufzeitkosten geloest werden
// verschiebe noch alle Bookmarks/TOXMarks
// alle Crsr/StkCrsr/UnoCrsr aus dem Loeschbereich verschieben
// verschiebe noch alle Bookmarks/TOXMarks
// alle Crsr/StkCrsr/UnoCrsr aus dem Loeschbereich verschieben
// erzeugt einen AttrSet mit Bereichen fuer Frame-/Para/Char-Attributen
// erfrage die OutlineLevel und update gegebenenfalls das Nodes-Array,
// falls sich die Level geaendert haben !
// Update beim Level 0 noch die Fussnoten !!
// Erfrage die akt. Condition des TextNodes:
// Wenn man sich genau am Ende einer Text- bzw. INetvorlage befindet,
// bekommt diese das DontExpand-Flag verpasst
// Wenn bExpand gesetzt ist, wird das Verhalten bei Eingabe
// simuliert, d.h. der Start wuede verschoben, das Ende expandiert,
// Beim Kopieren von Feldern in andere Dokumente
// muessen die Felder bei ihren neuen Feldtypen angemeldet werden.
// TabellenFormel muessen relativ kopiert werden.
// wandel die interne in eine externe Formel um
// Beim Kopieren von TOXMarks(Client) in andere Dokumente
// muss der Verzeichnis (Modify) ausgetauscht werden
// Wenn wir es mit einer Zeichenvorlage zu tun haben,
// muessen wir natuerlich auch die Formate kopieren.
// Wenn wir es mit benutzerdefinierten INet-Zeichenvorlagen
// zu tun haben, muessen wir natuerlich auch die Formate kopieren.
//JP 24.04.98: Bug 49753 - ein TextNode muss am Attribut
//              gesetzt sein, damit die Vorlagen erzeugt
//JP 22.10.97: Bug 44875 - Verbindung zum Format herstellen
//  Beschreibung    kopiert Attribute an der Position nStart in pDest.
//  BP 7.6.93:      Es werden mit Absicht nur die Attribute _mit_ EndIdx
//                  kopiert! CopyAttr wird vornehmlich dann gerufen,
//                  wenn Attribute fuer einen Node mit leerem String
//                  gesetzt werden sollen.
// keine Attribute, keine Kekse
// ueber das Textende, da nLen == 0
// Frames benachrichtigen, sonst verschwinden die Ftn-Nummern
// kopiert Zeichen und Attibute in pDest, wird angehaengt
// wurde keine Laenge angegeben, dann Kopiere die Attribute
// harte Absatz umspannende Attribute kopieren
// alle, oder nur die CharAttribute ?
//JP 15.02.96: Bug 25537 - Attributbehandlung am Ende fehlt! Darum
//              ueber die InsertMethode den Text einfuegen und nicht
// um reale Groesse Updaten !
// harte Absatz umspannende Attribute kopieren
// alle, oder nur die CharAttribute ?
// Ende erst jetzt holen, weil beim Kopieren in sich selbst der
// Start-Index und alle Attribute vorher aktualisiert werden.
// durch das Attribute-Array, bis der Anfang des Geltungsbereiches
// des Attributs hinter dem zu kopierenden Bereich liegt
// wird in sich selbst kopiert, dann kann beim Einfuegen ein
// Attribut geloescht werden. Darum erst ins Tmp-Array kopieren und
// dann erst ins eigene uebertragen.
// Del-Array fuer alle RefMarks ohne Ausdehnung
//Achtung: kann ungueltig sein!!
// JP 26.04.94: REFMARK's werden nie kopiert. Hat das Refmark aber
//              keinen Bereich umspannt, so steht im Text ein 255
//              dieses muss entfernt werden. Trick: erst kopieren,
//              erkennen und sammeln, nach dem kopieren Loeschen.
//              Nimmt sein Zeichen mit ins Grab !!
// nur falls im Array Attribute stehen (kann nur beim Kopieren
// sich selbst passieren!!)
// analog zu Insert(char) in txtedt.cxx:
// 1) bei bHintExp leere Hints an rIdx.GetIndex suchen und aufspannen
// 2) bei bHintExp == false mitgezogene Feldattribute zuruecksetzen
// bei leeren Attributen auch Start veraendern
// Kein Feld, am Absatzanfang, HintExpand
// nicht im Dokument verschieben ?
// wurde keine Laenge angegeben, dann Kopiere die Attribute
// wird in sich selbst verschoben, muss es gesondert behandelt werden !!
// dann suche mal alle Attribute zusammen, die im verschobenen
// Bereich liegen. Diese werden in das extra Array verschoben,
// damit sich die Indizies beim Updaten nicht veraendern !!!
// 2. Attribute verschieben
// durch das Attribute-Array, bis der Anfang des Geltungsbereiches
// des Attributs hinter dem zu verschiebenden Bereich liegt
// Anfang liegt vor dem Bereich
// Attribut mit einem Bereich
// und das Ende des Attribut liegt im Bereich
// der Anfang liegt vollstaendig im Bereich
// Attribut verschieben
// die Start/End Indicies neu setzen
// while-Schleife weiter, ohne ++ !
// das Ende liegt dahinter
// die Daten kopieren
// dann setze die kopierten/geloeschten Attribute in den Node
// String nicht gewachsen ??
// harte Absatz umspannende Attribute kopieren
// alle, oder nur die CharAttribute ?
// 2. Attribute verschieben
// durch das Attribute-Array, bis der Anfang des Geltungsbereiches
// des Attributs hinter dem zu verschiebenden Bereich liegt
// Anfang liegt vor dem Bereich
// Attribut mit einem Bereich
// und das Ende des Attribut liegt im Bereich
// der Anfang liegt vollstaendig im Bereich
// Attribut verschieben
// die Start/End Indicies neu setzen
// while-Schleife weiter, ohne ++ !
// das Ende liegt dahinter
// sollten jetzt noch leere Attribute rumstehen, dann haben diese
// eine hoehere Praezedenz. Also herausholen und das Array updaten.
// Die dabei entstehenden leeren Hints werden von den gesicherten
// Frames benachrichtigen;
/* GCAttr(); alle leeren weggwerfen ist zu brutal.
     * Es duerfen nur die wegggeworfen werden,
     * die im Bereich liegen und nicht am Ende des Bereiches liegen
     */
// Bei leeren Absaetzen werden nur die
// wenn Ende und Start gleich sind --> loeschen
//TxtFrm's reagieren auf aHint, andere auf aNew
/* hartes PageBreak/PageDesc/ColumnBreak aus AUTO-Set ignorieren */
// der naechste erbt keine Breaks!
// PageBreaks/PageDesc/ColBreak rausschmeissen.
// jetzt kann es sein, das durch die Nummerierung dem neuen Node eine
// Vorlage aus dem Pool zugewiesen wurde. Dann darf diese nicht
// nochmal uebergeplaettet werden !!
// mehr duerfte nicht gemacht werden oder ????
// fuer Nummerierung/Gliederung
// Position hinter dem eingefuegt wird
// Text einfuegen
// alle FontAttribute mit CHARSET Symbol in dem Bereich setzen
// ueber das Textende
// dahinter einfuegen;
// es existiert fuer den Node irgendein Redline-Delete-Object
// Absatz ist komplett geloescht
// von 0 bis nContent ist alles geloescht
// mehr kann nicht kommen
// mehr kann nicht kommen
// dann das 1. Zeichen ersetzen den Rest loschen und einfuegen
// Dadurch wird die Attributierung des 1. Zeichen expandiert!
//      Modify ueberladen, damit beim Loeschen von Vorlagen diese
//      wieder richtig verwaltet werden (Outline-Numerierung!!)
//      bei Nodes im Undo nie _ChgTxtCollUpdateNum rufen.
// nur wenn im normalen Nodes-Array


3 / 7 | libreoffice-4.4.0.3/sw/source/core/txtnode/atrtox.cxx
// kein entsprechender Verzeichnistyp vorhanden -> anlegen
// kein entsprechender Typ vorhanden -> neu erzeugen
// Verzeichnistyp umhaengen


2 / 267 | libreoffice-4.4.0.3/sw/source/core/layout/pagechg.cxx
//aendert sich sowieso
//3. und 3.1


1 / 446 | libreoffice-4.4.0.3/sw/source/core/layout/wsfrm.cxx
//Row+Cell, Browse mit Body


2 / 495 | libreoffice-4.4.0.3/sw/source/core/layout/frmtool.cxx
//   Hoehe danebenliegen.
// watch for Frm being deleted


1 / 909 | libreoffice-4.4.0.3/sw/source/core/layout/tabfrm.cxx
//Linker Rand und die Breite zaehlen (Word-Spezialitaet)


2 / 9 | libreoffice-4.4.0.3/sw/source/core/sw3io/swacorr.cxx
//  - Text mit Attributierung (kann nur der SWG - SWG-Format!)
//      rShort ist der Stream-Name - gecryptet!


1 / 8 | libreoffice-4.4.0.3/sw/source/core/fields/tblcalc.cxx
// es ist ein String


2 / 93 | libreoffice-4.4.0.3/sw/source/core/fields/docufld.cxx
// TODO: woher kommen die defines?
// das wars schon!!


1 / 24 | libreoffice-4.4.0.3/sw/source/core/fields/ddefld.cxx
// am Doc aufrufen ??


1 / 129 | libreoffice-4.4.0.3/sw/source/core/fields/cellfml.cxx
// Kennung fuer Box loeschen


9 / 15 | libreoffice-4.4.0.3/sw/source/filter/inc/fltini.hxx
// die speziellen Reader
// wir wollen die Streams / Storages nicht geoeffnet haben
// die speziellen Writer
// Umsetzen der LRSpaces im aktuell importierten Doc. Die Fremd-Filter
// liefern immer absolute Werte fuer die Ebenen einer NumRule. Wir
// verarbeiten jetzt aber relative Werte bezogen auf das LR-Space-Item.
// Das hat zur Folge, das bei allen Absaetzen die EInzuege der NumRule vom
// Absatz-Einzug abgezogen werden muss.
// Liste aller benannten NumRules


32 / 40 | libreoffice-4.4.0.3/sw/source/filter/inc/wrtswtbl.hxx
//       Code aus dem HTML-Filter fuers schreiben von Tabellen
// SwTableBox der Zelle
// geerbter Hintergrund einer Zeile
// fixe/Mindest-Hoehe der Zeile
// Breite aus Option;
// Start-Zeile
// ueberspannte Zeilen
// ueberspannte Spalten
// Alle Zellen der Rows
// End-Position (twips) der Zeile
// Welche Umrandungen sind da?
// etwas Unschaerfe zulassen
// Da wir hier nur die Wahrheits-Grade 0 und 1 kennen, lassen wir lieber
// auch nicht zu, dass x==y und x<y gleichzeitig gilt ;-)
// End Position der Spalte
// Spaltenbreite ausgeben?
// Welche Umrandungen sind da?
// etwas Unschaerfe zulassen
// Da wir hier nur die Wahrheits-Grade 0 und 1 kennen, lassen wir lieber
// auch nicht zu, dass x==y und x<y gleichzeitig gilt ;-)
// alle Spalten
// alle Zellen
// Umrandungsfarbe
// Dicke der inneren Umrandung
// Absatnd Umrandung-Inhalt
// Dicke der ausseren Umrandung
// Dicke der inneren Umrandung
// Bezugsgroesse fur Breiten SwFmtFrmSize
// letzte Zeile des Tabellen-Kopfes
// Absolute/Relative Breite der Tabelle
// Breiten relativ ausgeben?
// Layout zur Hoehenbestimmung nehmen?


3 / 7 | libreoffice-4.4.0.3/sw/source/filter/inc/wrt_fn.hxx
// einige Forward-Deklarationen
/* Funktionspointer auf die Attribut-Write-Funktionen */
/* Funktionspointer auf die Node-Write-Funktionen */


4 / 21 | libreoffice-4.4.0.3/sw/source/filter/inc/fltshell.hxx
// Stack-Eintrag fuer die Attribute Es werden immer Pointer auf neue Attribute uebergeben.
// Der WWEndStack verhaelt sich wie der WWControlStck, nur dass die Attribute
// auf ihm bis ans Ende des Dokuments gehortet werden, falls auf sie noch
// zugegriffen werden muss (z.B. Book/RefMarks, Index u.s.w.)


104 / 504 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8atr.cxx
//  Hilfsroutinen fuer Styles
/*
 * Format wie folgt ausgeben:
 *      - gebe die Attribute aus; ohne Parents!
 */
// Da WW nur Break-After ( Pagebreak und Sectionbreaks ) kennt, im SW aber
// Bagebreaks "vor" und "nach" und Pagedescs nur "vor" existieren, werden
// die Breaks 2* durchgeklimpert, naemlich vor und hinter jeder Zeile.
// Je nach BreakTyp werden sie vor oder nach der Zeile gesetzt.
// Es duerfen nur Funktionen gerufen werden, die nicht in den
// Ausgabebereich pO schreiben, da dieser nur einmal fuer CHP und PAP existiert
// und damit im falschen landen wuerden.
// Die PageDescs werden beim Auftreten von PageDesc-Attributen nur in
// WW8Writer::pSepx mit der entsprechenden Position eingetragen.  Das
// Aufbauen und die Ausgabe der am PageDesc haengenden Attribute und
// Kopf/Fusszeilen passiert nach dem Haupttext und seinen Attributen.
// tatsaechlich wird hier NOCH NICHTS ausgegeben, sondern
// nur die Merk-Arrays aCps, aSects entsprechend ergaenzt
// dann muss das fuer die Ausgabe korrigiert werden
// nix, macht WW undokumentiert auch so
// Fly als Zeichen werden bei uns zu Absatz-gebundenen
// jetzt den Abstand vom Absatz-Rand setzen
// TransCol uebersetzt SW-Farben in WW. Heraus kommt die bei WW fuer
// Text- und Hintergrundfarbe benutzte Codierung.
// Gibt es keine direkte Entsprechung, dann wird versucht, eine moeglichst
// aehnliche WW-Farbe zu finden.
// TransBrush uebersetzt SW-Brushes in WW. Heraus kommt WW8_SHD.
// Nicht-Standardfarben des SW werden noch nicht in die
// Misch-Werte ( 0 .. 95% ) vom WW uebersetzt.
// Return: Echte Brush ( nicht transparent )
// auch bei Transparent wird z.B. fuer Tabellen eine transparente Brush
// nur WW8 kann ZeichenHintergrund
// Typ nachtragen
// TOXMarks fehlen noch
// Detaillierte Einstellungen zur Trennung erlaubt WW nur dokumentenweise.
// Man koennte folgende Mimik einbauen: Die Werte des Style "Standard" werden,
// falls vorhanden, in die Document Properties ( DOP ) gesetzt.
// ACK.  Dieser Vorschlag passt exakt zu unserer Implementierung des Import,
// daher setze ich das gleich mal um. (KHZ, 07/15/2000)
// NoHyphen: ich habe keine Entsprechung in der SW-UI und WW-UI gefunden
// RefMark, NoLineBreakHere  fehlen noch
// Fuer Auto-Nummer muss ein Spezial-Zeichen
// in den Text und darum ein fSpec-Attribut
// Auto-Nummer-Zeichen
// User-Nummerierung
//???? was ist bei Prozentangaben ???
// PageDesc : Breite + Hoehe
// ReplaceCr() wird fuer Pagebreaks und Pagedescs gebraucht. Es wird ein
// bereits geschriebenes CR durch ein Break-Zeichen ersetzt. Replace muss
// direkt nach Schreiben des CR gerufen werden.
// Rueckgabe: FilePos des ersetzten CRs + 1 oder 0 fuer nicht ersetzt
// Breaks schreiben nichts in das Ausgabe-Feld rWrt.pO,
// sondern nur in den Text-Stream ( Bedingung dafuer, dass sie von Out_Break...
// gerufen werden duerfen )
// Ausgeschaltet
// Flys fehlen noch ( siehe RTF )
// Mittelwert nehmen, da WW nur 1 Wert kennt
// Flys fehlen noch ( siehe RTF )
// Mittelwert nehmen, da WW nur 1 Wert kennt
// Print, Opaque, Protect fehlen noch
//!!!! Ankertyp und entsprechende Umrechnung fehlt noch
//!!!! Ankertyp und entsprechende Umrechnung fehlt noch
// WW: 0 ist reserviert
// Im Fall eine Flys als Zeichen: Absatz-gebunden setzen!!!
//       nicht weglassen
// Masseinheit : pt
// MakeBorderLine() bekommt einen WW8Bytes* uebergeben, um die Funktion
// auch fuer die Tabellen-Umrandungen zu benutzen.
// Wenn nSprmNo == 0, dann wird der Opcode nicht ausgegeben.
// bShadow darf bei Tabellenzellen *nicht* gesetzt sein !
// FormatBox1() ist fuer alle Boxen ausser in Tabellen.
// es wird pO des WW8Writers genommen
// FormatBox2() ist fuer TC-Strukturen in Tabellen. Der Sprm-Opcode
// wird nicht geschrieben, da es in der TC-Structur ohne Opcode gepackt ist.
// dxpSpace wird immer 0, da WW das in Tabellen so verlangt
// ( Tabellenumrandungen fransen sonst aus )
// Ein WW8Bytes-Ptr wird als Ausgabe-Parameter uebergeben
// moeglich und vielleicht besser waere 0xffff
// Fly um Grafik-> keine Umrandung hier, da
// der GrafikHeader bereits die Umrandung hat
// dann besorge mal die Seitenbreite ohne Raender !!
// Nachsehen, ob alle Spalten gleich sind
// gibt es aber nicht in WW - also wie kommt man an
//  Es wird nur das Item "SvxWidowItem" und nicht die Orphans uebersetzt,
//  da es fuer beides im WW nur ein Attribut "Absatzkontrolle" gibt und
//  im SW wahrscheinlich vom Anwender immer Beide oder keiner gesetzt werden.
// so viele Tabs kommen hinzu
// so viele Tabs fallen weg
// Add( const SvxTabStop & rTS ) fuegt einen Tab in die WW-Struktur ein
// Tab-Position eintragen
// Tab-Typ eintragen
// Del( const SvxTabStop & rTS ) fuegt einen zu loeschenden Tab
// in die WW-Struktur ein
// Tab-Position eintragen
//  PutAll( WW8Export& rWW8Wrt ) schreibt das Attribut nach rWrt.pO
// cch eintragen
// DelArr schreiben
// InsArr schreiben
// alt noch nicht am Ende ?
// neu noch nicht am Ende
// naechster Tab ist alt
// naechster Tab ist neu
// muss eigefuegt werden
// Tabs sind gleich:
// nichts zu tun
// alten loeschen
// neuen einfuegen


35 / 317 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtw8sty.cxx
// soviele sind reserviert fuer
// Standard und HeadingX u.a.
// das Default-ZeichenStyle ( 0 ) wird nicht mit ausgegeben !
// das Default-TextStyle ( 0 ) wird nicht mit ausgegeben !
// Start auf gerader
// nachtragen
// jetzt neu:
// ab Ver8 gibts zwei Felder mehr:
// Adr1 zum nachtragen der Laenge
// Adr2 zum nachtragen von "end of upx"
// Trotz P-String 0 am Ende!
// Laenge zum Nachtragen
// Keinen Pointer merken, da sich bei
// Laenge zum Nachtragen
// Start auf gerader
// Anzahl wird nachgetragen
// ab Ver8 sind folgende beiden Felder eingeschoben,
// werden von uns ignoriert.
// gleich die Flags am Dop setzen
// das ist also 1.Seite und nachfolgende, also nur den
// default neue Seite beginnen
// fortlaufender Abschnitt
// als Nachkomme wird bei 'deep'-OutputItemSet
// auch der Vorfahr abgeklappert
// am Nachkommen NUR  die Spaltigkeit gemaess Sect-Attr.
// umsetzen
// und raus damit ins WW-File
// Falls damit eine "Erste Seite" simuliert werden soll, so
// koennen wir das auch als solches schreiben.
// Anders sieht es mit Links/Rechts wechseln aus. Dafuer muss
// erkannt werden, wo der Seitenwechsel statt findet. Hier ist
// es aber dafuer zuspaet!
// werden es nur linke oder nur rechte Seiten?
/*
       !!!!!!!!!!!
    // Umrandungen an Kopf- und Fusstexten muessten etwa so gehen:
    // Dabei muss etwas wie pOut eingebaut werden,
    // das bei jeder Spezialtext-Zeile wiederholt wird.
    const SwFrmFmt* pFFmt = rFt.GetFooterFmt();
    const SvxBoxItem& rBox = pFFmt->GetBox(false);
    OutWW8_SwFmtBox1( m_rWW8Export.pOut, rBox, false);
    !!!!!!!!!!!
    You can turn this into paragraph attributes, which are then observed in each paragraph.
    Applies to background / border.
    !!!!!!!!!!!
    */
// Bereich also gueltiger Node


192 / 1912 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par6.cxx
// WW-Default fuer Hor. Seitenraender: 2.5 cm
// WW-Default fuer u.Seitenrand: 2.0 cm
// Seiten - Attribute, die nicht ueber die Attribut-Verwaltung, sondern
//  ueber ...->HasSprm abgearbeitet werden
//  ( ausser OLST, dass weiterhin ein normales Attribut ist )
// 1. Orientierung
// Header -> umrechnen
// kein Header -> Up einfach uebernehmen
// kein Footer -> Lo einfach uebernehmen
// ... und Header-Lower setzen
//Kopfzeilenhoehe minimal sezten
// ... und Footer-Upper setzen
// Seitennummernformat speichern
// Bei jedem Abschnittswechsel ( auch am Anfang eines Dokuments ) wird
// CreateSep gerufen, dass dann den / die Pagedesc(s) erzeugt und
// mit Attributen un KF-Texten fuellt.
// Dieses Vorgehen ist noetig geworden, da die UEbersetzung der verschiedenen
// Seiten-Attribute zu stark verflochten ist.
// 1. Orientierung
//   Hilfsroutinen fuer Grafiken und Apos und Tabellen
// ungueltige Borders ausfiltern
// fuer Berechnung der minimalen FrameSize
// so breit ist max. der Border
// fuer +-1-Fehler, mindestens 1
// Breite       //sprmPDxaWidth
// Breite
// Umrandung
// Block zum rausspringen
// bGrafApo nur bei Hoehe automatisch
// (*pPap)++ geht bei FastSave schief
// -> bei FastSave kein Test auf Grafik-APO
// Block zum rausspringen
// Naechste Zeile
// Nein -> Grafik-Apo
// Neuer FlaPara zum Vergleich
// selber APO ? ( oder neuer ? )
// nein -> 1-zeiliger APO
// Block zum rausspringen
// Block zum rausspringen
// Breite
// Breite
// Umrandung
// Initialisieren
// keine Angabe oder Stuss
// Auto-Breite
// Minimale Breite
// Wenn der Fly links, rechts, oben oder unten aligned ist,
// wird der aeussere Textabstand ignoriert, da sonst
// der Fly an falscher Position landen wuerde
// Problematisch wird es nur bei Innen/Aussen
// Bindung
// aussen
// X - Bindung -> Koordinatentransformation
// hat ein Fly in WW eine automatische Breite, dann muss das durch
// nachtraegliches Anpassen der ( im SW festen ) Fly-Breite simuliert werden.
// Dabei kann die Fly-Breite groesser oder kleiner werden, da der Default-Wert
// ohne Wissen ueber den Inhalt eingesetzt wird.
// Die Klasse WW8FlySet ist von SfxItemSet abgeleitet und stellt auch
// im Prizip nicht mehr zur Verfuegung, ist aber fuer mich besser
// zu handeln
// Abstand/Umrandung raus
// der 5. Parameter ist immer 0, daher geht beim Cast nix verloren
// Groesse einstellen
// WW8FlySet-ctor fuer zeichengebundene Grafiken
// Abstand/Umrandung raus
// Setze Pam in den FlyFrame
// Alle Attribute schliessen, da sonst Attribute entstehen koennen,
// die aus Flys rausragen
// APO-Parameter ermitteln und Test auf bGrafApo
// Innerhalb des GrafApo muessen Textattribute ignoriert werden, da
// sie sonst auf den folgenden Zeilen landen.  Der Rahmen wird nur
// eingefuegt, wenn er *nicht* nur zum Positionieren einer einzelnen
// Grafik dient.  Ist es ein Grafik-Rahmen, dann werden pWFlyPara und
// pSFlyPara behalten und die
// daraus resultierenden Attribute beim Einfuegen der Grafik auf die
// Grafik angewendet.
// 1) ReadText() wird nicht wie beim W4W-Reader rekursiv aufgerufen,
//    da die Laenge des Apo zu diesen Zeitpunkt noch nicht feststeht,
//    ReadText() diese Angabe aber braucht.
// 2) Der CtrlStck wird nicht neu erzeugt.
//    die Char-Attribute laufen weiter ( AErger mit SW-Attributen )
//    Paraattribute muessten am Ende jeden Absatzes zurueckgesetzt
//    sein, d.h. es duerften am Absatzende keine Paraattribute
//    auf dem Stack liegen
// an den Anfang der Zeile gehen
// Grafik-Rahmen, der *nicht* eingefuegt wurde leeren Absatz incl.
// Damit die Frames bei Einfuegen in existierendes Doc erzeugt werden,
// wird in fltshell.cxx beim Setzen des FltAnchor-Attributes
// pFlyFrm->MakeFrms() gerufen
// TestSameApo() beantwortet die Frage, ob es dasselbe APO oder ein neues ist
// Es muss ein kompletter Vergleich ( ausser Borders ) stattfinden, um
// alle Kombinationen Style / Hart richtig einzuordnen. Deshalb wird ein
// temporaerer WW8FlyPara angelegt ( abh. ob Style oder nicht ), darauf
// die harten Attrs angewendet, und dann verglichen
// Zum Vergleich
// zum Ignorieren von Styles beim Doc-Einfuegen
// holt Attribut aus der FmtColl / Stack / Doc
// Die Methoden erhalten die Token-Id und die Laenge der noch folgenden
// Parameter gemaess Tabelle in WWScan.cxx als Parameter
// Read_Obj wird fuer fObj und fuer fOle2 benutzt !
// Stimmt das immer ?
// Read_BoldUsw fuer Italic, Bold, Kapitaelchen, Versalien, durchgestrichen,
// die Attribut-Nr fuer "doppelt durchgestrichen" tanzt aus der Reihe
// umdrehen
// Flag setzen
// Flag loeschen
// im Text -> Flags abfragen
// Bit 7 gesetzt ?
// dann invertieren
// am Stack vermerken, das dieses ein Toggle-Attribut ist
// Bit 7 gesetzt ?
// umdrehen
// Flag setzen
// Flag loeschen
// im Text -> Flags abfragen
// Bit 7 gesetzt ?
// dann invertieren
// am Stack vermerken, das dieses ein Toggle-Attribut ist
// ... nun in % ( gerundet )
// zur Sicherheit
// dann Stack ggfs. verwursteln und exit!
// Parameter: 0 = Auto, 1..16 Farben
// unbekannt -> Black
// Die Defines, aus denen diese Tabellen erzeugt werden, stehen in windows.h
// FontNummer unbekannt ?
// dann ignorieren
// Mac-Font im Mac-Charset oder
// auf ANSI-Charset uebersetzt
// ...und 'reinsetzen
// merken zur Simulation Default-Font
/*
    Font ein oder ausschalten:
*/
// falls bSymbol, gilt der am Symbol
// (siehe sprmCSymbol) gesetzte Font !
// merken zur Simulation Default-FontSize
/*
    Einschalten des Zeichen-Styles:
*/
// ungueltige Id ?
// oder Para-Style ?
// dann ignorieren
/*
    enger oder weiter als normal:
*/
// Zeichenfarbe auch
// Zeichenfarbe auch
// Zeichenfarbe auch
// Parameter: 0 = Auto, 1..16 Farben
// unbekannt -> Black
// Kommentear siehe Read_UL()
// WW hat einen impliziten zusaetzlichen Absatzabstand abhaengig vom
// Zeilenabstand. Er betraegt bei "genau", 0.8*Zeilenabstand "vor" und
// 0.2*Zeilenabstand "nach".
// Bei "Mindestens" sind es 1*Zeilenabstand "vor" und 0*Zeilenabstand "nach".
// Bei Mehrfach sind es 0 "vor" und min( 0cm, FontSize*(nFach-1) ) "nach".
// SW hat auch einen impliziten Zeilenabstand. er betraegt bei "mindestens"
// 1*Zeilenabstand "vor" und 0 "nach"
// bei proportional betraegt er min( 0cm, FontSize*(nFach-1) ) sowohl "vor"
// wie auch "nach"
// nach Absprache mit AMA ist die Begrenzung unsinnig
// bei negativen Space ist der Abstand exakt, sonst minimum
// Nun eine Umpopelung eines WW-Fehlers: Bei nProduct == 0c03d wird
// faelschlicherweise ein DyaAfter 240 ( delta y abstand after, amn.d.?b.)
// im Style "Normal" eingefuegt, der
// gar nicht da ist. Ueber das IniFlag WW8FL_NO_STY_DYA laesst sich dieses
// Verhalten auch fuer andere WW-Versionen erzwingen
//  OSL_ENSURE( !bStyNormal || bWWBugNormal, "+Dieses Doc deutet evtl. auf einen
// Fehler in der benutzten WW-Version hin. Wenn sich die Styles <Standard> bzw.
// <Normal> zwischen WW und SW im Absatz- oder Zeilenabstand unterscheiden,
// dann bitte dieses Doc SH zukommen lassen." );
// bWWBugNormal ist kein hinreichendes Kriterium dafuer, dass der
// angegebene Abstand falsch ist
// Zeichenfarbe auch
// Zeichenfarbe auch
// die Borders auf allen 4 Seiten werden gebuendelt.  dieses
// vereinfacht die Verwaltung, d.h. die Box muss nicht 4 mal auf den
// CtrlStack und wieder runter
// in Apo keine Umrandungen *ein*-schalten, da ich
// sonst die Flyumrandungen doppelt bekomme
// aber nur wenn am Fly ein gesetzt ist, keine
// uebernehmen. Sonst wird gar keine gesetzt!
// auch wenn kein Rand gesetzt ist, muss das Attribut gesetzt
// werden, sonst ist kein hartes Ausschalten von Style-Attrs
// moeglich
// merken zur Simulation
// Seiten - Attribute werden nicht mehr als Attribute gehandhabt
//  ( ausser OLST )
// Arrays zum Lesen der erweiterten ( selbstdefinierten ) SPRMs
// Arrays zum Lesen der SPRMs
// Funktion zum Einlesen von Sprms. Par1: SprmId
// "0" Default bzw. Error
//wird uebersprungen! ,
// "0" Default bzw. Error
//wird uebersprungen! ,
// "0" Default bzw. Error
//      Hilfsroutinen : SPRM finden
//      Hilfsroutinen : SPRMs


1 / 293 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtw8nds.cxx
// Hole vom Node und vom letzten Node die Position in der Section


130 / 312 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par3.cxx
// Zeichenattribute aus GrpprlChpx
// Zeichen Style Pointer
// nur DIE Eintraege, die WIR benoetigen!
// Flag: Liste hat nur EINEN Level
// nur DIE Eintraege, die WIR benoetigen!
// nur DIE Eintraege, die WIR benoetigen!
// Ver6-Compatible: Breite des Prefix Textes; ggfs. zur
// Absatzattribute aus GrpprlPapx
// linker Einzug
// Erstzeilen-Einzug
// Offset der Feldkodes im Num-X-String
// falls true , beachte die V6-Compatible Eintraege!
// (macht das Byte voll)
// dieses Byte ist _absichtlich_ nicht in das folgende Byte hineingepackt   !!
// (siehe Kommentar unten bei struct WW8LFOInfo)
// in den ListenInfos zu speichernde Daten
// sortiert nach nIdLst (in WW8 verwendete Listen-Id)
// Zeichenattribute aus GrpprlChpx
// Zeichen Style Pointer
// Zeiger auf entsprechende Listenvorlage im Writer
// WW8Id dieser Liste
// Flag, ob diese NumRule nur einen Level verwendet
// Flag, ob diese NumRule im Doc verwendet wird,
//   oder beim Reader-Ende geloescht werden sollte
// in den ListenFormatOverrideInfos zu speichernde Daten
// unsortiert, d.h. Reihenfolge genau wie im WW8 Stream
// Zeiger auf entsprechende Listenvorlage im Writer
// entweder: Liste in LSTInfos oder eigene Liste
// (im Ctor erstmal die aus den LSTInfos merken)
// Ja, ich natuerlich koennten wir nLfoLvl (mittels :4) noch in das folgende
// Byte mit hineinpacken, doch waere das eine ziemliche Fehlerquelle,
// an dem Tag, wo MS ihr Listenformat auf mehr als 15 Level aufbohren.
// Flag, ob die NumRule nicht in maLSTInfos steht,
//   sondern fuer pLFOInfos NEU angelegt wurde
// Flag, ob diese NumRule nur einen Level verwendet
// Flag, ob diese NumRule im Doc verwendet wird,
//   oder beim Reader-Ende geloescht werden sollte
// Flag, ob bUsedInDoc in maLSTInfos gesetzt wurde,
//   und nicht nochmals gesetzt zu werden braucht
// finden der Sprm-Parameter-Daten, falls Sprm im Grpprl enthalten
// Zugriff ueber die List-Id des LST Eintrags
// Ausrichtung (Links/rechts/zent.)
// 1. LVLF einlesen
// 2. ggfs. PAPx einlesen und nach Einzug-Werten suchen
// 3. ggfs. CHPx einlesen und
// neues ItemSet fuer die Zeichenattribute anlegen
// Reader-ItemSet-Pointer darauf zeigen lassen
// Reader-Style auf den Style dieses Levels setzen
// Nun den GrpprlChpx einfach durchnudeln: die Read_xy() Methoden
// in WW8PAR6.CXX rufen ganz normal ihr NewAttr() oder GetFmtAttr()
// und diese merken am besetzten Reader-ItemSet-Pointer, dass dieser
// spezielle ItemSet relevant ist - und nicht ein Stack oder Style!
// Reader-ItemSet-Pointer und Reader-Style zuruecksetzen
// 4. den Nummerierungsstring einlesen: ergibt Prefix und Postfix
// 5. gelesene Werte in Writer Syntax umwandeln
// eigentlich: ORDINAL
// akt. Anzeigetiefe fuer den Writer
// falls kein NULL als Terminierungs-Char kam,
// ist die Liste voller Indices, d.h. alle Plaetze sind besetzt,
// also sind alle Level anzuzeigen
// 6. entsprechendes NumFmt konfigurieren
// Don't forget: unten, nach dem Bauen eventueller Styles auch noch
// SetBulletFont() rufen !!!
// reminder: Garnix ist default Prefix
// ggfs. passenden pItem im pLowerLevelItemSet finden
// falls kein Item mit gleicher nWhich gefunden oder Werte
// der Items ungleich, Ungleichheit merken und abbrechen!
// Attribute reinsetzen
// passenden Style hier anhaengen
// Style an das NumFormat haengen
// ggfs. Bullet Font an das NumFormat haengen
// und wieder rein in die NumRule
// wird erstmal zur Bildung des Style Namens genommen
// oeffentliche Methoden
// LST und LFO gibts erst ab WW8
// offensichtlich keine Listen da
// 1. PLCF LST auslesen und die Listen Vorlagen im Writer anlegen
// 1.1.1 Daten einlesen
// 1.2.1 betreffende(n) LVL(s) fuer diese aLST einlesen
// LVLF einlesen
// und in die rMyNumRule aufnehmen
// 1.2.2 die ItemPools mit den CHPx Einstellungen der verschiedenen
//       Level miteinander vergleichen und ggfs. Style(s) erzeugen
// 1.2.3 ItemPools leeren und loeschen
// 2. PLF LFO auslesen und speichern
// soviele Overrides existieren
// die Parent NumRule der entsprechenden Liste ermitteln
// hier, im ersten Schritt, erst mal diese NumRule festhalten
// hat die Liste mehrere Level ?
// und rein ins Merk-Array mit dem Teil
// 2.2 fuer alle LFO die zugehoerigen LFOLVL einlesen
// stehen hierfuer ueberhaupt LFOLVL an ?
// 2.2.1 eine neue NumRule fuer diese Liste anlegen
// Nauemsprefix aufbauen: fuer NumRule-Name (eventuell)
// und (falls vorhanden) fuer Style-Name (dann auf jeden Fall)
// jetzt dem pNumRule seinen RICHTIGEN Wert zuweisen !!!
// Dazu erst mal nachsehen, ob ein Style diesen LFO
// referenziert:
// 2.2.2 alle LFOLVL (und ggfs. LVL) fuer die neue NumRule
// einlesen
// Zeichenattribute aus GrpprlChpx
// Zeichen Style Pointer
// 2.2.2.1 den LFOLVL einlesen
// beachte: Die Witzbolde bei MS quetschen die
// Override-Level-Nummer in vier Bits hinein, damit sie
// wieder einen Grund haben, ihr Dateiformat zu aendern,
// falls ihnen einfaellt, dass sie eigentlich doch gerne
// bis zu 16 Listen-Level haetten.  Wir tun das *nicht*
// (siehe Kommentar oben bei "struct
// 2.2.2.2 eventuell auch den zugehoerigen LVL einlesen
// falls bStartup true, hier den Startup-Level
// durch den im LVL vermerkten ersetzen LVLF
// einlesen
// 2.2.2.3 das NumFmt in die NumRule aufnehmen
// 2.2.3 die LVL der neuen NumRule anpassen
// 2.2.4 ItemPools leeren und loeschen
// und schon sind wir fertig!
//          SwWW8ImplReader:  anhaengen einer Liste an einen Style oder Absatz
// Phase 1: Nummerierungsattribute beim Einlesen einer StyleDef
// jetzt nur die Parameter vermerken: die tatsaechliche Liste wird
// spaeter drangehaengt, wenn die Listendefinitionen gelesen sind...
// Phase 2: aktualisieren der StyleDef nach einlesen aller Listen
// beachte: die Methode haengt die NumRule an den Text Node, falls
// bSetAttr (dann muessen natuerlich vorher die Listen gelesen sein)
// stellt sie NUR den Level ein, im Vertrauen darauf, dass am STYLE eine
// NumRule haengt - dies wird NICHT ueberprueft !!!
// sind wir erst beim Einlesen der StyleDef ?
// die Streamdaten sind hier Null basiert, so wie wir es brauchen
// die Streamdaten sind hier 1 basiert, wir ziehen EINS ab
// Das Control-Model am Control-Shape setzen


4 / 92 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtw8num.cxx
// UEberhaupt Nummerierung ?
// -> suche, ob noch Zahlen davor
// Nummerierung drueber ?
// dann Punkt einfuegen


2 / 44 | libreoffice-4.4.0.3/sw/source/filter/ww8/writerhelper.cxx
// exitiert schon ein Layout, dann muss an dieser Tabelle die BoxFrames
// neu erzeugt


17 / 428 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8struc.hxx
// jetzt neu:
// ab Ver8 gibts zwei Felder mehr:
/** Basis zum Einlesen UND zum Arbeiten (wird jeweils unter schiedlich beerbt)
*/
/** Hiermit arbeiten wir im Parser (und Dumper)
*/
// ab Ver8 als Unicode
// Vorsicht: Dieses Array kann auch kleiner sein!!!
/* a c h t u n g :     es duerfen keine solchen Bitfelder ueber einen eingelesenes Byte-Array
                            gelegt werden!!
                            stattdessen ist ein aBits1 darueber zu legen, das mit & auszulesen ist
    GRUND: Compiler auf Intel und Sparc sortieren die Bits unterschiedlich
    */
// hiermit wird weitergearbeitet (entspricht weitestgehend dem Ver8-Format)
// reserved - nicht loeschen: macht das sal_uInt16 voll !!
// wird aus der Datei gelesen
// wird aus der Datei gelesen
// Dokumentation siehe oben unter WW8_TCell
// Dokumentation siehe oben unter WW8_TCell
// struct SHD fehlt in der Beschreibung
// 2=Dotted, 3=Dash Dot, 4=Dash Dot Dot, 5=Hollow
// Schattierung!
// alle Member an gleicher Position und Groesse,


10 / 529 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par2.cxx
// Auto == false-> Nummerierungsvorlage
// pNd->UpdateNum ohne Regelwerk gibt GPF spaetestens beim Speichern als
// WW:10 = numberierung -> SW:0 & WW:11 = bullets -> SW:0
// wegen Sonderbehandlung Raender-Defaults
// am Ende einschleifen
// 1. Durchlauf: aeusserste L- und R-Grenzen finden
// mangel mit Defaults ueber
// keine rekursiven Tabellen Nicht bei EinfuegenDatei in Tabelle oder
// If Style basiert auf Nichts oder Basis ignoriert
// "Absatz-Standardschriftart" ( Style-ID 65 ).


80 / 270 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par.hxx
// defines nur fuer die WW8-variable der INI-Datei
// keine Zeichenstyles importieren
// falls gestetzt, werden fuer Writer-Def-Styles neue Styles mit den
// WW8-Def-Style-Eigenschaften erzeugt, statt die Writer-Standards zu
// ueberschreiben
// Zusatz-Filter-Flags, gueltig ab Winword 8
// D. aus PLF LFO, sortiert genau wie im WW8 Stream
// Zeichenattribute aus GrpprlChpx
// Zeichen Style Pointer
// Achtung: *Nicht* umsortieren, da Teile mit
// memcmp verglichen werden
// Breite / Hoehe
// rohe Bindung + Alignment
// Umrandung Top, Left, Bottom, Right, Between
// Umrandungslinien
// true: Dieser Rahmen dient allein dazu, die
// enthaltene Grafik anders als zeichengebunden
// zu positionieren
// leer oder Valid
// true-> pFmt ist SwTxtFmtColl
// nur true bei !bNewDoc && vorh. Style
// true-> Benannter NumRule in Style
//    Mini-Merker fuer einige Flags
// allgemeines
// Stack fuer die Attribute
// Control-Implementierung
// Pointer auf die Style-Einleseklasse
// gerade zu erzeugende Collection
// ( ist ausserhalb einer Style-Def immer 0 )
// gerade einzulesende Zeichenattribute
// (ausserhalb des WW8ListManager Ctor's immer 0)
// Pointer auf Header / Footer - Scannerklasse
// daraus erzeugte Sw-Parameter
// Beschreibung der Tabelleneigenschaften
// Gliederung im Text
// Flags aus der writer.ini
// dito ( zusaetzliche Flags )
// dito fuers Taggen von nicht importierbaren F.
// Anfang der Txbx-SubDocs
// X-Verschiebung von Flys
// Y-Verschiebung von Flys
// gemaess WW-Zaehlung
// laufende Nummer dafuer
// gemaess WW-Zaehlung, <0 fuer keine
// aktuell einzulesendes Symbolzeichen
// urspruenglich vom Writer
// angeforderte WW-Doc-Version
// LevelNummer fuer Outline / Nummerierung
// Gliederung / Nummerg / Aufzaehlg
// Keine Tabellen
// Page- oder Sectionbreak ist noch einzufuegen
// Special-Char im Text folgt
// Obj im Text
// FlyFrame, der als Ersatz fuer Winword Textbox eingefuegt wurde
// fuer Buendelung der Border
// wird gerade eine Tabelle eingelesen
// Textfarbe indirekt gesetzt ( Hintergrund sw )
// Textfarbe indirekt gesetzt ( Zeichenhintergrund sw )
// Nummerierung in Bearbeitung
// Fussnote oder Endnote
// Text aus Header wird gelesen ( Zeilenhoehe )
// Text aus Footer wird gelesen ( Zeilenhoehe )
// aktuelles Text-Stueck ist als 2-Bytiger-Unicode kodiert
// bitte NICHT als Bitfeld kodieren!
// Style im Complex Part
// Style mit Id 0 wird gelesen
// Attribute ignorieren zum Ignorieren v. Styles
// Sonderfall zum einlesen eines 0x01
// siehe: SwWW8ImplReader::Read_F_Hyperlink()
// praktische Hilfsvariablen:
// Nummerierungen / Aufzaehlungen ( Autonumbered List Data Descriptor )
//   eine Ebene: ANLV ( Autonumber Level Descriptor )
// Listen sind in WW8 eigene Strukturen, die ueber folgende drei Tabellen
// verwaltet werden: rglst, hpllfo und hsttbListNames
// die Strukturen hierfuer sind: LSTF, LVLF, LFO LFOLVL
// spaeter zu ersetzen durch Aufruf in entsprechend erweiterten SvxMSDffManager
// Schnittstellen fuer die Toggle-Attribute
// eigentlich private, geht aber leider nur public
// Gliederungsebene Ver8
// Laden eines kompletten DocFiles


3 / 121 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtww8gr.cxx
// eingefuegt, der statt Adresse ein Magic sal_uLong enthaelt. Ausserdem wird
// in der Graf-Klasse der GrfNode-Ptr gemerkt ( fuers spaetere Ausgeben der
// Grafiken und Patchen der PicLocFc-Attribute )


71 / 641 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8scan.hxx
///< Gesamtlaenge ( zum Text ueberlesen )
///< Anfang Ergebnis
///< Laenge ( == 0, falls kein Ergebnis )
///< WW-Flags ( z.B.: vom User geaendert )
///< Befehl rekursiv verwendet
///< Befehl in Resultat eingefuegt
/**
    u.a. fuer Felder, also genausoviele Attr wie Positionen,
    falls Ctor-Param bNoEnd = false
*/
///< Pointer auf Pos-Array und auf ganze Struktur
///< Pointer auf Inhalts-Array-Teil des Pos-Array
///< Anzahl der Elemente
///< Merker, wo wir gerade sind
// geht ueber FC- bzw. CP-Wert
// bzw. naechste groesseren Wert
/* u.a. fuer FKPs auf normale Attr., also ein Attr weniger als Positionen */
// Pointer auf Pos-Array und auf ganze Struktur
// Pointer auf Inhalts-Array-Teil des Pos-Array
// Anzahl der Elemente
/*
        Falls im Dok ein PLC fehlt und die FKPs solo dastehen,
        machen wir uns hiermit einen PLC:
    */
/*
        folgender Ctor generiert ggfs. einen PLC aus nPN und ncpN
    */
// Pointer auf Pos-Array und auf ganze Struktur
// Pointer auf Inhalts-Array-Teil des Pos-Array
/* mehrere WW8PLCFpcd_Iter koennen auf die gleiche WW8PLCFpcd zeigen !!!  */
// PLCF von Sprms oder von anderem ( Footnote, ... )
// Attribut Anzahl davon
// entweder 1 Byte oder ein komplettes BX
// Anzahl der Eintraege
/*
            liefert einen echten Pointer auf das Sprm vom Typ nId,
            falls ein solches im Fkp drin ist.
        */
/*
            ruft GetLenAndIStdAndSprms() auf...
        */
/// Iterator fuer Piece Table Exceptions of Fkps arbeitet auf CPs (High-Level)
/// Iterator fuer Fuss-/Endnoten und Anmerkungen
//liefert Angabe, wo Kopf und Fusszeilen-Text zu finden ist
/*
    hiermit arbeiten wir draussen:
*/
// wird nur vom Aufrufer benutzt
// Sprm-Id ( 0 = ungueltige Id -> ueberspringen! )
// (2..255) oder Pseudo-Sprm-Id (256..260)
// bzw. ab Winword-Ver8 die Sprm-Id (800..)
// Absatz- oder Section-Anfang
// neue Zeile
// neue Section
/*
    hiermit arbeitet der Manager drinnen:
*/
// Speicher fuer Attr-Id fuer Attr-Ende(n)
// wo liegen die Sprm(s)
// wo liegen die NoSprm(s)
// wie viele Bytes fuer weitere Sprms / Laenge Fussnote
// fuer Erkennung erster Sprm einer Gruppe
// false bei Pap-Piece-Ende
// zeigt *hinter* das <CR>
/*
        Where fragt, an welcher naechsten Position sich irgendein
        Attr aendert...
    */
/* fragt, ob *aktueller Absatz* einen Sprm diesen Typs hat */
/* fragt, ob *aktueller Textrun* einen Sprm diesen Typs hat */
// Anmerkungen
// Fields in Anmerkungen
// Anzahl davon
/*
        vom Ctor aus dem FIB gelesene Daten
        (entspricht nur ungefaehr der tatsaechlichen Struktur
         des Winword-FIB)
    */
// 0x4 product version written by
// Einschub fuer WW8
// Ende des Einschubs fuer WW8
// Einschub fuer WW8
// Ende des Einschubs fuer WW8
// Ende des Einschubs fuer WW67
/*
        spezielle Listenverwaltung fuer WW8
    */
/*
        spezielle Break-Verwaltung fuer Text-Box-Stories in WW8
    */
// 0x02f2 PLCF fuer TextBox-Break-Deskriptoren im Maintext
// 0x02fa PLCF fuer TextBox-Break-Deskriptoren im Header-/Footer-Bereich
/*
        General-Varaiblen, die fuer Ver67 und Ver8 verwendet werden,
        obwohl sie in der jeweiligen DATEI verschiedene Groesse haben:
    */
/*
        nun wird lediglich noch ein Ctor benoetigt
    */
/* leider falsch, man braucht auch noch einen fuer den Export */
// hier sollte bei nFib < 103   Schluss sein, sonst ist Datei fehlerhaft!
/*
        bei nFib >= 103 gehts weiter:
    */
// hier sollte bei nFib <= 105  Schluss sein, sonst ist Datei fehlerhaft!
/*
        bei nFib > 105 gehts weiter:
    */


106 / 387 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8graf.cxx
// Farbtabelle zum Umrechnen RGB-Werte in vordefinierte Farben
// ( Damit bei der Writer-UI die Farbnamen stimmen )
// Die Tabelle int im *3er-System* aufgeteilt. Die Grauwerte fehlen,
// da sie nicht ins 3er-System passen ( 4 Werte: sw, ws, 2 * grau )
// In nWC[3] steht ein Byte, dass in der WW-Doku nicht beschrieben ist.
// Die Bedeutung ist anscheinend folgende: Bei 0 ist es eine normale
// Farbe, dessen RGB-Wert in nWC[0..2] steht. stehen in nWC[3] die
// Werte 0x1, 0x7d oder 0x83, dann ist es ein Grauwert, dessen
// Schwarzanteil in 1/2 % in nWC[0] steht.
// Ich vermute, dass es auf Bit0 in nWV[3] ankommt, ob es RGB oder Grau ist.
// keine Spezial-Farbe (grau)
// R-Anteil
// G-Anteil
// B-Anteil
// ReadGrafStart liest die ObjektDaten ein und erzeugt falls noetig einen Anker
// SetStdAttr() setzt die Attribute, die jedes Objekt hat
// sichtbar
// SetFill setzt Fuellattribute wie Vordergrund- und Hintergrund-Farbe
// und Muster durch Reduktion auf eine Farbe.
// SetFill() setzt z.Zt kein Muster, da Sdr das nur sehr umstaendlich kann
// und die Sdr-Schraffur ( XDash ) noch nicht fertig ist.
// Statt dessen wird eine Mischfarbe gewaehlt, die auf den entsprechenden
// Farbton zwischen den Farben liegt.
// Ab hier folgen die Routinen fuer die einzelnen Objekte
// Beim Ende erst 1 Zeichen spaeter auf naechste Zeile umschalten,
// da sonst Zeilenattribute immer eine Zeile zu weit reichen.
// InsertTxbxStyAttrs() setzt die Style-Attribute in den uebergebenen ItemSet.
// Es werden die SW-Styles genommen, die Import-WW-Styles sind zu diesem
// Zeitpunkt schon destruiert.
// Die SW-Styles werden per Tiefensuche, d.h. mit Parent-Styles nach den
// in aSrcTab angegebenen Attributen untersucht. Diese werden per Clone
// dupliziert, bei den Duplikaten werden die Which-IDs
// gemaess der Tabelle aDstTab umgesetzt, damit die EditEngine sie nicht
// Es werden hierbei sowohl Para- wie auch Zeichen-Attribute in den
// InsertAttrsAsDrawingAttrs() setzt zwischen StartCp und EndCp die Attribute.
// Dabei werden Style-Attribute als harte Attribute, Absatz- und Zeichen-
// attribute gesetzt.
// ggfs. zuerst die richtige TextBox-Story finden
// jetzt ggfs. die passende Page in der Break-Table finden
// Sonderfall: gesamte(!) Kette soll ermittelt werden,
//             dann sind wir hier schon fertig!
// rasch den TextBox-Break-Deskriptor-PLCF greifen
// den ersten Eintrag fuer diese TextBox-Story finden
// ggfs. entsprechende Anzahl Eintraege weitergehen
// dann die tatsaechlichen Start und Ende ermitteln
// kein Error: leerer String!
// TxbxText() holt aus WW-File den Text und gibt diesen und den Anfangs- und
// den um -2 (bzw. -1 bei Ver8) korrigierten End-Cp zurueck
// leerer String: durchaus denkbar!
// den Text einlesen: kann sich ueber mehrere Pieces erstrecken!!!
// InsertTxbxText() fuegt fuer TextBoxen und CaptionBoxen den Text
// und die Attribute ein
// SdrTextObj in dessen Gruppe einsetzen
// Fuer die naechste Textbox noch die alten Absatz-Attribute
// und Styles entfernen, sonst startet die naechste Box
// mit falschen Attributen.
// Vorgehen: Text loeschen = auf 1 Absatz reduzieren
// und an diesem Absatz die Absatzattribute und Styles loeschen
// (Empfehlung JOE)
// Umrandung sichtbar ?
// nein -> Nimm Linie
// Vorsichtsmassmahme
// unbekannt
/*
    Beachte: im Gegensatz zu den Winword-ueblichen Tabellen- und
    Rahmen-Randbreiten-Angaben, bei denen jeweils aus der Staerke *einer*
    Linie die Gesamt-Randbreite zu errechnen ist, liegen die aus dem ESCHER
    stammenden Daten bereits als Gesamt-Breite [twips] vor!

    Der Winword default ist 15 tw. Wir nehmen hierfuer unsere 20 tw Linie.  (
    0.75 pt uns 1.0 pt sehen sich auf dem Ausdruck naemlich aehnlicher als
    etwas 0.75 pt und unsere 0.05 pt Haarlinie. ) Die Haarlinie setzen wir nur
    bei Winword-Staerken bis zu maximal 0.5 pt ein.
    */
/*
    Beachte: im Gegensatz zu den Winword-ueblichen Tabellen- und
    Rahmen-Randbreiten-Angaben, bei denen jeweils aus der Staerke *einer*
    Linie die Gesamt-Randbreite zu errechnen ist, liegen die aus dem ESCHER
    stammenden Daten bereits als Gesamt-Breite [twips] vor!

    Der Winword default ist 15 tw. Wir nehmen hierfuer unsere 20 tw Linie.  (
    0.75 pt uns 1.0 pt sehen sich auf dem Ausdruck naemlich aehnlicher als
    etwas 0.75 pt und unsere 0.05 pt Haarlinie. ) Die Haarlinie setzen wir nur
    bei Winword-Staerken bis zu maximal 0.5 pt ein.
    */
// zuerst die Einzel-Linien
// dann die Doppel-Linien, fuer die wir feine Entsprechungen haben :-)))
/*
    am Rahmen zu setzende Frame-Attribute
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SwFmtFrmSize            falls noch nicht gesetzt, hier setzen
    SvxLRSpaceItem          hier setzen
    SvxULSpaceItem          hier setzen
    SvxOpaqueItem           (Derzeit bei Rahmen nicht moeglich! khz 10.2.1999)
    SwFmtSurround           bereits gesetzt
    SwFmtVertOrient         bereits gesetzt
    SwFmtHoriOrient         bereits gesetzt
    SwFmtAnchor             bereits gesetzt
    SvxBoxItem              hier setzen
    SvxBrushItem            hier setzen
    SvxShadowItem           hier setzen
*/
// einige Items koennen direkt so uebernommen werden
// jetzt die Umrandung berechnen und die Box bauen: Das Mass wird fuer die
// Rahmen-GROESSE benoetigt!
// dashed oder solid wird zu solid
// jetzt die Umrandung setzen
// Schattenwurf der Box: SvxShadowItem
// bei Modus 2 oder 4 auch den Zusatzparameter beruecksichtigen
// Winword kann nur Aussen-Konturen
// eingelesenes Objekt (kann eine ganze Gruppe sein) jetzt korrekt
// positionieren usw.
// Pruefen, ob Gruppenobjekt (z.B. zwei Klammern) vorliegt
// Gruppenobjekte haben keinen Text. Fuege ein Textobjekt in die
// Gruppe ein, um den Text zu halten.
// Objekt ist Bestandteil einer Gruppe?
// wurde dieses Objekt ersetzt ??
// Objekt wurde bereits (in der Gruppe und) der Drawing-Page
// durch ein neues SdrGrafObj ersetzt.
// Objekt in der Z-Order-Liste ersetzen
// Objekt jetzt noch loeschen
// und das neue Objekt merken.
// Objekt aus der Z-Order-Liste loeschen
// Objekt aus der Drawing-Page rausnehmen
// und FrameFormat entfernen, da durch Grafik ersetzt (dies
// loescht auch das Objekt)
// auch den Objektmerker loeschen
// ww8-default Randabstand einsetzen
// mehrfaches Auftreten gleicher Grafik-Namen vermeiden
// falls alles Ok, Zeiger auf neues Objekt ermitteln und Z-Order-Liste
// entsprechend korrigieren (oder Eintrag loeschen)
// altes Objekt aus der Z-Order-Liste entfernen
// aus der Drawing-Page rausnehmen
// und das Objekt loeschen
/*
        Achtung: ab jetzt nur noch pOrgShapeObject abfragen!
    */
// Kontakt-Objekt in die Z-Order-Liste und die Page aufnehmen
// Das Kontakt-Objekt MUSS in die Draw-Page gesetzt werden, damit in
// SwWW8ImplReader::LoadDoc1() die Z-Order festgelegt werden kann !!!
// Fuer SVDraw und VCControls und Escher
// evtl. von Grafik angelegt


19 / 321 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtww8.hxx
// einige Forward Deklarationen
// Verwaltung
// Pos der einzelnen Header / Footer
// bOutPageDesc muss nicht gesichert werden, da es nur nicht waehrend der
// Ausgabe von Spezial-Texten veraendert wird.
// Pointer auf Piece-Table
///<       in/an dem ein Fly verankert ist
// zur Justierung eines im Writer als
// Zeichen gebundenen Flys, der im WW
// Absatzgebunden wird.
// escher export class
//    SwTwips nFlyWidth, nFlyHeight;  // Fuer Anpassung Graphic
// ( wird zB bei Flys in Tabelle zurueckgesetzt )
// Die Absatz- und Textattribute des Writers kommen rein, und es wird
// mit Where() die naechste Position geliefert, an der sich die Attribute
// aendern. IsTxtAtr() sagt, ob sich an der mit Where() gelieferten Position
// ein Attribut ohne Ende und mit \xff im Text befindet.
// Mit OutAttr() werden die Attribute an der angegebenen SwPos
// ausgegeben.


22 / 252 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtw8esh.cxx
// Fuer DrawObjets muss ein Spezial-Zeichen
// in den Text und darum ein fSpec-Attribut
// Attributwechsel an Pos 0 wird ignoriert, da davon ausgegangen
// wird, dass am Absatzanfang sowieso die Attribute neu ausgegeben
// der erste Parameter in SearchNext() liefert zurueck, ob es ein TxtAtr ist.
// gibt erstes Attr-Zeichen
// gibt letztes Attr-Zeichen + 1
// HasTextItem nur in dem obigen Bereich erlaubt
// HasItem ist fuer die Zusammenfassung des Doppel-Attributes Underline
// und WordLineMode als TextItems. OutAttr() ruft die Ausgabefunktion,
// die dann ueber HasItem() nach anderen Items an der
// Attribut-Anfangposition fragen kann.
// Es koennen nur Attribute mit Ende abgefragt werden.
// Es wird mit bDeep gesucht
// dann kommt da nichts mehr
// Am Zeilenende werden die Attribute bis ueber das CR
// aufgezogen. Ausnahme: Fussnoten am Zeilenende
// Ausgabe der Zeichenattribute
// Ausnahme: Fussnoten am Zeilenende
// PPT arbeitet nur mit Einheiten zu 576DPI
// WW hingegen verwendet twips, dh. 1440DPI.
// MS-DFF-Properties sind grossteils in EMU (English Metric Units) angegeben


14 / 342 | libreoffice-4.4.0.3/sw/source/filter/ww8/wrtww8.cxx
// ab hier grpprls
// Werte aus der DocStatistik (werden aufjedenfall fuer die
// fuer jedes FKP die Page ausgeben
// selber FC ohne Sprm wird ohne zu mosern ignoriert.
// wenn bCombined, dann ist das Array ab pFkp schon Bytemaessig auf LittleEndian
// umgedreht, d.h. zum Herausholen der Anfangs- und Endpositionen muss
// zurueckgedreht werden.
// WriteShort() traegt an FilePos nPos den Wert nVal ein und seekt auf die
// alte FilePos zurueck. Benutzt zum Nachtragen von Laengen.
// Tabelle in Sonderbereichen erkennen
// Zeilenhoehe ausgeben   sprmTDyaRowHeight
// dann besorge mal die Seitenbreite ohne Raender !!
// Ausgabe in WordDocument-Stream
// dggInfo - escher stream


18 / 67 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par4.cxx
// Skalierungsfaktoren holen:
//      Informationen in PIC-Stream ( durch ausprobieren )
//      0x2c, 0x30 Skalierung x,y in Promille
// *pSt >> aWMF  geht nicht ohne placable Header
// MetaFile auf neue Groesse skalieren und
// neue Groesse am MetaFile setzen
// 03-META-Stream nicht da. Vielleicht ein 03-PICT ?
// Ist der 01Ole-Stream ueberhaupt vorhanden
// Mac-Pict steht im 03PICT-StorageStream allerdings ohne die ersten 512
// Bytes, die bei einem MAC-PICT egal sind ( werden nicht ausgewertet )
// Abstand/Umrandung raus
// OLE im Rahmen ?  ok, Rahmen auf Bildgroesse vergroessern (
// nur wenn Auto-Breite )
// Ole-Object wurde eingefuegt
// das brauchen wir nicht mehr
// 03-META-Stream nicht da. Vielleicht ein 03-PICT ?
// PICT: kein WMF da -> Grafik statt OLE
// StorageStreams wieder zu


71 / 470 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par5.cxx
// FindPara() findet den ersten Parameter mit '\' und cToken. Es wird
// ein neuer String allokiert ( der vom Aufrufer deallokiert werden muss )
// und alles, was zum Parameter gehoert, wird in ihm zurueckgeliefert.
// Anfuehrungszeichen vor Para
// Anfuehrungszeichen ueberlesen
// ab hier nach Ende suchen
// keine Anfuehrungszeichen
// ab hier nach Ende suchen
// r"omisch
// alphabetisch, alphabetic
// Am Ende des Einlesens entsprechende Felder updaten ( z.Zt. die Referenzen )
// JP: neu fuer alles wichtige
// Datenbank-Felder auch
// Read_Field liest ein Feld ein oder, wenn es nicht gelesen werden kann,
// wird 0 zurueckgegeben, so dass das Feld vom Aufrufer textuell gelesen wird.
// Returnwert: Gesamtlaenge des Feldes ( zum UEberlesen )
// Resultat nicht als Text
// Resultat nicht als Text
// keine Routine vorhanden
// Resultat nicht als Text
// Lese nur Resultat
// Result nested -> nicht brauchbar
// so viele ueberlesen, das Resultfeld
// wird wie Haupttext eingelesen
// so viele ueberlesen, das Resultfeld wird wie Haupttext
// eingelesen
// oder ignorieren
// auf Char 1 positionieren
// MakeTagString() gibt als Returnwert die Position des ersten
// CR / Zeilenende / Seitenumbruch in pText und wandelt auch nur bis dort
// Wenn keins dieser Sonderzeichen enthalten ist, wird 0 zurueckgeliefert.
// Typographische Anfuehrungszeichen
// gegen normale tauschen
// 19..21 zu {|}
// ausgeben ?
// mit 0x19 am Anfang
// Gesamtlaenge mit Resultat u. Nest
// MaxLaenge, durch Quoten
// GetFieldResult alloziert einen String und liest das Feld-Resultat ein
// macht ohne Textmarke keinen Sinn
// Nummer um eins erhoehen (default)
/* kann alle INFO-Vars!! */
// SH: Das SwAuthorField bezeichnet nicht den urspruenglichen
// Autor, sondern den aktuellen Benutzer, also besser ueber DocInfo
// Sowohl das Datum- wie auch das Uhrzeit-Feld kann fuer Datum, fuer Uhrzeit
// oder fuer beides benutzt werden.
// den Converter-Namen ueberlesen
/*
            Besonderheit:

            Wir setzen jetzt den Link ins Doc und merken uns den SwFlyFrmFmt.
            Da wir ja unten auf jjeden Fall mit Return-Wert FLD_READ_FSPA enden,
            wird der Skip-Wert so bemessen, dass das folgende Char-1 eingelesen
            wird.
            Wenn wir dann in SwWW8ImplReader::ImportGraf() reinlaufen, wird
            erkannt, dass wir soeben einen Grafik-Link inserted haben und
            das passende SwAttrSet wird ins Frame-Format eingesetzt.
        */
// Bereich aus Quelle ( kein Switch ) ?
// Datenbank: Nichts
// Datenbank: Nichts
// Datenbank: Nichts
// TOX_OUTLINELEVEL setzen wir genau dann, wenn
// die Parameter \o in 1 bis 9 liegen
// oder der Parameter \f existiert
// oder GARKEINE Switches Parameter angegeben sind.
// Delimiter statt Tabstop vor der Seitenzahl einsetzen,
// falls es eine Seitenzahl gibt:
// TOX_OUTLINELEVEL setzen wir genau dann, wenn
// die Parameter \o in 1 bis 9 liegen
// oder der Parameter \f existiert
// oder GARKEINE Switches Parameter angegeben sind.
// Delimiter statt Tabstop vor der Seitenzahl einsetzen,
// falls es eine Seitenzahl gibt:
// Seitenzahl und ggfs. davorstehenden Tabstop
// Setze Anfang in Stack
// Setze Ende in Stack
// das Resultat uebernehmen
// Vorsicht: Bei Feldnamen mit Umlauten geht das MEMICMP nicht!
// kein Feld zu finden
// keine Mehrfachnennungen moeglich


2 / 573 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par.cxx
/*
        Import revisioning data: author names
    */
/*
        zuerst(!) alle Styles importieren   (siehe WW8PAR2.CXX)
            VOR dem Import der Listen !!
    */


47 / 101 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8graf2.cxx
// escher count
// InsertObj() fuegt das Objekt in die Sw-Page ein und merkt sich die Z-Pos in
// einem VarArr
// Parallel zu dem Obj-Array im Dokument baue ich ein Array auf,
// dass die Ww-Height ( -> Wer ueberdeckt wen ) beinhaltet.
// Anhand dieses VARARR wird die Einfuegeposition ermittelt.
// Der Offset bei Datei in bestehendes Dokument mit Grafiklayer einfuegen
// muss der Aufrufer den Index um mnNoInitialObjects erhoeht werden, damit die
// neuen Objekte am Ende landen ( Einfuegen ist dann schneller )
// Grafik in File schreiben
// BMP-File ( nicht embeddet ) oder GIF
// TIFF-File ( nicht embeddet )
// Name als P-String einlesen
// Datei anschliessend nicht loeschen
// Einlesen OK
// im WMF steht nur "Benutzen sie Word 6.0c" Mac-Pict steht dahinter
// allerdings ohne die ersten 512 Bytes, bei einem MAC-PICT egal sind (
// werden nicht ausgewertet )
// SdrGrafObj anstatt des SdrTextObj in dessen Gruppe einsetzen
// altes Objekt raus aus Gruppen-Liste und neues rein
// (dies tauscht es ebenfalls in der Drawing-Page aus)
// MakeGrafNotInCntnt setzt eine nicht-Zeichengebundene Grafik
// Vertikale Verschiebung durch Zeilenabstand
// Damit die Frames bei Einfuegen in existierendes Doc erzeugt werden:
// MakeGrafInCntnt fuegt zeichengebundene Grafiken ein
// dann sollte ists ein OLE-Object
// dann eben als Graphic
// Grafik im Rahmen ? ok, Rahmen auf Bildgroesse vergroessern
//  ( nur wenn Auto-Breite )
// Grafik nicht korrekt eingelesen
/*
        kleiner Spass von Microsoft: manchmal existiert ein Stream Namens DATA
        Dieser enthaelt dann den PICF und die entsprechende Grafik !!!
        Wir mappen ansonsten die Variable pDataStream auf pStream.
    */
// Plausibilitaetstest ist noetig, da z.B. bei CheckBoxen im
// Feld-Result ein WMF-aehnliches Struct vorkommt.
// Soeben haben wir einen Grafik-Link ins Doc inserted.
// Wir muessen ihn jetzt noch Positioniern und Skalieren.
// verlinkte Grafik im Escher-Objekt
// fuer den Rahmen
//Groesse aus der WinWord PIC-Struktur als
//Grafik-Groesse nehmen
// ggfs. altes AttrSet uebernehmen und
// horiz. Positionierungs-Relation korrigieren
// Nun den Link bzw. die Grafik ins Doc stopfen
// also nur, wenn wir ein *Insert* gemacht haben
// Zeiger auf neues Objekt ermitteln und Z-Order-Liste
// entsprechend korrigieren (oder Eintrag loeschen)
// altes SdrGrafObj aus der Page loeschen und
// auch das ggfs.  Page loeschen, falls nicht gruppiert,


130 / 1429 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8scan.cxx
// "Default-sprm",  wird uebersprungen
// "sprmCIstd" chp.istd istd, see stylesheet definition
// "Default-sprm"/ wird uebersprungen
// Zaehle Zahl der Grpprls
// trage Laenge ein
// trage in Array ein
// ueberlies nicht-Grpprl
// lies Piece Table PLCF ein
// vergessene Schaeflein
// Anz. Fkp-Eintraege des letzten Fkp
// letzer FC-Eintrag des letzten Fkp
// 0 oder 1
// Der Operator ++ hat eine Tuecke: Wenn 2 Bookmarks aneinandergrenzen, dann
// sollte erst das Ende des ersten und dann der Anfang des 2. erreicht werden.
// Liegen jedoch 2 Bookmarks der Laenge 0 aufeinander, *muss* von jedem Bookmark
// erst der Anfang und dann das Ende gefunden werden.
// Der Fall: ][
// ist noch nicht geloest, dabei muesste ich in den Anfangs- und Endindices
// vor- und zurueckspringen, wobei ein weiterer Index oder ein Bitfeld
// oder etwas aehnliches zum Merken der bereits abgearbeiteten Bookmarks
// Am Ende eines Absatzes reichen bei WW6 die Attribute bis hinter das <CR>.
// Das wird fuer die Verwendung mit dem SW um 1 Zeichen zurueckgesetzt, wenn
// dadurch kein AErger zu erwarten ist.
// nLineEnd zeigt *hinter* das <CR>
// Absatzende um 1 Zeichen verkuerzen
// gibt es bereits ein Sep-Ende, das auf das jetzige Absatzende
// zeigt ?  ... dann auch um 1 Zeichen verkuerzen
// Sep Adjust Wenn Ende Char-Attr == Absatzende ...
// ... dann um 1 Zeichen verkuerzen
// Suchreihenfolge der Attribute
// Suchreihenfolge der Attribute
// unbenutzt bei SpezText
// Feld-Initialisierung
// PLCFe auf Text-StartPos einstellen
// initialisieren der Member-Vars Low-Level
// initialisieren der Member-Vars High-Level
// Vorsicht: nEndPos muss bereits
// bei allen PLCFen initialisiert sein
// 0. welche Attr.-Klasse,
// 1. ob ein Attr.-Start ist,
// 2. CP, wo ist naechste Attr.-Aenderung
// SuchReihenfolge:
// gibt die CP-Pos der naechsten Attribut-Aenderung zurueck
// aufsetzen
// Ende-Kennzeichen
// Sprm-Klasse(!) ermitteln
/*
                Pruefe, ob noch Sprm(s) abzuarbeiten sind
            */
// Gesamtlaenge Sprms um SprmLaenge verringern
// Pos des evtl. naechsten Sprm
// sicherheitshalber auf Null setzen, da Enden folgen!
// es folgen Enden
// NoSprm ohne Ende
// Rueckgabe true fuer Anfang eines Attributes oder Fehler,
// Restliche Rueckgabewerte werden in der vom Aufrufer zu stellenden Struktur
// nur ab WinWord 8 benutzt
/*
        Wunsch-Nr vermerken, File-Versionsnummer ermitteln
        und gegen Wunsch-Nr. checken !
    */
// von 101 WinWord 6.0
// von 105 WinWord 95
// von 106 WinWord 97
// und hopp raus!
// und auf gehts: FIB einlesen
// unter Ver67  nur leeres Reservefeld
// Inhalt von aVer8Bits1
// Einschub fuer WW8
/*
        // dies sind die 9 unused Felder:
        && (bVer67 || WW8ReadINT16(  rSt, pnFbpChpFirst_W6          ))  // 1
        && (bVer67 || WW8ReadINT16(  rSt, pnChpFirst_W6                 ))  // 2
        && (bVer67 || WW8ReadINT16(  rSt, cpnBteChp_W6                  ))  // 3
        && (bVer67 || WW8ReadINT16(  rSt, pnFbpPapFirst_W6          ))  // 4
        && (bVer67 || WW8ReadINT16(  rSt, pnPapFirst_W6                 ))  // 5
        && (bVer67 || WW8ReadINT16(  rSt, cpnBtePap_W6                  ))  // 6
        && (bVer67 || WW8ReadINT16(  rSt, pnFbpLvcFirst_W6          ))  // 7
        && (bVer67 || WW8ReadINT16(  rSt, pnLvcFirst_W6                 ))  // 8
        && (bVer67 || WW8ReadINT16(  rSt, cpnBteLvc_W6                  ))  // 9
        */
// Ende des Einschubs fuer WW8
// 2 Longs uebergehen, da unwichtiger Quatsch
// weitere 2 Longs nur bei Ver67 ueberspringen
// weiteres Long nur bei Ver67 ueberspringen
// Einschub fuer WW8
// Ende des Einschubs fuer WW8
// weiteres short nur bei Ver67 ueberspringen
/*
            ggfs. Ziel-Varaiblen, aus xxx_Ver67 fuellen
            oder Flags setzen
        */
/*
                speziell fuer WW8:
                ermittle die Werte fuer PLCF LST und PLF LFO
                und PLCF fuer TextBox-Break-Deskriptoren
            */
// muss das sein ???
// Einschub fuer WW8
// Ende des Einschubs fuer WW8
// 2 Longs uebergehen, da unwichtiger Quatsch
// weitere 2 Longs nur bei Ver67 ueberspringen
// weiteres Long nur bei Ver67 ueberspringen
// Einschub fuer WW8
// Ende des Einschubs fuer WW8
// weiteres short nur bei Ver67 ueberspringen
// nur bei Ver67, in Ver8 unused
// nur bei Ver67, in Ver8 unused
// nur bei Ver67, in Ver8 unused
// nur bei Ver67, in Ver8 unused
// lies die Laenge der in der Datei gespeicherten Struktur
// ggfs. den Rest ueberlesen
// Trick: obiger Block wird genau einmal durchlaufen
//   und kann vorzeitig per "break" verlassen werden.
// Read1STDFixed() liest ein Style ein. Wenn der Style vollstaendig vorhanden
// ist, d.h. kein leerer Slot, dann wird Speicher alloziert und ein Pointer auf
// die ( evtl. mit Nullen aufgefuellten ) STD geliefert. Ist es ein leerer
// Slot, dann wird ein Nullpointer zurueckgeliefert.
// ab Ver8 sollten diese beiden Felder dazukommen:
// man kann nie wissen: vorsichtshalber ueberlesen
// wir eventuelle Fuellsel, die noch zum BASE-Part gehoeren...
// Trick: obiger Block wird genau einmal durchlaufen
//   und kann vorzeitig per "break" verlassen werden.
// Fixed part zu kurz
// Kann keinen Namen liefern
// Vorsicht: Dieses Array kann auch kleiner sein!!!
// ab Ver8 sind folgende beiden Felder eingeschoben,
// werden von uns ignoriert.
// ab Ver8 als Unicode
// Vorsicht: Dieses Array kann auch kleiner sein!!!
// ein Reserve-Bit ueberspringen
// ein Reserve-Bit ueberspringen
// Zeiger auf Ursprungsarray einen Font nach hinten setzen
// Suche zu einem Header / Footer den Index in der WW-Liste von Headern / Footern
// Pferdefuesse bei WinWord6 und -7:
// 1) Am Anfang des Einlesens muss WWPLCF_HdFt mit Fib und Dop konstruiert werden
// 2) Der Haupttext muss sequentiell ueber alle Sections gelesen werden
// 3) Fuer jedes vorkommende Header / Footer - Attribut des Haupttextes
//  ( Darf pro Section maximal eins sein ) muss UpdateIndex() genau einmal
//  mit dem Parameter des Attributes gerufen werden. Dieser Aufruf muss *nach*
//  dem letzten Aufruf von GetTextPos() passieren.
// 4) GetTextPos() darf mit genau einem der obenstehen WW_... aufgerufen werden
//   ( nicht verodern ! )
// -> dann liefert GetTextPos() vielleicht auch ein richtiges Ergebnis
// Bit gesetzt ?
// und der Fussnoten
// dann mal die Daten auswerten
/*
            bei nFib >= 103 gehts weiter:
        */
/*
            bei nFib > 105 gehts weiter:
        */
// die untersten 9 Bit sind uninteressant
// dann mal die Daten auswerten
// lvl auf 9 setzen        // 410 0x19a
// gib Zeiger auf Daten


12 / 35 | libreoffice-4.4.0.3/sw/source/filter/ww8/ww8par2.hxx
// 1. Teil: daraus abgeleitete Sw-Attribute
// Hoehe Fix oder Min
// Bindung
// Seite oder Seitenrand
// Seite oder Seitenrand
// Oben, unten, mittig
// links, rechts, mittig
// relativ zu was gebunden
// 2.Teil: sich waehrend des Einlesens ergebende AEnderungen
// um nach Apo in Haupttext zurueckzukehren
// Bullets und Aufzaehlungen in Styles
// fuer Bullets und Aufzaehlungen in Styles


1 / 80 | libreoffice-4.4.0.3/sw/source/filter/basflt/shellio.cxx
// das Doc ist jetzt modifiziert


1 / 124 | libreoffice-4.4.0.3/sw/source/filter/basflt/fltshell.cxx
// loesche aus dem Stack


2 / 67 | libreoffice-4.4.0.3/sw/source/filter/xml/xmltble.cxx
// Und ihren Index
// Und ihren Index


1 / 34 | libreoffice-4.4.0.3/sw/source/filter/xml/xmlfmte.cxx
// Parent-Namen nur uebernehmen, wenn kein Default


1 / 25 | libreoffice-4.4.0.3/sw/source/filter/xml/xmlimp.hxx
// overwritten.


1 / 51 | libreoffice-4.4.0.3/sw/source/filter/xml/xmlexp.cxx
//Auf die Korrektheit der OrdNums sind wir schon angewiesen.


1 / 228 | libreoffice-4.4.0.3/sw/source/filter/xml/xmltbli.cxx
// und jetzt nochmal von vorne ...


113 / 144 | libreoffice-4.4.0.3/sw/source/filter/html/htmlcss1.cxx
// Wie viele Zeilen/Zeichen sind fuer DropCaps erlaubt?
// (Gibt es vielleicht woanders entsprechende Werte?)
// Implementierung des SwCSS1Parsers (eigentlich swcss1.cxx)
// LEFT/RIGHT koennte man auch am Absatz davor setzen
// %-Angaben beim FontHeight-Item werden nicht unterstuetzt
// Ein Brush-Item mit RES_BACKGROUND muss noch in eines mit
// linker, rechter Rand und Erstzeilen-Einzug
// oberer und unterer Rand
// %-Angaben beim FontHeight-Item werden nicht unterstuetzt
// ein Hintergrund wird gesetzt
// eine Umrandung wird gesetzt
// eine Umrandung wird gesetzt
// linker, rechter Rand und Erstzeilen-Einzug
// oberer und unterer Rand
// Bei "size: auto|portrait|landscape" bleibt die bisherige
// Groesse der Vorlage erhalten. Bei "landscape" und "portrait"
// wird das Landscape-Flag gesetzt und evtl. die Breite/Hoehe
// vertauscht.
// Geht das wirklich?
// eine Umrandung wird gesetzt
// Token und Class zu dem Selektor holen
// und noch ein ganz par Infos zum naechsten Element
// Erstmal ein par Spezialfaelle
// vielleicht A:visited oder A:link
// Den Hintergrund muessen wir vor dem Setzen abfragen,
// denn in SetPageDescAttrs wird er geloescht.
// Ein par Attribute muessen an der Seitenvorlage gesetzt werden,
// und zwar die, die nicht vererbt werden
// alle noch uebrigen Optionen koennen an der Standard-Vorlage
// gesetzt werden und gelten dann automatisch als defaults
// Jetzt werden die Selektoren verarbeitet, die zu einer Absatz-Vorlage
// gehoehren
// nicht TH und TD, aber TH P und TD P
// Entweder kein zusammengesetzter Selektor oder
// ein X:first-line { float: left; ... }
// Die Vorlage Suchen bzw. Anlegen
// nur die Attribute an der Vorlage setzen
// ein Drop-Cap-Attribut basteln
// die Attribute in das DropCap-Attribut einfuegen
// Das Attribut nur setzen, wenn float: left angegeben wurde
// und das Initial ueber mehrere Zeilen geht. Sonst wird die
// ggf. angelegte Zeichen-Vorlage spaeter ueber den Namen
// gesucht und gesetzt.
// Jetzt werden die Selektoten verarbeitet, die zu einer Zechenvorlage
// gehoehren. Zusammengesetzte gibt es hier allerdings nich nicht.
// die entsprechende Vorlage suchen
// die Vorlage suchen oder anlegen (geht nur mit Namen)
// Die Vorlage (ohne Class) suchen oder anlegen
// Wenn es eine Klasse gibt, die Klassen-Vorlage suchen aber nicht
// neu anlegen.
// eine vom Reader angelegte
// Wenn dieser Fall eintritt, dann wurde ein <TD><P CLASS=foo>
// gelesen, aber die TD.foo Vorlage nicht gefunden. Dann muessen
// wir P.foo nehmen, wenn es sie gibt.
// Die erste Seite wird aus der rechten Seite erzeugt, wenn es die
// Die neue Seitenvorlage entsteht aus dem Master durch kopieren.
// dazu brauchen wir auch die Nummer der neuen Vorlage
// Die Vorlagen an ihren neuen Zweck anpassen.
// Wenn es schon eine linke Seite gibt, dann ist das die
// Folge-Vorlage, sonst ist es die HTML-Vorlage.
// Wenn die linke Vorlage schon angelegt ist, passiert hier gar
// nichts. Sonst wird die linke Vorlage angelegt und sorgt auch
// fuer die richtige Verkettung mit der rechten Voralge.
// Die rechte Vorlage wird angelegt, wenn sie noch nicht existiert.
// Es findet aber keine Verkettung statt.
// Wenn schon eine erste Seitenvorlage existiert, wird die linke
// Vorlage die Folge-Vorlage der ersten Seite.
// - das Tag wird absolut positioniert und left/top sind beide
//   gegeben und enthalten auch keine %-Angabe, oder
// - das Tag soll fliessen, und
// - es wurde eine Breite angegeben (in beiden Faellen noetig)
// die Anzahl der Zeilen entspricht in etwa einer %-Angabe
// fuer die Hoehe (was passiert mit absoluten Hoehen???)
// Nur wenn nLines>1 ist, wird das Attribut auch gesetzt. Dann
// brauchen wir die Font-Hoehe aber auch nicht in der Zeichen-Vorlage.
// Bei harter Attributierung (pName==0) koennen wir aufhoehren, wenn
// das Initial nur ueber eine Zeile geht.
// ein rechter Rand wird der Abstand zum Text!
// Fuer alle anderen Attribute eine Zeichen-Vorlage anlegen
// Die Zeichenvorlage braucht nur im Attribut gesetzt werden, wenn
// auch das Attribut gesetzt wird.
// CSS1-sezifisches des SwHTMLParsers
// den zu dem Item gehoehrenden Tabellen-Eintrag ermitteln ...
// View wegschmeissen (wegen Reschedule)
// Ein Medium anlegen
// wurde abgebrochen?
// wurde der Import vom SFX abgebrochen?
// Der Style wurde synchron geladen und wir koennen
// es direkt aufrufen.
// Der Style wird asynchron geladen und ist erst beim
// naechsten Continue-Aufruf da. Wir muessen deshalb einen
// Pending-Stack anlegen, damit wir hierher zurueckkehren
// @page (wirkt auf alle Seiten, die es schon gibt
// Fuer alle anderen Seiten-Vorlagen, die es schon gibt,
// muessen die Attribute auch noch gesetzt werden
// Absolut positionierte Objekte sind seitengebunden, wenn
// sie nicht schon in einem Rahmen stehen und sonst
// Rahmengebunden.
// wird noch umgeschossen
// fliessende Objekte werden Absatzgebunden eingefuegt, wenn
// der Absatz noch leer ist und sonst auto-gebunden.
// Auto-gebundene Rahmen werden zunaechst an der Position davor
// eingefuegt und erst spaeter verschoben.
// Absolut Positioniert mit Durchlauf
// Netscape und MS-IE interpretieren die Hoehe regelwiedrig
// als Mindest-Hoehe, also machwn wir das auch so.
// Alle 4 Seiten gleichzeitig auf 0 setzen
// Stack-Eintrag zu dem Token suchen
// 0 als Token kommt nicht vor
// Fuer DropCaps noch die Anzahl der Zeichen anpassen. Wenn
// es am Ende 0 sind, wird das Attribut invalidiert und dann
// von _SetAttr gar nicht erst gesetzt.
// den zu dem Item gehoehrenden Tabellen-Eintrag ermitteln ...


39 / 62 | libreoffice-4.4.0.3/sw/source/filter/html/svxcss1.hxx
// nichts angegeben
// nichts angegeben
// automatisch
// nichts angegeben
// automatisch
// nichts angegeben
// automatisch
// naechste Seite ist eine linke
// naechste Seite ist eine rechte
// Wert einer Property
// und der dazugehoerige Wert eines Enums
// Diese Klasse bereitet den Output des CSS1-Parsers auf,
// indem die CSS1-Properties in SvxItem(Set)s umgewandelt werden.
// Ausserdem werden die Selektoren samt zugehoeriger Item-Set
// gespeichert.
// Ein abgeleiteter Parser kann dies fuer einzelne Selektoren unterdruecken,
// indem er die Methode StyleParsed ueberlaed.
// Mindest-Abstand fuer festen Zeilenabstand
// Diese Methode wird fuer jeden Selektor mit dem zugehoerigen
// Item-Set aufgerufen. Fuer einen Selektor koennen mehrere
// Aufrufe erfolgen.
// wenn true zuruckgegeben wird, wird der Item-Set bzw. der
// Selektor nicht mehr gespeichert!
// Der ItemSet darf entsprechend modifiziert werden!
// Die Implementierung dieser Methode gibt false zurueck.
// Diese Methode wird aufgerufen, wenn ein Selektor geparst wurde
// Wenn bFirst gesetzt ist, wird der Inhalt von aItemSet in alle
// zuletzt angelegten Styles kopiert.
// Diese Methode sollte in abgleiteten Parsern nicht mehr
// ueberladen werden!
// Diese Methode wird fuer jede geparste Property aufgerufen
// sie fuegt das Item in den ItemSet 'pItemSet' ein
// Sie sollte in abgeleiteten Parsern nicht mehr ueberladen werden!
// Parsen eines Style-Sheets. Fuer jeden gefundenen Selektor
// wird StyleParsed mit dem entsprechenem Item-Set aufgerufen
// Parsen einer Style-Option. Hier wird einfach nur der Item-Set
// gefuellt.
// Umwandeln eines Strings in den Wert eines Enums
// Die Font-Hoehe fuer eine bestimmte Font-Groesse (0-6) ermitteln


38 / 50 | libreoffice-4.4.0.3/sw/source/filter/html/htmldrawreader.cxx
// linken/rechten Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// oberen/unteren Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// Ein DrawTxtobj anlegen
// (Nur) Alternate leueft per Default von links nach rechts
// die fuer das Scrollen benoetigten Attribute umsetzen
// die Default-Farbe (aus der Standard-Vorlage) setzen, damit ueberhaupt
// eine sinnvolle Farbe gesetzt ist.
// Die Attribute der aktuellen Absatzvorlage setzen
// die Attribute der Umgebung am Draw-Objekt setzen
// Styles parsen (funktioniert hier nur fuer Attribute, die auch
// am Zeichen-Objekt gesetzt werden koennen)
// jetzt noch die Groesse setzen
// Die Laufschrift steht in einer Tabelle, aber nicht
// in einer Zelle. Da jetzt keine vernuenftige Zuordung
// zu einer Zelle moeglich ist, passen wir hir die
// Breite dem Inhalt der Laufschrift an.
// Da wir wissen, in welcher Zelle die Laufschrift ist,
// koennen wir die Breite auch anpassen. Keine Breitenangabe
// wird wie 100% behandelt.
// Die Hoehe ist nur eine Mindest-Hoehe
// und das Objekt in das Dok einfuegen
// Das Zeichen-Objekt der Tabelle bekanntmachen. Ist ein bisserl
// umstaendlich, weil noch ueber den Parser gegangen wird, obwohl die
// Tabelle bekannt ist, aber anderenfalls muesste man die Tabelle
// oeffentlich machen, und das ist auch nicht schoen. Das globale
// pTable kann uebrigens auch nicht verwendet werden, denn die
// Laufschrift kann sich auch mal in einer Sub-Tabelle befinden.
// Da es keine fixe Hoehe gibt, das Text-Objekt erstmal breiter
// als den Text machen, damit nicht umgebrochen wird.
// den gesammelten Text einfuegen
// die Groesse dem Text anpassen.
// das akteulle Textstueck an den Text anhaengen


31 / 62 | libreoffice-4.4.0.3/sw/source/filter/html/htmlsect.cxx
// noch keine Header, dann erzeuge einen.
// noch keine Footer, dann erzeuge einen.
// Einen neuen Node zu Beginn der Section anlegen
// Den bisherigen Inhalt der Section loeschen
// Die Seitenvorlage aktualisieren
// Bereiche fuegen wir in Rahmen nur dann ein, wenn der Bereich gelinkt ist.
// Bereich einfuegen (muss vor dem Setzten von Attributen erfolgen,
// weil die Section vor der PaM-Position eingefuegt.
// wenn wir im ersten Node einer Section stehen, wir die neue
// Section nicht in der aktuellen, sondern vor der aktuellen
// Section eingefuegt. Deshalb muessen wir dann einen Node
// einfuegen. UND IN LOESCHEN!!!
// Namen der Section eindeutig machen
// ggfs. einen Bereich anspringen
// PageDesc- und SwFmtBreak Attribute vom aktuellen Node in den
// (ersten) Node des Bereich verschieben.
// noch vorhandene PostIts in den ersten Absatz
// der Tabelle setzen
// keine text::Bookmarks mit dem gleichen Namen wie Bereiche einfuegen
// Stack-Eintrag zu dem Token suchen (weil wir noch den Div-Stack
// haben unterscheiden wir erst einmal nicht zwischen DIV und CENTER
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// Der untere Absatz-Abstand wird zum Abstand zur
// Kopf- oder Fusszeile
// und anschliessend auf einen vernuenftigen Wert
// gesetzt
// Der obere Absatz-Abstand wird zum Abstand zur
// Kopf- oder Fusszeile, wenn er groesser ist als
// der untere vom Absatz davor
// und anschliessend auf einen vernuenftigen Wert gesetzt
// den Bereich beenden


13 / 36 | libreoffice-4.4.0.3/sw/source/filter/html/htmlfldw.cxx
// Fuer ein fixes Feld och den Num-Value ausgeben.
// Fixe Felder ohne Zahlenformate sollte es
// eigentlich nicht geben. OSL_ENSURE(ist unten.
// Nicht fixe Felder muessen kein Zahlenformat haben,
// wenn sie aus 4.0-Dokumenten stammen.
// <SDFIELD>-Tag ausgeben
// Inhalt des Feldes ausgeben
// Off-Tag ausgeben
// Kommentare werden im ANSI-Zeichensetz, aber mit System-Zeilen-
// Umbruechen gesschrieben.
// META-Tags direkt ausgeben
// sonst ist es der Script-Inhalt selbst. Da nur noh JavaScript
// in Feldern landet, muss es sich um JavaSrript handeln ...:)


87 / 135 | libreoffice-4.4.0.3/sw/source/filter/html/wrthtml.hxx
// einige Forward Deklarationen
// Flags fuer die Ausgabe von Rahmen aller Art
// BORDER geht nur bei OutHTML_Image
// ANYSIZE gibt an, ob auch VAR_SIZE und MIN_SIZE angaben exportiert werden
// ABSSIZE gibt an, ob Abstand und Umrandung ignoriert werden sollen
// Die folgenden Flags bestimmen nur, welche Descriptoren, Tags, Optionen etc.
// ausgegeben werden ...
// Die folgenden Flags legen fest, was ausgegeben wird
// die Form, zu der das Control gehoert
// der Node, in dem es verankert ist
// wie viele Controls sind in dem Node
// operatoren fuer das Sort-Array
// das Format selbst
// das Vergleichs-Format
// das auszugebende Token
// die auszugebende Klasse
// der auszugebende Attribut-Set
// ein par default-Werte fuer
// Absatz-Vorlagen
// Konstruktor fuer einen Dummy zum Suchen
// Konstruktor zum Erstellen der Format-Info
// aktuelle Numerierung
// Beschreibung der Export-Konfiguration
// geschriebene Image Maps
// implizite Stprungmarken
// die zu schreibenden Forms
// der Selektor eines Styles
// die HTML-Vorlage
// Index des ersten Absatz
// Die aktuelle Seiten-Vorlage
// die Font-Hoehen 1-7
// Result-Code fuer Warnungen
// letzte Position eines LF
// fuers Absaetze zusammenhalten
// zum eindeutig
// linker Einzug (z.B. aus Listen)
// die dafaults, der nicht geschrieben
// werden muessen (aus der Vorlage)
// Erstzeilen-Einzug (aus Listen)
// nicht zu schreibender default
// die defaults, der nicht geschrieben
// werden muessen (aus der Vorlage)
// wie weit ist eingerueckt?
// wie lang darf eine Zeile werden?
// welcher DL-Level existiert gerade
// Wie weit wird in DL eingerueckt
// Beschreibung der Export-Konfiguration
// Styles herkoemmlichen Tags vorziehen
// Beschreibung dessen, was exportiert wird
// wird die 1. Zeile ausgegeben ?
// Tag an oder aus/Attr-Start oder -Ende
// Die folgenden beiden Flags geben an, wir Attribute exportiert werden:
// 1        0           Hints: Jedes Attribut wird als eignes Tag
//                          geschrieben und es gibt ein End-Tag
// 0        1           (Absatz-)Attribute: Das Attribut wird als Option
//                          eines bereits geschrieben Tags exportiert. Es
//                          gibt kein End-Tag.
// wird der Tabelleninhalt geschrieben?
// wurde schon eine Property ausgegeben
// wurde schon eine Property ausgegeben
// die Textkoerper-Vorlage wurde
// modifiziert.
// was muss/kann/darf nicht ausgegeben werden?
// HTML-Tag erlaubt kein ALIGN=...
// <BR CLEAR=LEFT> am Absatz-Ende ausg.
// <BR CLEAR=RIGHT> am Absatz-Ende ausg.
// ein Zeilenumbruch darf eingef. werden
// die aktuelle Form beibehalten
// schreibe den makierten Bereich
// gebe alle an in aktuellen Ansatz stehenden Bookmarks aus
// gebe die evt. an der akt. Position stehenden FlyFrame aus.
// BODY-Tag-Events aus der SFX-Konfigaurion
// ALT/ALIGN/WIDTH/HEIGHT/HSPACE/VSPACE-Optionen des aktuellen
// Frame-Formats ausgeben und ggf. ein <BR CLEAR=...> vorne an
// Die aktuelle Numerierungs-Information holen.
// Die Numerierungs-Information des naechsten Absatz holen. Sie
// muss noch nicht vorhanden sein!
// Die Numerierungs-Information des naechsten Absatz setzen.
// Die Numerierungs-Information des naeschten Absatz fuellen.
// Die Numerierungs-Information des naeschten Absatz loeschen.
// Struktur speichert die aktuellen Daten des Writers zwischen, um
// einen anderen Dokument-Teil auszugeben, wie z.B. Header/Footer
// Mit den beiden USHORTs im CTOR wird ein neuer PaM erzeugt und auf
// die Position im Dokument gesetzt.
// Im Destructor werden alle Daten wieder restauriert und der angelegte
// Pam wieder geloescht.
// einige Funktions-Deklarationen


73 / 116 | libreoffice-4.4.0.3/sw/source/filter/html/htmlform.cxx
// startProduction darf nicht im Konstruktor gerufen werden, weil
// wir und ggf. selbst zerstoeren ... Deshlab eine eigene Methode.
// UNO Anbindung
// Die Quelle des Images merken
// Als Event-Listener am Shape anmelden, damit wir es beim dispose
// Zum Schluss halten wir noch eine Referenz auf uns selbst, damit
// wir am Leben bleiben ... (eigentlich sollte das nicht neotig sein,
// weil wir ja noch an diversen anderen Stellen angemeldet sind)
// und am ImageProducer anmelden, um die Groesse zu erehalten ...
// Wenn keine Breite oder Hoehe angegeben ist, ist das das init von
// der leeren Grafik, die angezeigt wird, bevor der Stream einer
// asynchron anzuzeigenden Grfik verfuegbar ist.
// Wenn das Control in einer Tabelle verankert ist, muesen
// die Tabellen-Spalten neu berechnet werden
// Um an den SwXShape* zu gelangen, brauchen wir ein Interface,
// das auch vom SwXShape implementiert wird.
// uns selbst abmelden und loeschen
// uns selbst abmelden und loeschen
// Wenn das Shape verschwindet soll muessen wir es loslassen
// Um an den SwXShape* zu gelangen, brauchen wir ein Interface,
// das auch vom SwXShape implementiert wird.
// es muss ein Draw-Format sein
// Schauen, ob es ein SdrObject dafuer gibt
// Erstmal muss die Anzahl der Events ermittelt werden ...
// Solange nicht alle Events implementiert sind, enthaelt die
// Tabelle auch Leerstrings!
// linken/rechten Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// oberen/unteren Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// unsauber, aber laut OS geht das ...
// unsauber, aber laut OS geht das ...
// Das Control-Model am Control-Shape setzen
// Da beim Einfuegen der Controls der Fokus gesetzt wird, werden
// auch schon Fokus-Events verschickt. Damit die nicht evtl. schon
// vorhendene JavaSCript-Eents rufen, werden die Events nachtraeglich
// gesetzt.
// Gibt es schon eine Form?
// Bei leerer URL das Directory nehmen
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// eigtl. nur EDIT
// eigtl. nur EDIT
// eigtl. nur EDIT
// Image-Controls ohne Image-URL werden ignoriert (wie bei MS)
// ALIGN fuer alle Controls auszuwerten ist keine so gute Idee,
// solange Absatz-gebundene Controls die Hoehe von Tabellen-Zellen
// nicht beeinflussen
// Defaults entsprechen HTML_IT_TEXT
// Fuer ein par Controls mussen CR/LF noch aus dem VALUE
// Beim RadioButton darf die DefaultChecked-Property
// erst gesetzt werden, wenn das Control angelegt und ein
// activateTabOrder gerufen wurde, weil es sonst noch zu der
// vorhergehenden Gruppe gehoert.
// SIZE auszuwerten duerfte hier keinen Sinn machen???
// Beim File-Control wird der VALUE aus Sicherheitsgruenden ignoriert.
// Beim Image-Button bei nicht gegebern Groesse einen sinnvollen Default
// Die URL erst nach dem Einfuegen setzen, weil sich der
// Download der Grafik erst dann am XModel anmelden kann,
// wenn das Control eingefuegt ist.
// Spezialbehandlung fuer TextArea auch untem im Parser beenden
// einen neuen Kontext anlegen
// und PRE/Listing/XMP voruebergehend aussetzen
// und ggf. die Attribute beenden
// das ist hier richtig!!!
// 4 Zeilen als default
// einen neuen Kontext anlegen
// und PRE/Listing/XMP voruebergehend aussetzen
// In einer DropDown-Listbox sollte immer ein Eintrag selektiert
// sein.
// und ggf. die Attribute beenden
// erstmal weglassen!!!


108 / 119 | libreoffice-4.4.0.3/sw/source/filter/html/htmltabw.cxx
// Einige Twip-Werte an Pixel-Grenzen anpassen
// MIB 30.6.97: Wenn schon eine Box expandiert wurde, wird eine
// weitere nur expandiert, wenn sie Umrandungen besitzt.
// Eine Box als einzelne Zelle schreiben
// Art der Zelle (TD/TH) bestimmen
// nur Absaetzte betrachten, an denen man was erkennt
// Das ist der Fall, wenn die Vorlage eine der Tabellen-Vorlagen
// ist oder von einer der beiden abgelitten ist.
// <TH>/<TD> in neue Zeile
// ROW- und COLSPAN ausgeben
// WIDTH ausgeben (Grrr: nur fuer Netscape)
// WIDTH ausgeben: Aus Layout oder berechnet
// ALIGN wird jetzt nur noch an den Absaetzen ausgegeben
// VALIGN ausgeben
// Hintergrund ausgeben
// den Inhalt von <TD>...</TD> einruecken
// den Inhalt von <TD>...</TD> einruecken
// Eine Line als Zeilen ausgeben
// Wenn die Zeile mehr als eine Zelle nethaelt und alle Zellen
// die gleiche Ausrichtung besitzen, das VALIGN an der Zeile statt der
// Zelle ausgeben
// <TR> in neuer Zeile
// Inhalt von <TR>...</TR> einruecken
// Inhalt von <TR>...</TR> einruecken
// </TR> in neuer Zeile
// vorhergende Aufzaehlung etc. beenden
// <TABLE> in neue Zeile
// ALIGN= ausgeben
// WIDTH ausgeben: Stammt aus Layout oder ist berechnet
// CELLPADDING ausgeben: Stammt aus Layout oder ist berechnet
// CELLSPACING ausgeben: Stammt aus Layout oder ist berechnet
// Hintergrund ausgeben
// Inhalte von Table einruecken
// Ueberschrift ausgeben
// <CAPTION> in neue Zeile
// <COLGRP>/<COL> ausgeben: Bei Export ueber Layout nur wenn beim
// Import welche da waren, sonst immer.
// <COLGRP> in neue Zeile
// Inhalt von <COLGRP> einruecken
// <COL> in neue Zeile
// Inhalt von <COLGRP> einruecken
// </COLGRP> in neue Zeile
// <COLGRP> in neue Zeile
// Inhalt von <COLGRP> einruecken
// Inhalt von <COLGRP> einruecken
// </COLGRP> in neue Zeile
// die Lines als Tabellenzeilen rausschreiben
// <TBODY> ausgeben?
// Wenn Sections ausgegeben werden muessen darf ein THEAD um die erste
// Zeile nur ausgegeben werden, wenn unter der Zeile eine Linie ist
// <TBODY> aus ausgeben, wenn <THEAD> ausgegeben wird.
// <THEAD>/<TDATA> in neue Zeile
// Inhalt von <THEAD>/<TDATA> einr.
// Inhalt von <THEAD>/<TDATA> einr.
// </THEAD>/</TDATA> in neue Zeile
// <THEAD>/<TDATA> in neue Zeile
// Inhalt von <THEAD>/<TDATA> einr.
// Inhalt von <THEAD>/<TDATA> einr.
// </THEAD>/</TDATA> in neue Zeile
// Inhalt von <TABLE> einr.
// </TABLE> in neue Zeile
// die horizontale Ausrichtung des Rahmens hat (falls vorhanden)
// Prioritaet. NONE bedeutet, dass keine horizontale
// Ausrichtung geschrieben wird.
// ggf. eine FORM oeffnen
// text::HoriOrientation::NONE und text::HoriOrientation::FULL Tabellen benoetigen relative Breiten
// Tabellen mit automatischer Ausrichtung werden zu Tabellen
// mit 100%-Breite
// Die Tabellenbreite wird anhand des linken und rechten
// Abstandes bestimmt. Deshalb versuchen wir die
// tatsaechliche Breite der Tabelle zu bestimmen. Wenn
// das nicht geht, machen wir eine 100% breite Tabelle
// Ohne rechten Rand bleibt die %-Breite erhalten
// Ohne rechten Rand bleibt auch eine absolute Breite erhalten
// Wir versuchen aber trotzdem ueber das Layout die
// tatsachliche Breite zu ermitteln.
// In allen anderen Faellen kann eine absolute oder relative
// Breite direkt uebernommen werden.
// Wenn der Absatz vor der Tabelle nicht numeriert ist oder
// der Absatz nach der Tabelle mit einer anderen oder
// (gar keiner) Regel numeriert ist, koennen wir
// die Einrueckung ueber eine DL regeln. Sonst behalten wir
// die Einrueckung der Numerierung bei.
// eFlyHoriOri und eTabHoriOri besitzen nun nur noch die Werte
// LEFT/CENTER und RIGHT!
// MIB 4.7.97: Wenn die Tabelle eine relative Breite besitzt,
// dann richtet sich ihre Breite nach der des Rahmens, also
// exportieren wir dessen Breite. Bei fixer Breite ist die Breite
// der Tabelle massgeblich. Wer Tabellen mit relativer Breite <100%
// in Rahmen steckt, ist selber schuld wenn nix Gutes bei rauskommt.
// Wenn eine linksbuendigeTabelle keinen rechtsseiigen Durchlauf
// hat, brauchen wir auch kein ALIGN=LEFT in der Tabelle.
// Aehnliches gilt fuer rechtsbuendigeTabelle, hier nehmen wir
// stattdessen ein <DIV ALIGN=RIGHT>.
// ALIGN=CENTER versteht so gut wie keiner, deshalb verzichten wir
// daruf und nehmen ein <CENTER>.
// <CENTER> in neuer Zeile
// Inhalt von <CENTER> einruecken
// Wenn die Tabelle in keinem Rahmen ist kann man immer ein LF ausgeben.
// Wenn die Tabelle in keinem Rahmen war kann man immer ein LF ausgeben.
// Inhalt von <CENTER> einruecken
// </CENTER> in neue Teile
// Pam hinter die Tabelle verschieben
// Wenn der Absatz hinter der Tabelle mit der gleichen Regel
// numeriert ist wie der Absatz vor der Tabelle, dann steht in
// der NumInfo des naechsten Absatzes noch die Ebene des Absatzes
// vor der Tabelle. Es muss deshalb die NumInfo noch einmal geholt
// werden um ggf. die Num-Liste noch zu beenden.


64 / 99 | libreoffice-4.4.0.3/sw/source/filter/html/wrthtml.cxx
// ueberhaupt Styles ausgeben
// (dann auch obere und untere Absatz-Abstaende)
// Nur noch fuer den MS-IE ziehen wir den Export von Styles vor.
// die HTML-Vorlage holen
// Tabellen und Bereiche am Doc.-Anfang beachten
// mit dem Tabellen-Node anfangen !!
// erster Node (der einen Seitenumbruch enthalten darf)
// mit dem Section-Node anfangen !!
// nur das Tag fuer die Section merken
// FindSectionNode() an einem SectionNode liefert den selben!
// Tabelle fuer die freifliegenden Rahmen erzeugen, aber nur wenn
// das gesamte Dokument geschrieben wird
// Formulare, die nur HiddenControls enthalten ausgeben.
// loesche die Tabelle mit den freifliegenden Rahmen
// Waehrend des Exports angelegte Zeichen- und Abastzvorlagen
// loeschen
// HTML-Modus wieder restaurieren
// sichern
// suche die naechste text::Bookmark-Position aus der text::Bookmark-Tabelle
// gebe alle Bereiche des Pams in das HTML-File aus.
// suche den ersten am Pam-auszugebenen FlyFrame
// Wie weit ?
/* sollen nur die Selectierten Bereiche gesichert werden, so
             * duerfen nur die vollstaendigen Nodes gespeichert werde,
             * d.H. der 1. und n. Node teilweise, der 2. bis n-1. Node
             * vollstaendig. (vollstaendig heisst mit allen Formaten! )
             */
// Nach einem Node keine Fusszeile mehr
// MIB 8.7.97: Machen wir jetzt hier und nicht
// beim Aufrufer
// bis alle PaM's bearbeitet
// wieder auf alten Wert zurueck
// schreibe die StyleTabelle, algemeine Angaben,Header/Footer/Footnotes
// wenn das Item nur in der Vorlage des aktuellen Doks gesetzt
// ist oder einen anderen Wert hat, als in der HTML-Vorlage,
// wird es gesetzt
// Das Item war in der HTML-Vorlage noch gesetzt, also geben wir
// das Default aus
// baue den Vorspann
// Inhalt von <HEAD> einruecken
// Kommentare und Meta-Tags des ersten Absatzes
// In Nicht-HTML-Dokumenten wird die erste gesetzte Seitenvorlage
// exportiert und wenn keine gesetzt ist die Standard-Vorlage
// und nun ... das Style-Sheet!!!
// und nun ... das BASIC und JavaScript!
// nur mit DocShell ist Basic moeglich
// Inhalt von <HEAD> einruecken
// der Body wird nicht eingerueckt, weil sonst alles eingerueckt waere!
// Textfarbe ausgeben, wenn sie an der Standard-Vorlage gesetzt ist
// und sich geaendert hat.
// Farben fuer (un)besuchte Links
// nur mit DocShell ist Basic moeglich
// Ausgabe aller Bookmarks in diesem Absatz. Die Content-Position
// wird vorerst nicht beruecksichtigt!
// Der Bereich derBookmark wird erstam ignoriert, da er von uns
// auch nicht eingelesen wird.
// erst die SWG spezifischen Daten:
// etwas umstaendlich, aber wir haben nur einen Indent-String!
// Struktur speichert die aktuellen Daten des Writers zwischen, um
// einen anderen Dokument-Teil auszugeben, wie z.B. Header/Footer
// Tabelle in Sonderbereichen erkennen
// Ggf. die aktuelle Numerierungs-Info merken, damit sie wieder
// neu aufgenommen werden kann. Nur dann belibt auch die Numerierungs-
// Info des nachsten Absatz gueltig.
// Die Numerierung wird in jedem Fall unterbrochen.
// Pam wieder loeschen
// Ggf. die Numerierung von vor der Section fortsetzen. Die Numerierung
// des naecshten Absatz wird in jedem Fall ungueltig.


20 / 36 | libreoffice-4.4.0.3/sw/source/filter/html/htmlnumwriter.cxx
// Der naechste wird als naechstes ausgegeben.
// Vor einer Tabelle behalten wir erst einmal die alte Ebene bei,
// wenn die gleiche Numerierung hinter der Tabelle
// fortgesetzt wird und dort nicht von vorne numeriert
// wird. Die Tabelle wird ann beim Import so weit eingeruckt,
// wie es der Num-Ebene entspricht.
// Eine Tabelle wird uebersprungen, also den Node
// hinter der Tabelle betrachten.
// In allen anderen Faellen ist die Numerierung erstmal
// zu Ende.
// <OL>/<UL> in eine neue Zeile
// Aufzaehlungs-Liste: <OL>
// den Typ ueber das Bullet-Zeichen bestimmen
// den Typ ueber das Format bestimmen
// Inhalt von <OL> einruecken
// MIB 23.7.97: Die Schleife muss doch rueckwaerts durchlaufen
// werden, weil die Reihenfolge von </OL>/</UL> stimmen muss
// Inhalt von <OL> einruecken
// </OL>/</UL> in eine neue Zeile
// es wird also eine Liste angefangen oder beendet:


3 / 8 | libreoffice-4.4.0.3/sw/source/filter/html/htmlnum.hxx
// Aktuelle Numerierung
// Export: Numerierung neu starten
// Export: Absatz ist numeriert


95 / 107 | libreoffice-4.4.0.3/sw/source/filter/html/htmlctxt.cxx
// In Umgebung gueltige Numerierung
// hierhin beim verlassen den
// Kontexts zurueckgesprungen
// In Umgebung gueltige Attribute,
// wenn Attributierung nicht
// beibehalten werden soll.
// In Umgebung gueltige Stack-
// Untergrenze, wenn der Stack
// geschuetzt werden soll.
// In Umgebung gueltige Stack-
// Untergrenze, wenn die Attribute
// nicht beibehalten werden sollen.
// Numerierung beibehalten?
// Die Position gehoert uns, muss also angelegt und zerstoert werden
// Der Index gehoert uns nicht. Kein Anlgen und Zerstoeren.
// alle noch offenen Attribute beenden und hinter der Tabelle
// neu aufspannen
// Das Attribut muss eine Content-Position weiter vorne
// beendet werden
// Das Attribut muss gesetzt werden. Da wir
// das Original noch brauchen, weil Zeiger auf das Attribut
// noch in den Kontexten existieren, muessen wir es clonen.
// Die Next-Liste geht dabei verloren, aber die
// Previous-Liste bleibt erhalten
// Wenn das Attribut nicht gesetzt vor der Tabelle
// gesetzt werden muss, muessen der Previous-Attribute
// trotzdem gesetzt werden.
// den Start des Attributs neu setzen
// Wenn der PaM an eine andere Position gesetzt wird, muss
// die Numerierung gerettet werden..
// Die Numerierung soll nicht beibehalten werden. Also muss
// der aktuelle Zustand gerettet und die Numerierung
// anschliessend ausgeschaltet werden.
// Attribute an aktueller Position beenden und an neuer neu anfangen
// Mit dem Setzen von nContextStMin koennen automatisch auch
// keine gerade offenen Listen (DL/OL/UL) mehr beendet werden.
// Die bisherigen Attribute koennen wir schonmal setzen.
// Die bisherige gemerkte Numerierung wieder setzen
// Alle noch offenen Kontexte beenden. Der eigene
// Kontext muss bereits geloscht sein!
// Alle noch offenen Attribute beenden
// Falls ein Bereich geoeffnet wurde, den verlassen. Da Bereiche
// auch innerhalb von absolut positionierten Objekten angelegt werden,
// muss das passieren, bever ein alter Dokument-Kontext restauriert wird.
// Rahmen und sonstige Sonderbereiche verlassen.
// Ggf. noch einen Ansatz-Umbruch einfuegen
// PRE-/LISTING- und XMP-Umgebungen wieder starten
// einfaches Loeschen reicht hier nicht, weil das
// Attribut auch aus seiner Liste ausgetragen werden
// muss. Theoretisch koennt man natuerlich auch die Liste
// und die Attribute getrennt loeschen, aber wenn man
// dann was falsch gemacht hat, sieht es uebel aus.
// PRE-/LISTING- und XMP-Umgebungen wieder starten
// Unter folgenden Umstaenden wird jetzt ein Rahmen aufgemacht:
// - das Tag wird absolut positioniert und left/top sind beide
//   gegeben und enthalten auch keine %-Angabe, oder
// - das Tag soll fliessen, und
// - es wurde eine Breite angegeben (in beiden Faellen noetig)
// Ausrichtung setzen
// Groesse setzen
// Abstaende setzen
// Sonstige CSS1-Attribute Setzen
// Ein DropCap-Attribut basteln, wenn auf Zeichen-Ebene vor dem
// ersten Zeichen ein float: left vorkommt
// Nur wenn das Initial auch ueber mehrere Zeilen geht, wird das
// DropCap-Attribut gesetzt. Sonst setzten wir die Attribute hart.
// Absatz-Einzuege muessen addiert werden und werden immer
// nur absatzweise gesetzt (fuer den ersten Absatz hier,
// die bisherigen Absatz-Abstaende holen (ohne die vom
// obersten Kontext, denn den veraendern wir ja gerade) ...
// und noch die aktuell gueltigen
// ... und die neuen Abstaende zu den alten addieren
// Hier werden nicht die aus dem Item genommen, sondern die
// extra gemerkten, weil die auch negativ sein koennen. Die
// Abfrage ueber das Item funktioniert aber trotzdem, denn
// fuer negative Werte wird das Item (mit Wert 0) auch
// eingefuegt.
// und die Werte fuer nachfolgende Absaetze merken
// das Attribut noch am aktuellen Absatz setzen
// ... und noch die Kontext-Information speichern
// es werden keine Attribute mit %-Angaben gesetzt
// es werden keine Attribute mit %-Angaben gesetzt
// es werden keine Attribute mit %-Angaben gesetzt
// das Frame-Attr ggf. in ein Char-Attr umwandeln
// Das Attribut setzen ...
// ... und noch die Kontext-Information speichern
// den zu dem Item gehoehrenden Tabellen-Eintrag ermitteln ...
// Das Attribut setzen ...
// ... und noch die Kontext-Information speichern
// auf zum naechsten Item
// das Attribut setzen
// und im Kontext merken
// PRE/Listing/XMP soll beim beenden des Kontexts beendet werden.
// Und die jetzt gueltigen Flags sollen wieder gesetzt werden.
// PRE/Listing/XMP wird auuserdem sofort beendet


62 / 69 | libreoffice-4.4.0.3/sw/source/filter/html/htmlforw.cxx
// Und die Position des ControlModel darin suchen
// wir sind in einer Tabelle oder einem Bereich
// ueber dem eine Form aufgespannt wurde
// die Form beenden wenn alle Controls ausgegeben wurden
// die neue Form
// Ueberspringen von Controls vor dem interesanten Bereich
// Check fuer einen einzelnen Node: da ist nur interessant, ob
// es zu dem Node ein Control gibt und zu welcher Form es gehoert
// wir klappern eine Tabelle/einen Bereich ab: hier interessiert uns:
// - ob es Controls mit unterschiedlichen Start-Nodes gibt
// - ob es eine Form gibt, fuer die nicht alle Controls in der
//   Tabelle/dem Bereich liegen
// die aktuelle Form in der Tabelle
// und der Start-Node eines Ctrls
// und die in ihr gefundenen Controls
// Wir befinden uns bereits in einer Form ...
// ... und das Control befindet sich auch darin ...
// ... aber es liegt in einer anderen Zelle:
// Dann muessen eir eine Form ueber der Tabelle
// aufmachen
// ... aber das Control liegt in einer anderen Zelle:
// Da tun wir so, als ob wir eine neue Form aufmachen
// und suchen weiter.
// Wir befinden uns noch in keiner Form:
// Da tun wir mal so, als ob wie wir die Form aufmachen.
// In der Tablle/dem Bereich sollte eine Form aufgemacht werden,
// die nicht vollstaendig in der Tabelle liegt. Dan muessen
// wie die Form jetzt ebenfalls oeffen.
// Es soll eine Form aufgemacht werden ...
// .. es ist aber noch eine Form offen: Das ist in
// jedem Fall eine Fehler, aber wir schliessen die alte
//!!!nWarn = 1; // Control wird falscher Form zugeordnet
// Ohne DrawModel kann es auch keine Controls geben. Dann darf man
// auch nicht per UNO auf das Dok zugreifen, weil sonst ein DrawModel
// angelegt wird.
// Inhalt der Form einruecken
// die neue Form wird geoeffnet
// Inhalt der Form einruecken
// hier folgen die Ausgabe-Routinen, dadurch sind die form::Forms gebuendelt:
// es muss ein Draw-Format sein
// Schauen, ob es ein SdrObject dafuer gibt
// wieviele sind sichtbar ??
// VALUE vim form aus Sicherheitsgruenden nicht exportieren
// kennt HTML nicht
// Wenn Zeichen-Objekte nicht absolut positioniert werden duerfen,
// das entsprechende Flag loeschen.
// der Inhalt von Select darf
// eingerueckt werden
// jede Option bekommt eine eigene Zeile
// das </SELECT> bekommt eine eigene Zeile
// In TextAreas duerfen keine zusaetzlichen Spaces oder LF exportiert
// Controls sind nicht absatz-gebunden, deshalb kein LF mehr ausgeben!
// Ermitteln, ob eine Format zu einem Control gehoert und wenn ja
// dessen Form zurueckgeben
//Doch kein FormObj
// Idee: die absatz- und zeichengebundenen Controls werden erst einmal
// eingesammelt. Dabei wird fuer jedes Control des Absatz-Position
// und VCForm in einem Array gemerkt.
// Ueber dieses Array laesst sich dann feststellen, wo form::Forms geoeffnet
// und geschlossen werden muessen.
// die absatz-gebundenen Controls einsammeln
// und jetzt die in einem zeichengebundenen Rahmen


263 / 515 | libreoffice-4.4.0.3/sw/source/filter/html/htmlatr.cxx
// eventuell muss erst mal eine Liste aufgemacht werden
// entsprechend dem Level-Unterschied schreiben!
// fuer die Formate muesste eine einzige Ausgabe-Funktion genuegen !
/*
 * Formate wie folgt ausgeben:
 * - fuer Formate, fuer die es entsprechende HTML-Tags gibt wird das
 *   Tag ausgegeben
 * - fuer alle anderen wird ein Absatz-Tag <P> ausgegeben und bUserFmt
 *   gesetzt
 * - Wenn eine Absatz-Ausrichtung am uebergebenen Item-Set des Nodes
 *   oder im Item-Set des Format gesetzt ist, wird ein ALIGN=xxx ausgegeben,
 *   sofern HTML es zulaesst
 * - in jedem Fall wird harte Attributierung als STYLE-Option geschrieben.
 *   Wenn bUserFmt nicht gesetzt ist, wird nur der uebergebene Item-Set
 *   betrachtet. Sonst werden auch Attribute des Formats ausgegeben.
 */
// auszugendens End-Token
// harte Attributierung
// in einer Aufzaehlungs-Liste;
// ein </P> darf zusaetzlich ausgegeben werden
// ein </P> soll ausgegeben werden
// Vergleichs-Format
// Es ist eine HTML-Tag-Vorlage oder die Vorlage ist von einer
// solchen abgeleitet
// wenn keine Styles exportiert werden, muss evtl. zusaetlich
// harte Attributierung geschrieben werden
// fuer HTML-Tag-Vorlagen die Unterscheide zum Original
// sonst die zur HTML-Tag-Vorlage des Originals oder des
// aktuellen Doks, wenn die nicht verfuegbar ist
// Nicht von einer HTML-Tag-Vorlage abgeleitete Absatz-Vorlagen
// muessen als harte Attributierung relativ zur Textkoerper-Volage
// exportiert werden. Fuer Nicht-Styles-Export sollte die der
// HTML-Vorlage als Referenz dienen
// wenn Unterschiede zu einer anderen Vorlage geschrieben werden
// sollen ist harte Attributierung noetig. Fuer Vorlagen, die
// nicht von HTML-Tag-Vorlagen abgeleitet sind, gilt das immer
// einen leeren Item-Set gleich loeschen, das spart speater
// Arbeit
// Ggf. noch ein DropCap-Attribut uebernehmen
// Die diversen default-Abstaende aus der Vorlage oder der
// Vergleischs-Vorlage merken
// Wir sind in einer Liste?
// Der aktuelle Absatz ist numeriert
// das aktuelle Token ist <P>
// ein <P> darf zusaetzlich ausgegeben werden
// kein End-Tag ausgeben
// kein ALIGN=... moeglich
// kein STYLE=... moeglich
// Die auszugebende Bullet-Grafik
// Sind wir in einer Aufzaehlungs- oder Numerierungliste?
// ist der aktuelle Absatz numeriert?
// nur veruebergehend!!!
// Jetzt holen wir das Token und ggf. die Klasse
// Jetzt wird festgelegt, was aufgrund des Tokens so moeglich ist
// Token fuer Tag-Wechsel
// nur ein LF ausgeben?
// Es ist eine HTML-Tag-Vorlage oder die Vorlage ist von einer
// solchen abgeleitet
// alle Vorlagen, die nicht einem HTML-Tag entsprechen oder von
// diesem abgeleitet sind, werden als <P> exportiert
// Falls noetig, die harte Attributierung der Vorlage uebernehmen
// und noch die harte Attributierung des Absatzes dazunehmen
// den unteren Absatz-Abstand brauchen wir noch
// nur einen Zeilen-Umbruch (ohne Einrueckung) am Absatz-Anfang
// ausgeben
// kein End-Tag ausgeben
// soll ein ALIGN=... geschrieben werden?
// Unteren Absatz-Abstand beachten ? (nie im letzen Absatz von
// Wenn Styles exportiert werden, wird aus eingerueckten Absaetzen
// eine Definitions-Liste
// Statt eines DD muessen wir hier auch ein DT der Ebene
// darueber nehmen
// Absaetze ohne unteren Abstand als DT exportieren
// ggf. eine Aufzaehlung- oder Numerierungsliste beginnen
// Die Defaults aus der Vorlage merken, denn sie muessen nicht
// exportiert werden
// In Numerierungs-Listen keinen Ertzeilen-Einzug ausgeben.
// ein einzelnes LI hat keinen Abstand
// ein einzelnes DD hat auch keinen Abstand
// Wenn im letzten Absatz einer Tabelle der
// untere Absatz-Abstand veraendert wird, vertut sich
// Netscape total. Deshalb exportieren wir hier erstmal
// nichts, indem wir den Abstand aus dem Absatz als Default
// Absatz-Tag in neue Zeile
// das ist jetzt unser neues Token
// ggf ein List-Item aufmachen
// fuer BLOCKQUOTE, ADDRESS und DD wird noch ein Absatz-Token
// ausgegeben, wenn,
// - keine Styles geschrieben werden, und
// - ein untere Abstand oder eine Absatz-Ausrichtung existiert
// Ein <P> wird nur geschrieben, wenn
// - wir in keiner OL/UL/DL sind, oder
// - der Absatz einer OL/UL nicht numeriert ist, oder
// - keine Styles exportiert werden und
//      - ein unterer Abstand oder
//      - eine Absatz-Ausrichtung existiert, ode
// - Styles exportiert werden und,
//      - die Textkoerper-Vorlage geaendert wurde, oder
//      - ein Benutzer-Format exportiert wird, oder
//      - Absatz-Attribute existieren
// jetzt werden Optionen ausgegeben
// ggf. Ausrichtung ausgeben.
// und nun ggf. noch die STYLE-Option
// Soll ein </P> geschrieben wenrden
// wenn kein End-Tag geschrieben werden soll, es loeschen
// die Defaults zuruecksetzen
// wenn es kein Token gibt haben wir auch nichts auszugeben
// Auch in PRE muss eine Bullet-Liste beendet werden
// fuer BLOCKQUOTE, ADDRESS und DD wird ggf noch ein
// Absatz-Token ausgegeben, wenn
// - keine Styles geschrieben werden, und
// - ein untere Abstand existiert
// ggf. eine Aufzaehlung- oder Numerierungsliste beenden
// nach Anfangs-Psoitionen sortierte Liste
// nach End-Psotionen sortierte Liste
// die HTML-Vorlage (oder 0)
// die Default-Vordergrund-Farbe
// werden Styles exportiert
// die Position eines Items in der Start-/Ende-Liste suchen
// Eine SttEndPos in die Start- und Ende-Listen eintragen bzw. aus
// ihnen loeschen, wobei die Ende-Position bekannt ist
// die "Art" es Attributs ermitteln
// Existiert ein bestimmtes On-Tag-Item
// Existiert ein Item zum ausschalten eines Attributs, das genauso
// exportiert wird wie das uebergebene Item im gleichen Bereich?
// das Ende eines gesplitteten Items anpassen
// Ein Attribut in die Listen eintragen und ggf. aufteilen
// Ein bereits vorhandenes Attribut aufteilen
// Ein Attribut einfuegen
// In der Start-Liste das Attribut hinter allen vorher und an
// der gleichen Position gestarteten Attributen einfuegen
// die Position in der Ende-Liste wurde uebergeben
// jetzt Suchen wir es in der Start-Liste
// dieses uns alle folgenden Attribute beginnen spaeter
// das Attribut beginnt vor oder an der aktuellen Position
// und endet hinter ihr
// ein On-Tag-Attibut wurde gefunden
// dieses uns alle folgenden Attribute beginnen spaeter
// das Attribut beginnt vor oder an der aktuellen Position
// und endet hinter ihr
// Ein Off-Tag-Attibut wurde gefunden, das genauso
// exportiert wird, wie das aktuelle Item
// die End-Position entsprechend fixen
// das Item aus der End-Liste entfernen
// es wird von nun an als letztes an der entsprechenden Position
// jetzt noch die spaeter gestarteten Attribute anpassen
// das Test-Attribut und alle folgenden beginnen, nachdem das
// gesplittete Attribut endet
// das Test-Attribut beginnt, bevor das gesplittete Attribut
// endet und endet danach, muss also auch gesplittet werden
// das neue Ende setzen
// das Attribut aus der End-Liste entfernen
// es endet jetzt als erstes Attribut an der entsprechenden
// Position. Diese Position in der Ende-Liste kennen wir schon.
// den "Rest" des Attributs neu einfuegen
// das Test-Attribut endet, bevor das neue beginnt
// das Test-Attribut endet, bevor das neue endet. Das
// neue Attribut muss deshalb aufgesplittet werden
// das Test-Attribut (und alle folgenden) endet, bevor das neue
// ein Attribut muss noch eingefuegt werden
// erstmal muessen wir die alten Items anhand der Startliste suchen
// und die neuen Item-Bereiche festlegen
// dieses und alle nachfolgenden Attribute beginnen spaeter
// das Test Attribut endet im zu loeschenenden Bereich
// nur entsprechende On-Tag Attribute muessen beruecksichtigt
// der Start des neuen Attribut entspricht
// dem neuen Ende des Attribts
// das Test-Item beginnt erst hinter dem neuen
// Ende des Attribts und kann deshalb komplett
// ggf den zweiten Teil des gesplitteten Attribts einfuegen
// kein Bereich ?? dann nicht aufnehmen, wird nie wirksam !!
// das Attribut wird ausgegeben, wenn es nicht sowieso
// schon an ist
// wenn das entsprechne Attribut an ist, wird es gesplittet,
// Zusaetlich wird es aber als Style ausgegeben, wenn es nicht
// am ganzen Absatz gesetzt ist, weil es dann ja schon mit dem
// ABsatz-Tag ausgegeben wurde.
// das Attribut kann immer ausgegeben werden
// Das Attribut kann nur als CSS1 ausgegeben werden. Wenn
// es am Absatz gesetzt ist, wurde es schon mit dem
// Absatz-Tag ausgegeben. Einzige Ausnahme ist das
// Zeichen-Hintergrund-Attribut. Es muss immer wie ein
// das Zeichenvorlagen-Tag muss vor den harten
// Attributen ausgegeben werden
// Eine Vordergrund-Farbe als Absatz-Attribut wird nur
// exportiert, wenn sie nicht der Default-Farbe entspricht.
// Zumindest die Attribute der Zeichenvorlage uebernehmen
// die Edit-Engine-Attribute des Objekts als SW-Attribute holen
// und als Hints einsortieren. Wegen der Menge der Hints werden
// Styles hierbei nicht beruecksichtigt!
// die Attribute in der Start-Liste sind aufsteigend sortiert
// dieses und alle folgenden Attribute werden erst noch geoeffnet
// das Attribut ausgeben
// die Attribute in der End-Liste sind aufsteigend sortiert
// dieses und alle folgenden Attribute werden erst spaeter beendet
// Das Attribut wird vor der aktuellen Position beendet. Das
// darf nicht sein, aber wie koennen trotzdem damit umgehen
/* Ausgabe der Nodes */
// Besonderheit: leere Node und HR-Vorlage (horizontaler Strich)
//              nur ein <HR> ausgeben
// dann die absatz-gebundenen Grafiken/OLE-Objekte im Absatz
// MIB 8.7.97: Ein <PRE> spannen wir um die Linie auf. Dann stimmen
// zwar die Abstaende nicht, aber sonst bekommen wir einen leeren
// Absatz hinter dem <HR> und das ist noch unschoener.
// Alle an dem Node verankerten Rahmen ausgeben
// Absatz-Tag in eine neue Zeile
// Die leeren Nodes mit 2pt Font-Hoehe und der Stand-Vorlage, die
// vor Tabellen und Bereichen eingefuegt werden, nicht exportieren,
// Bookmarks oder absatzgebundene Grafiken aber schon.
// MIB 21.7.97: Ausserdem auch keine leeren Tabellen-Zellen exportieren.
// Der aktuelle Node ist leer und enthaelt Standard-Vorlage ...
// ... ausserdem ist die 2pt Schrift eingestellt ...
// ... und er steht vor einer Tabelle ohne einem Bereich
// Alle an dem Node verankerten Rahmen ausgeben
// eventuell eine Form oeffnen
// An dem Node "verankerte" Seitenegebunde Rahmen ausgeben
// An dem Node verankerte Rahmen ausgeben, die vor dem
// Absatz-Tag geschrieben werden sollen.
// gibt es harte Attribute, die als Optionen geschrieben werden muessen?
// jetzt das Tag des Absatzes ausgeben
// Wenn vor dem Absatz-Tag keine neue Zeile aufgemacht wurde, dann
// tun wir das jetzt
// dann die Bookmarks (inkl. End-Tag)
// jetzt ist noch mal eine gute Gelegenheit fuer ein LF, sofern es noch
// erlaubt ist
// Text, der aus einer Outline-Numerierung kommt ermitteln
// gibt es harte Attribute, die als Tags geschrieben werden muessen?
// Absatz-Attribute ausgeben, damit der Text die Attribute des
// Theoretisch muesste man hier die Zeichen-Vorlage der Numerierung
// beachten. Da man die ueber die UI nicht setzen kann, ignorieren
// wir sie erstmal.
// erstmal den Start berichtigen. D.h. wird nur ein Teil vom Satz
// ausgegeben, so muessen auch da die Attribute stimmen!!
// Ok, es gibt vorher Attribute, die ausgegeben werden muessen
// leere Hints am Anfang nicht beachten, oder ??
// Attribut in die Liste aufnehemen
// aber nicht ausgeben, das erfolgt spaeter !!
// dann gebe mal alle gesammelten Attribute von der String-Pos aus
// Die an der aktuellen Position verankerten Rahmen ausgeben
// Hints mit Ende einsortieren, wenn sie keinen
// leeren Bereich aufspannen (Hints, die keinen
// Bereich aufspannen werden ignoriert
// Hints ohne-Ende werden als letztes ausgebeben
// keine 255 ausgeben
// Manche Draw-Formate koennen auch noch Attribute mitbringen
// Die an der letzten Position verankerten Rahmen ausgeben
// Wenn der letzte Absatz einer Tabellezelle leer ist und
// wir fuer den MS-IE exportieren, schreiben wir statt eines
// <BR> ein &nbsp;
// wenn ein LF nicht schon erlaubt ist wird es erlaubt, wenn der
// Absatz mit einem ' ' endet
// eventuell eine Form schliessen
// wo ein Twip ist sollte auch ein Pixel sein
// wenn gerade Hints geschrieben werden versuchen wir den Hint als
// CSS1-Attribut zu schreiben
// Font-Farbe nicht als Tag schreiben, wenn Styles normalen Tags
// vielleicht als CSS1-Attribut ?
// vielleicht als CSS1-Attribut ?
// Wegen Netscape schrieben wir hier STRIKE und nicht S raus!
// vielleicht als CSS1-Attribut ?
// vielleicht als CSS1-Attribut ?
// vielleicht als CSS1-Attribut ?
// Das ist jetzt unser Blink-Item. Blinkend wird eingeschaltet, indem man
// das Item auf true setzt!
// vielleicht als CSS1-Attribut ?
// ggf. ein noch offenes Attribut voruebergehend beenden
// jetzt das neue aufmachen
// und merken
// das eigene Attribut vom Stack holen
// es ist noch ein Attribut auf dem Stack, das wieder geoeffnet
/*
 * lege hier die Tabellen fuer die HTML-Funktions-Pointer auf
 * die Ausgabe-Funktionen an.
 * Es sind lokale Strukturen, die nur innerhalb der HTML-DLL
 * bekannt sein muessen.
 */
// Neu: nicht trennen
// Neu: nicht umbrechen
// Neu: Zeichenhintergrund
// neu:  Registerhaltigkeit


12 / 25 | libreoffice-4.4.0.3/sw/source/filter/html/htmlbas.cxx
// Den Inhalt des Script-Tags ignorieren
// Ausser StarBasic und unbenutzem JavaScript jedes Script oder den
// Fuer JavaScript und StarBasic noch ein Basic-Modul anlegen
// Das Basic entfernt natuerlich weiterhin keine SGML-Kommentare
// Hier merken wir und nur ein par Strings
// Leerzeilen am Anfang werden ignoriert
// Wir stehen hinter dem CR/LF der Zeile davor
// nur das DocumentBasic schreiben
// und jetzt alle StarBasic-Module und alle unbenutzen JavaSrript-Module
// ausgeben
//Wo ist das Modul?
// nicht einruecken!


56 / 77 | libreoffice-4.4.0.3/sw/source/filter/html/htmlnumreader.cxx
// Erstmal einen neuen Absatz aufmachen
// Die Numerierung-Ebene erhoehen
// ggf. ein Regelwerk anlegen
// das Format anpassen, falls es fuer den Level noch nicht
// geschehen ist!
// das default Numerierungsformat erstellen
// Wir setzen hier eine Zeichenvorlage, weil die UI das auch
// so macht. Dadurch wurd immer auch eine 9pt-Schrift
// eingestellt, was in Netscape nicht der Fall ist. Bisher hat
// das noch niemanden gestoert.
// das Bulletzeichen !!
// Wenn die Ebene schon mal benutzt wurde, muss der Start-Wert
// ggf. hart am Absatz gesetzt werden.
// und es ggf. durch die Optionen veraendern
// Eine Bullet-Liste mit Grafiken
// Die Grafik als Brush anlegen
// Die Groesse nur beachten, wenn Breite und Hoehe vorhanden sind
// Die Ausrichtung auch nur beachten, wenn eine Ausrichtung
// angegeben wurde
// Und noch die Grafik merken, um sie in den Absaetzen nicht
// einzufuegen
// den aktuellen Absatz erst einmal nicht numerieren
// einen neuen Kontext anlegen
// Der Der Default-Einzug wurde schon eingefuegt.
// die Attribute der neuen Vorlage setzen
// Ein neuer Absatz muss aufgemacht werden, wenn
// - der aktuelle nicht leer ist, also Text oder absatzgebundene Objekte
// - der aktuelle Absatz numeriert ist.
// den aktuellen Kontext vom Stack holen
// Keine Liste aufgrund eines Tokens beenden, wenn der Kontext
// nie angelgt wurde oder nicht beendet werden darf.
// wars der letze Level ?
// Die noch nicht angepassten Formate werden jetzt noch
// angepasst, damit es sich besser Editieren laesst.
// Beim letzen Append wurde das NumRule-Item und das
// NodeNum-Objekt mit kopiert. Beides muessen wir noch
// loeschen. Das ResetAttr loescht das NodeNum-Objekt mit!
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// einen neuen Absatz aufmachen
// In <LI> wird kein Abstand eingefuegt!
// das Bulletzeichen !!
// Wir tun so, als ob wir in einem Absatz sind. Dann wird
// beim naechsten Absatz wenigstens die Numerierung
// weggeschmissen, die nach dem naechsten AppendTxtNode uebernommen
// wird.
// die neue Vorlage setzen
// Laufbalkenanzeige aktualisieren
// einen neuen Absatz aufmachen
// Kontext zu dem Token suchen und vom Stack holen
// keine LI/LH ausserhalb der aktuellen Liste betrachten
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// und die bisherige Vorlage setzen
// NumRule invalidieren, weil sie durch ein EndAction bereits
// auf valid geschaltet worden sein kann.


6 / 15 | libreoffice-4.4.0.3/sw/source/filter/html/htmlftn.cxx
// Infos fuer die letzte Fussnote
// In Kopf- und Fusszeilen duerfen keine Fussnoten eingefuegt werden.
// Inhalt von <DIV> einruecken
// Inhalt von <DIV> einruecken
// Dok/Seite/Kap (D)
// Folgeseite


8 / 16 | libreoffice-4.4.0.3/sw/source/filter/html/htmlfld.cxx
// Autor und Absender werden nur als als variables Feld eingefuegt,
// wenn man das Dok selbst als letztes geaendert hat oder es noch
// niemend geandert hat und man das Dok erstellt hat. Sonst
// wird ein Fixed-Feld daraus gemacht.
// das aktuelle Textstueck an den Text anhaengen
// MIB 24.06.97: Wenn ein PostIt nach einen Space eingefuegt
// werden soll, fuegen wir es vor dem Space ein. Dann gibt es
// weniger Probleme beim Formatieren (bug #40483#)


383 / 584 | libreoffice-4.4.0.3/sw/source/filter/html/swhtml.cxx
// Aufruf fuer die allg. Reader-Schnittstelle
// Die HTML-Seitenvorlage setzen, wenn des kein HTML-Dokument ist,
// sonst ist sie schon gesetzt.
// damit keiner das Doc klaut!
// den Stream als Fehlernummer Transporter benutzen
// Die Font-Groessen 1-7 aus der INI-Datei lesen
// Waehrend des Imports in den HTML-Modus schalten, damit die
// richrigen Vorlagen angelegt werden
// Timer nur bei ganz normalen Dokumenten aufsetzen!
// nicht, synchron laden
// es ist ein Sprungziel vorgegeben.
// das ist nichts gueltiges!
// ansonsten ist das ein normaler (Book)Mark
// das DocumentDetected kann ggfs. die DocShells loeschen, darum nochmals
// Gelinkte Bereiche updaten
// keiner will mehr das Doc haben, also weg damit
// wurde der Import vom SFX abgebrochen?
// einen temporaeren Index anlegen, auf Pos 0 so wird er nicht bewegt!
// in ein Dokument einfuegen ?
// Laufbalken anzeigen
// Wenn der Import (vom SFX) abgebrochen wurde, wird ein Fehler
// gesetzt aber trotzdem noch weiter gemacht, damit vernuenftig
// aufgeraeumt wird.
// Die SwViewShell vom Dokument holen, merken und als aktuelle setzen.
// Beim ersten Aufruf erstmal returnen, Doc anzeigen
// und auf Timer Callback warten.
// An dieser Stelle wurde im CallParser gerade mal ein Zeichen
// gelesen und ein SaveState(0) gerufen.
// waehrend des einlesens kein OLE-Modified rufen
// Wenn der Import abgebrochen wird, kein Continue mehr rufen.
// Falls ein Pending-Stack existiert aber durch einen Aufruf
// von NextToken dafuer sorgen, dass der Pending-Stack noch
// beendet wird.
// Laufbalken wieder abschalten
// noch die letzten Attribute setzen
// ggf. ein noch vorhandes LF hinter dem letzen Absatz entfernen
// noch offene Nummerierungen beenden.
// Noch die erst verzoegert gesetzten Styles setzen
// den Start wieder korrigieren
// wenn der Cursor noch in dem Node steht, dann setze in an das Ende
// !!! sollte nicht moeglich sein, oder ??
// Zeichen Attribute beibehalten!
// es fehlen noch ein paar Image-Map zuordungen.
// vielleicht sind die Image-Maps ja jetzt da?
// jetzt noch den letzten ueberfluessigen Absatz loeschen
// nun noch das SplitNode vom Anfang aufheben
// dann gabs am Ende kein <P>,
// als zum naechsten Node
// eigentlich muss hier ein JoinNext erfolgen, aber alle Cursor
// usw. sind im pTxtNode angemeldet, so dass der bestehen
// bleiben MUSS.
// Absatz in Zeichen-Attribute umwandeln, aus dem Prev die
// Absatzattribute und die Vorlage uebernehmen!
// sollte der Parser der Letzte sein, der das Doc haelt, dann braucht
// man hier auch nichts mehr tun, Doc wird gleich zerstoert!
// Wenn zu Beginn des Continue keine Shell vorhanden war,
// kann trotzdem mitlerweile eine angelegt worden sein.
// In dieses Fall stimmt das bWasUndo-Flag nicht und
// wir muessen das Undo noch anschalten.
// Wenn die Dokuemnt-SwViewShell noch existiert und eine Action
// offen ist (muss bei Abbruch nicht sein), die Action beenden,
// uns von der Shell abmelden und schliesslich die alte Shell
// wieder rekonstruieren.
// ansonsten sind wir fertig!
// Durch das DocumentDetected wurde im allgemeinen eine
// SwViewShell angelegt. Es kann aber auch sein, dass sie
// erst spaeter angelegt wird, naemlich dann, wenn die UI
// Ein harter Zeilen-Umbruch am Ende muss immer entfernt werden.
// Einen zweiten ersetzen wir durch einen Absatz-Abstand.
// die harten Attribute an diesem Absatz werden nie mehr ungueltig
// Zeichen-Attribute aufspalten und ggf keine setzen, die ueber den
// ganzen Absatz gesetzt sind
// den besehrigen Teil setzen
// Wenn das Attribut den gesamten Absatz umspannt, werden
// alle auesseren Attribute nicht mehr beachtet. Deshalb
// darf es auch nicht in die Prev-Liste eines ausseren
// Attributs eingetragen werden, denn dieses wird ja
// erstmal nicht gesetzt. Das fuehrt zu verschiebenungen,
// Die Previous-Attribute muessen trotzdem gesetzt werden.
// Attrubute im Absatz davor sollte man jetzt setzen (wegen JavaScript)
// Hier wird
// - ein EndAction gerufen, damit formatiert wird
// - ein Reschedule gerufen,
// - die eiegen View-Shell wieder gesetzt
// - und Start-Action gerufen
// wurde der Import vom SFX abgebrochen?
// Die SwViewShell nochmal holen, denn sie koennte im Reschedule
// zerstoert wirden sein.
// ist der aktuelle Node nicht mehr sichtbar, dann benutzen wir
// eine groessere Schrittweite
// Hier wird
// - ein Reschedule gerufen, damit gescrollt werden kann
// - die eiegen View-Shell wieder gesetzt
// - ein Start/End-Action gerufen, wenn gescrollt wurde.
// Laufbalkenanzeige
// wurde der Import vom SFX abgebrochen?
// an allen CrsrEditShells die Cursor auf den Doc-Anfang setzen
//Schon gescrollt?, dann dafuer sorgen, dass die View sich nicht bewegt!
// bChkJumpMark ist nur gesetzt, wenn das Object auch gefunden wurde
// sollte der Parser der Letzte sein, der das Doc haelt, dann kann
// man hier abbrechen und einen Fehler setzen.
// Zechen-Attribute mit Ende moeglich frueh,
// also noch im aktuellen Absatz setzen (wegen JavaScript
// und diversen Chats). das darf man aber nicht fuer Attribute,
// die ueber den ganzen Absatz aufgspannt werden sollen, weil
// sie aus Absatzvorlgen stammen, die nicht gesetzt werden
// koennen. Weil die Attribute mit SETATTR_DONTREPLACE
// eingefuegt werden, sollte man sie auch anchtraeglich
// noch setzen koennen.
// Attribiute im Content-Bereich duerfen nicht gesetzt
// werden, wenn wir in einem Sonderbereich stehen, aber
// umgekekehrt schon.
// Das Attribute darf nicht in der liste der vorlaeufigen
// Absatz-Attribute stehen, weil es sonst geloescht wurde.
// dann also setzen
// ungueltige Attribute koennen gloescht werden
// durch die elende Loescherei von Nodes kann auch mal
// ein Index auf einen End-Node zeigen :-(
// wenn der End-Index auch auf den Node zeigt
// brauchen wir auch kein Attribut mehr zu setzen,
// es sei denn, es ist ein Text-Attribut.
// durch das Loeschen von BRs kann der Start-Index
// auch mal hinter das Ende des Textes zeigen
// durch das Loeschen von BRs kann der End-Index
// auch mal hinter das Ende des Textes zeigen
// wenn wir vor dem Einfuegen einer Tabelle stehen
// und das Attribut im aktuellen Node beendet wird,
// muessen wir es im Node davor beenden oder wegschmeissen,
// wenn es erst in dem Node beginnt
// wegen Numerierungen dieses Attribut direkt
// am Node setzen
// ggfs. ein Bookmark anspringen
// Font-Hoehen und -Farben- sowie Escapement-Attribute duerfen nicht
// zusammengefasst werden. Sie werden deshalb in einer Liste gespeichert,
// in der das zuletzt aufgespannte Attribut vorne steht und der Count
// immer 1 ist. Fuer alle anderen Attribute wird der Count einfach
// Der Listenkopf ist im Attribut gespeichert
// WIrd das zueltzt gestartete oder ein frueher gestartetes Attribut
// Es wird nicht das zuletzt gestartete Attribut beendet
// Dann suche wir das unmittelbar danach gestartete Attribut, das
// ja ebenfalls noch nicht beendet wurde (sonst stuende es nicht
// mehr in der Liste
// dann eine Cntntnt Position zurueck!
// ein Bereich ??
// keine offenen Attribute dieses Typs mehr da,
// dann koennen alle gesetzt werden, es sei denn
// sie haengen noch von einem anderen Attribut ab,
// dann werden sie dort angehaengt
// es gibt noch andere offene Attribute des Typs,
// daher muss das Setzen zurueckgestellt werden.
// das aktuelle Attribut wird deshalb hinten an die
// Previous-Liste des Nachfolgers angehaengt
// dann nicht einfuegen, sondern Loeschen. Durch das "tuerken" von
// Vorlagen durch harte Attributierung koennen sich auch mal andere
// leere Attribute in der Prev-Liste befinden, die dann trotzdem
// gesetzt werden muessen
// Die Previous-Attribute muessen trotzdem gesetzt werden.
// wenn das erste Attribut der Liste gesetzt wurde muss noch der
// Listenkopf korrigiert werden.
// Der Listenkopf ist im Attribut gespeichert
// Wird das zueltzt gestartete oder ein frueher gestartetes Attribut
// Es wird nicht das zuletzt gestartete Attribut beendet
// Dann suche wir das unmittelbar danach gestartete Attribut, das
// ja ebenfalls noch nicht beendet wurde (sonst stuende es nicht
// mehr in der Liste
// Die Previous-Attribute muessen trotzdem gesetzt werden.
// wenn das erste Attribut der Liste entfernt wurde muss noch der
// Listenkopf korrigiert werden.
// alle noch offenen Attribute beenden und hinter der Tabelle
// neu aufspannen
// keine Attribute setzen, wenn der PaM aus dem Content-Bereich
// herausgeschoben wurde.
// das Attribut muss vor der Liste gesetzt werden. Da wir
// das Original noch brauchen, weil Zeiger auf das Attribut
// noch in den Kontexten existieren, muessen wir es clonen.
// Die Next-Liste geht dabei verloren, aber die
// Previous-Liste bleibt erhalten
// Wenn das Attribut nicht gesetzt vor der Tabelle
// gesetzt werden muss, muessen der Previous-Attribute
// trotzdem gesetzt werden.
// den Start des Attributs neu setzen und die Verkettungen
// aufbrechen
// einen neuen Kontext anlegen
// einen neuen Kontext anlegen
// und ggf. die Attribute beenden
// einen neuen Kontext anlegen
// Stack-Unterlauf in Tabellen vermeiden
// tatsaechlich einzustellende Font-Hoehe
// HTML_BIGPRINT_ON oder HTML_SMALLPRINT_ON
// in Ueberschriften bestimmt die aktuelle Ueberschrift
// die Font-Hoehe und nicht BASEFONT
// wenn die Schriftgroesse in der Ueberschrift noch
// nicht veraendert ist, die aus der Vorlage nehmen
// in Ueberschriften wird die neue Fonthoehe wenn moeglich aus
// den Vorlagen geholt.
// falls nicht gefunden
// einen neuen Kontext anlegen
// Stack-Unterlauf in Tabellen vermeiden
// einen neuen Kontext anlegen
// Styles parsen (Class nicht beruecksichtigen. Das geht nur, solange
// keine der CSS1-Properties der Klasse hart formatiert werden muss!!!)
// und auf den Stack packen
// die aktuelle Vorlage oder deren Attribute setzen
// Laufbalkenanzeige
// leere Absaetze werden von Netscape uebersprungen, von uns jetzt auch
// wenn ein DD oder DT offen war, handelt es sich um eine
// implizite Def-Liste, die jetzt beendet werden muss
// den Kontext vom Stack holen. Er kann auch von einer implizit
// geoeffneten Definitionsliste kommen
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// und die bisherige Vorlage neu setzen
// einen neuen Absatz aufmachen
// die passende Vorlage suchen
// Styles parsen (zu Class siehe auch NewPara)
// udn auf den Stack packen
// und die Vorlage oder deren Attribute setzen
// Laufbalkenanzeige
// einen neuen Absatz aufmachen
// Kontext zu dem Token suchen und vom Stack holen
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// die bisherige Vorlage neu setzen
// einen neuen Absatz aufmachen
// Diese beiden Tags werden jetzt auf die PRE-Vorlage gemappt.
// Fuer dem Fall, dass ein CLASS angegeben ist, loeschen wir
// es damit wir nicht die CLASS der PRE-Vorlage bekommen.
// ADDRESS kann auf einen <P> ohne </P> folgen
// ... und in einem Kontext merken
// Styles parsen (zu Class siehe auch NewPara)
// die neue Vorlage setzen
// Laufbalkenanzeige aktualisieren
// den aktuellen Kontext vom Stack holen
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// und die bisherige Vorlage setzen
// einen neuen Absatz aufmachen
// ein Level mehr
// ... und in einem Kontext merken
// darin auch die Raender merken
// Die Einrueckung, die sich schon aus einem DL-ergibt, entspricht der
// eines DT auf dem aktuellen Level, und die entspricht der eines
// DD auf dem Level davor. Fue einen Level >=2 muss also ein DD-Abstand
// hinzugefuegt werden
// und den der DT-Vorlage des aktuellen Levels
// die Attribute der neuen Vorlage setzen
// ein Level weniger
// den aktuellen Kontext vom Stack holen
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// und Vorlage setzen
// festellen, ob das DD/DT in einer DL vorkommt
// wenn nicht, implizit eine neue DL aufmachen
// einen neuen Absatz aufmachen
// Kontext zu dem Token suchen und vom Stack holen
// keine DD/DT ausserhalb der aktuelen DefListe betrachten
// und auch nicht ausserhalb einer anderen Liste
// und noch Attribute beenden
// Absatz-Atts wegen JavaScript moeglichst schnell setzen
// und die bisherige Vorlage setzen
// bNoSurroundOnly:     Der Absatz enthaelt mindestens einen Rahmen
//                      ohne Umlauf
// bSurroundOnly:       Der Absatz enthaelt mindestens einen Rahmen
//                      mit Umlauf aber keinen ohne Umlauf
// sonst:               Der Absatz enthaelt irgendeinen Rahmen
// Ein Rahmen wurde gefunden, wenn
// - er absatzgebunden ist, und
// - im aktuellen Absatz verankert ist, und
//   - jeder absatzgebunene Rahmen zaehlt, oder
//   - (nur Rahmen oder umlauf zaehlen und ) der Rahmen keinen
//     Umlauf besitzt
// Wenn Rahmen mit Umlauf gesucht sind,
// auch keine mit Durchlauf beachten. Dabei handelt es
// sich (noch) um HIDDEN-Controls, und denen weicht man
// besser auch nicht aus.
// weitersuchen: Es koennten ja noch welche ohne
// Umlauf kommen ...
// die speziellen Methoden zum Einfuegen von Objecten
// die zu setzende Vorlage
// die Einzuege und
// Es gibt eine Vorlage, die zu setzen ist. Dann
// muss zunaechst einmal entschieden werden,
// ob die Vorlage auch gesetzt werden kann
// <TD><P CLASS=xxx> muss TD.xxx werden
// <HR> auch in <PRE> als Vorlage setzen, sonst kann man sie
// nicht mehr exportieren
// wenn jetzt eine andere Vorlage gesetzt werden soll als
// bisher, muss die bishere Vorlage durch harte Attributierung
// ersetzt werden
// die Attribute, die bisherige Vorlage setzt
// hart einfuegen
// aber die Attribute, die aktuelle Vorlage setzt
// entfernen, weil sie sonst spaeter ueberschrieben
// vielliecht gibt es ja eine Default-Vorlage?
// ggf. neue Absatz-Einzuege holen
// wenn im aktuellen Kontext eine neue Vorlage gesetzt werden soll,
// muessen deren Absatz-Abstaende noch in den Kontext eingetragen werden
// <TD><P CLASS=xxx> muss TD.xxx werden
// In Definitions-Listen enthalten die Abstaende auch die der
// vorhergehenden Level
// die Absatz-Abstaende addieren sich
// wenn gar keine Vorlage im Kontext gesetzt ist, Textkoerper nehmen
// bisherige harte Attributierung des Absatzes entfernen
// Die Vorlage setzen
// ggf. noch den Absatz-Einzug korrigieren
// und nun noch die Attribute setzen
// einen neuen Kontext anlegen
// die Vorlage setzen und im Kontext merken
// Styles parsen (zu Class siehe auch NewPara)
// Zeichen-Vorlagen werden in einem eigenen Stack gehalten und
// koennen nie durch Styles eingefuegt werden. Das Attribut ist deshalb
// auch gar nicht im CSS1-Which-Range enthalten
// und es ggf. durch die Optionen veraendern
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// einen leeren Textrahmen anlegen
// den Anker und die Ausrichtung setzen
// und noch die Groesse des Rahmens
// den Inhalt schuetzen
// der Rahmen anlegen
// Ggf Frames anlegen und auto-geb. Rahmen registrieren
// einen Absatz-Abstand setzen
// den unteren Absatz-Abstand des vorherigen Nodes aendern,
// wenn moeglich
// noch offene Absatz-Attribute setzen
// Wenn der Abstz davor kein Txtenode ist, dann wird jetzt
// ein leere Absatz angelegt, der eh schon eine Zeilenhoehe
// Abstand erzeugt.
// nicht am Abstand drehen!
// wenn der Absatz noch leer ist, einen Erstzeilen-Einzug
// setzen, sondern Sperrschrift ueber einem Space aufspannen
// <BR CLEAR=xxx> wird wie folgt behandelt:
// 1.) Es werden nur nur absatzgebundene Rahmen betrachtet, die
//     im aktuellen Absatz verankert sind.
// 2.) Fuer linksbuendig ausgerichtete Rahmen wird bei CLEAR=LEFT
//     oder ALL und auf rechtsbuendige ausgerichtete Rahmen bei
//     CLEAR=RIGHT oder ALL der Durchlauf wie folgt geaendert:
// 3.) Wenn der Absatz keinen Text enthaelt, bekommt der Rahmen keinen
//     Umlauf
// 4.) sonst erhaelt ein links ausgerichteter Rahmen eine rechten
//     "nur Anker" Umlauf und recht rechst ausg. Rahmen einen linken
//     "nur Anker" Umlauf.
// 5.) wenn in einem nicht-leeren Absatz der Umlauf eines Rahmens
//     geaendert wird, wird ein neuer Absatz aufgemacht
// 6.) Wenn von keinem Rahmen der Umlauf geaendert wird, wird ein
//     harter Zeilenumbruch eingefuegt
// die ID der Bookmark
// wurde ein CLEAR ausgefuehrt?
// dann holen wir mal die Optionen
// CLEAR wird nur fuer den aktuellen Absaetz unterstuetzt
// Anker ist nicht im Node
// Schleife ueber Fly-Frames
// kein Text-Node
// kein CLEAR
// wenn kein CLEAR ausgefuehrt werden sollte oder konnte, wird
// ein Zeilenumbruch eingef?gt
// wenn ein clear in einem nicht-leeren Absatz ausgefuehrt wurde,
// muss anschliessen ein neuer Absatz aufgemacht werden
// MIB 21.02.97: Eigentlich muesste man hier den unteren Absatz-
// Absatnd auf 0 drehen. Das geht aber bei sowas wie <BR ..><P>
// schief (>Netacpe). Deshalb lassen wir das erstmal.
// dann holen wir mal die Optionen
// 100%-Linien sind der default-Fall (keine Attrs neotig)
// ... und in einem Kontext merken
// die neue Vorlage setzen
// die harten Attribute an diesem Absatz werden nie mehr ungueltig
// Farbe und/oder Breite der Linie setzen
// Wenn wir in keiner Tabelle sind, wird die Breitenangabe durch
// Absatz-Einzuege "getuerkt". In einer Tabelle macht das wenig
// Sinn. Um zu Vermeiden, dass die Linie bei der Breitenberechnung
// beruecksichtigt wird, bekommt sie aber trotzdem entsprechendes
// Laenge und Ausrichtung der Linie ueber Absatz-Einzuege "tuerken"
// Bookmarks koennen nicht in Hyperlinks eingefueht werden
// den aktuellen Kontext vom Stack holen
// und im Absatz danach die dort aktuelle Vorlage setzen
// Hier wird es etwas tricky: Wir wissen genau, da? die Dok-Info
// nicht geaendert wurde. Deshalb genuegt es, auf Generator und
// auf refresh abzufragen, um noch nicht verarbeitete Token zu finden,
// denn das sind die einzigen, die die Dok-Info nicht modifizieren.
// das Attribut mit der alten Start-Position neu anlegen
// die Previous-Liste muss uebernommen werden, die Next-Liste nicht!
// den Anfang (und das Ende) neu setzen
// den Head korrigieren und die Verkettungen aufheben


43 / 167 | libreoffice-4.4.0.3/sw/source/filter/html/svxcss1.cxx
// die Funktionen zum Parsen einer CSS1-Property sind von folgendem Typ:
// Linien-Stil doppelt oder einfach?
// benannte Breite umrechnenen, wenn keine absolute gegeben ist
// wie man sieht passiert hier gar nichts
// und die naechste Rule vorbereiten
// den Selektor haben wir gespeichert. Loeschen toedlich!
// die Deklaration brauchen wir nicht mehr. Loeschen!
// Item-Ids auch initialisieren
// und etwas aufrauemen
// Alle nachfolgenden id's sammeln und mit einem
// (wobei nor noch normal | italic und oblique zulaessig sind
// der Wert kann zwei Werte enthalten!
// Auch hier hinterlaesst MS-IEs Parser seine Spuren
// erstmal pruefen, ob es ein Italic-Wert oder 'normal' ist
// fuer 'normal' muessen wir auch die case-map aussch.
// den naechsten Ausdruck holen
// da wir keine absolute Positionierung koennen,
// unterscheiden wir nur zwischen  0 und !0. Deshalb
// koennen Pixel auch wie alle anderen Einheiten behandelt
// die %-Angabe wird auf den enum abgebildet
// <scroll> kennen wir nicht
// transparent schlaegt alles
// repeat hat prio gegenueber einer Position
// Da "font" alle Werte zurecksetzt, fuer die nichts angegeben ist,
// tun wir das hier.
// eigentlich unnoetig, aber wir sind ja tollerant
// Vorschtshalber auch MS-IE
// der Wert kann zwei Werte enthalten! Und MS-IE auch Strings
// koennen wir nicht
// koennen wir nicht
// koennen wir nicht
// koennen wir nicht
// koennen wir nicht
// koennen wir nicht
// koennen wir nicht
// die Linien-Dicke
// benannte Linien-Dicke (und default)
// Ein Pixel wird zur Haarlinie (ist huebscher)
// die Linien-Dicke
// benannte Linien-Dicke (und default)
// wegen Netscape und IE
// die Zuordung Property zu parsender Funktion
// die Tabelle mit den Zuordnungen


79 / 134 | libreoffice-4.4.0.3/sw/source/filter/html/htmlflywriter.cxx
// Als Default irgendein Zeichen-Objekt
// Laufschrift
// Als Default ein Textrahmen
// spaltiger Rahmen
// Tabelle mit Unterschrft
// leerer Rahmen? Nur wenn kein Rahmen am
// Text- oder Start-Node verankert ist.
// leerer Rahmen
// Tabelle mit Ueberschrift
// Absatz-gebundene Rahmen werden nur dann vor den
// Absatz geschrieben, wenn der Absatz einen Abstand
// OutFlyFrm kan rekursiv aufgerufen werden. Deshalb muss man
// manchmal wieder von vorne anfangen, nachdem ein Fly ausgegeben
// wurde.
// suche nach dem Anfang der FlyFrames
// Erst entfernen ist wichtig, weil in tieferen
// Rekursionen evtl. weitere Eintraege oder das
// ganze Array geloscht werden koennte.
// nicht wirklich, nur raus
// aus der Schleife
// Hier wird's evtl rekursiv
// Fuer Nicht-Zeichenobekte eine Breite ausgeben
// Fuer spaltige Rahmen koennen wir auch noch den Hintergrund ausgeben.
// MIB 12.3.98: Ist es nicht schlauer, absatzgebundene
// Rahmen notfalls links auszurichten als sie
// zeichengebunden einzufuegen???
// geht nicht
// geht nicht
// geht nicht
// HSPACE und VSPACE
// Der Abstand muss bei der Groesse beruecksichtigt, wenn das entsprechende
// Flag gesetzt ist.
// ATT_VAR_SIZE/ATT_MIN_SIZE nur ausgeben, wenn ANYSIZE gesezut ist
// Groesse des Objekts Twips ohne Raender
// Umlauf fuer absatzgeb. Grafiken als <BR CLEAR=...> in den String
// schreiben
// hspace und vspace
// Der Abstand muss bei der Groesse beruecksichtigt, wenn das entsprechende
// Flag gesetzt ist.
// ATT_VAR_SIZE/ATT_MIN_SIZE nur ausgeben, wenn ANYSIZE gesezut ist
// Groesse des Objekts Twips ohne Raender
// Umlauf fuer absatzgeb. Grafiken als <BR CLEAR=...> in den String
// schreiben
// das URL-Attribut nur beruecksichtigen, wenn keine Image-Map
// uebergeben wurde
// Image-Map rausschreiben
// den Namen eindeutig machen
// sollte nicht passieren
// ggf. ein noch offenes Attribut voruebergehend beenden
// es ist noch ein Attribut auf dem Stack, das wieder geoeffnet
// Nicht const, weil GetTable spater mal nicht const ist
// Tabelle mit Ueberschrift
// als Multicol ausgeben
// die Anzahl der Spalten als COLS ausgeben
// die Gutter-Breite (Minimalwert) als GUTTER
// den Inhalt von Multicol einruecken;
// in einem Block damit rechtzeitig vor dem Ende der alte Zustand
// wieder hergestellt wird.
// den Inhalt von Multicol einruecken;
// wenn meoglich vor der Grafik einen Zeilen-Umbruch ausgeben
// als DIV ausgeben
// den Inhalt einruecken
// Am Start-Node verankerte Rahmen-gebundene Rahmen ausgeben
// in einem Block damit rechtzeitig vor dem Ende der alte Zustand
// wieder hergestellt wird.
// den Inhalt von Multicol einruecken;
// die Edit-Engine-Attribute des Objekts als SW-Attribute holen
// und als Hints einsortieren
// als Multicol ausgeben
// den Inhalt von Multicol einruecken;
// Einen Spacer fuer den Absatnd zusammenbasteln. Da durch das
// <DL> bzw. </DL> immer einer Absatz-Abstand entsteht, wird der
// in einem Block damit rechtzeitig vor dem Ende der alte Zustand
// wieder hergestellt wird. pFlyFmt braucht hier nicht gestzt zu
// werden, denn PageDesc-Attribute koennen hier nicht vorkommen
// den Inhalt von Multicol einruecken;
// Einfach nur in einem sortierten Array merken
// Hier brauchen wir Position und Name. Deshalb sortieren wir
// ein sal_uInt16 und ein String-Array selbst


13 / 24 | libreoffice-4.4.0.3/sw/source/filter/html/htmldrawwriter.cxx
// die Edit script::Engine-Attribute aus dem Objekt holen
// ueber die Edit script::Engine-Attribute iterieren und die Attribute
// in SW-Attrs wandeln bzw. default setzen
// wenn das Item nicht gesetzt ist nehmen wir ggf. das
// jetzt Clonen wir das Item mit der Which-Id des Writers
// Gibt es ueberhaupt auszugebenden Text
// Die Attribute des Objektd holen
// Die Hoehe ist bei MS eine Mindesthoehe, also geben wir auch die
// Mindestheoehe aus, wenn es sie gibt. Da eine Mindesthoehe MINFLY
// mit hoher Wahrscheinlichkeit vom Import kommt, wird sie nicht mit
// ausgegeben. Falsch machen kann man da nichst, denn jeder Font ist
// und nun noch ALIGN, HSPACE und VSPACE
// Was jetzt kommt ist das Gegenstueck zu SdrTextObjectt::SetText()


4 / 11 | libreoffice-4.4.0.3/sw/source/filter/html/htmlfly.hxx
// ACHTUNG: Die Werte dieses Enumgs gehen direkt in die
// der Rahmen
// seine Position im Content
// Ausgabe-Infos


93 / 129 | libreoffice-4.4.0.3/sw/source/filter/html/htmlgrin.cxx
// auf den Start-Node der 1. Section
// Die (leere) Image-Map des Nodes wird entweder
// durch die jetzt gefundene Image-Map ersetzt
// oder geloescht.
// die Grafikgroesse ist mitlerweile da oder dir
// Grafik muss nicht skaliert werden
// eine Map weniger suchen
// Wenn wir und in einem Container befinden wird die Verankerung
// des Containers uebernommen.
// Wenn die Ausrichtung anhand der CSS1-Optionen gesetzt werden kann
// werden die benutzt.
// Sonst wird die Ausrichtung entsprechend der normalen HTML-Optionen
// gesetzt.
// den Absatz-Einzug bestimmen
// Horizonale Ausrichtung und Umlauf bestimmen.
// Einen neuen Absatz aufmachen, wenn der aktuelle
// absatzgebundene Rahmen ohne Umlauf enthaelt.
// Wenn der Absatz nur Grafiken enthaelt, braucht er
// auch keinen unteren Absatz-Abstand. Da hier auch bei
// Verwendung von Styles kein Abstand enstehen soll, wird
// hier auch geweohnlich attributiert !!!
// Vertikale Ausrichtung und Verankerung bestimmen.
// automatisch verankerte Rahmen muessen noch um eine Position
// nach vorne verschoben werden.
// und jetzt auswerten
// erstmal nur als Pixelwerte merken!
// erstmal nur als Pixelwerte merken!
// Wenn wir in einer Numerierung stehen und der Absatz noch leer und
// nicht numeriert ist, handelt es sich vielleicht um die Grafik
// einer Bullet-Liste
// Rule invalisieren ist noetig, weil zwischem dem einlesen
// des LI und der Grafik ein EndAction gerufen worden sein kann.
// Die Vorlage novh mal setzen. Ist noetig, damit der
// Erstzeilen-Einzug stimmt.
// Umrandung setzen
// Ausrichtung setzen
// Abstaende setzen
// Sonstige CSS1-Attribute Setzen
// CSS1-Groesse auf "normale" Groesse umrechnen
// Twip-Size am Node setzen?
// Frame-Format nachtraeglich anpassen?
// Es fehlt die Breite oder die Hoehe
// Wenn die Grfik in einer Tabelle steht, wird sie gleich
// angefordert, damit sie eventuell schon da ist, bevor die
// Tabelle layoutet wird.
// Die Groesse des Rahmens wird nachtraeglich gesetzt
// eine %-Angabe
// Breite und Hoehe wurden angegeben und brauchen nicht gesetzt
// zu werden
// Da wir nur lokale Image-Maps kennen nehmen wireinfach alles
// hinter dem # als Namen
//wird kopieiert
//wird kopieiert
// es fehlen noch Image-Maps
// die Grafik muss beim SetTwipSize skaliert werden, wenn
// wir keine Groesse am Node gesetzt haben oder die Groesse
// nicht der Grafikgroesse entsprach.
// min. Werte einhalten !!
// ggfs. eine Grafik anspringen
// das Attribut wurde unmitellbar vor einer zeichengeb.
// Grafik eingefuegt, also verschieben wir es
// Wenn das Attribut auch ein Sprungziel ist, fuegen
// wir noch eine Bookmark vor der Grafik ein, weil das
// SwFmtURL kein Sprungziel ist.
// Ggf. Frames anlegen und Auto-gebundenen Rahmen registrieren
// Die Textfarbe wird an der Standard-Vorlage gesetzt
// Die Item fuer die Seitenvorlage vorbereiten (Hintergrund, Umrandung)
// Beim BrushItem muessen schon gesetzte werte erhalten bleiben!
// Hintergrundfarbe aus "BGCOLOR"
// Hintergrundgrafik aus "BACKGROUND"
// Ein par Attribute muessen an der Seitenvorlage gesetzt werden,
// und zwar die, die nicht vererbit werden
// alle noch uebrigen Optionen koennen an der Standard-Vorlage
// gesetzt werden und gelten dann automatisch als defaults
// den voherigen Link beenden, falls es einen gab
// und ggf. die Attribute beenden
// Sprungziele, die unseren ipmliziten Zielen entsprechen, schmeissen
// einen neuen Kontext anlegen
// Bei leerer URL das Directory nehmen
// das Default-Attribut setzen
// den Knoten duerfen wir nicht loeschen
// die noch offenen Attribute muessen
// beendet werden, bevor der Node
// geloescht wird, weil sonst der
// End-Index in die Botanik zeigt
// es wurden Felder in den Node eingefuegt, die muessen
// wir jetzt verschieben
// jetz muessen wir noch eventuell vorhandene Bookmarks verschieben
// In leeren Zellen stellen wir einen kleinen Font ein, damit die
// Zelle nicht hoeher wird als die Grafik bzw. so niedrig wie
// moeglich bleibt.
// Wenn die Zelle nur zeichengebundene Grafiken/Rahmen enthaelt
// stellen wir ebenfalls einen kleinen Font ein.


438 / 606 | libreoffice-4.4.0.3/sw/source/filter/html/htmltab.cxx
// wurde schon eine Zelle angelegt?
// Beenden einer Tab-Definition (MUSS fuer ALLE Tabs aufgerufen werden)
// die Tabellen brauchen wir nicht mehr
// der Inhalt ist in mehrere Zellen eingetragen, darf aber nur einmal
// Die Inhalte dieser Zelle mussen nich irgenwo anders verankert
// sein, weil sie nicht geloescht werden!!!
// Inhalt loeschen
// Hintergrundfarbe kopieren.
// die Zeile wird mit einer einzigen Zelle aufgefuellt, wenn
// bOneCell gesetzt ist. Das geht, nur fuer Zeilen, in die keine
// Zellen mehr eingefuegt werden!
// nBorder gibt die Breite der Umrandung an, wie sie in die
// Breitenberechnung in Netscape einfliesst. Wenn pOption->nBorder
// == USHRT_MAX, wurde keine BORDER-Option angegeben. Trotzdem fliesst
// eine 1 Pixel breite Umrandung in die Breitenberechnung mit ein.
// HACK: ein Pixel-breite Linien sollen zur Haarlinie werden, wenn
// wir mit doppelter Umrandung arbeiten
// pLayoutInfo wurde entweder bereits geloescht oder muss aber es
// in den Besitz der SwTable uebergegangen.
// Suchen des SwStartNodes der letzten belegten Vorgaengerbox
// immer die Vorgaenger-Zelle
// der Contents der letzten Zelle
// evtl. eine Zelle in der aktuellen Zeile
// sonst die letzte gefuellte Zelle der Zeile davor suchen
// Wenn die Gegenueberliegende Seite umrandet ist muessen
// wir zumindest den minimalen Abstand zum Inhalt
// beruecksichtigen. (Koennte man zusaetzlich auch an
// nCellPadding festmachen.)
// Wenn die Gegenueberliegende Seite umrandet ist muessen
// wir zumindest den minimalen Abstand zum Inhalt
// beruecksichtigen. (Koennte man zusaetzlich auch an
// nCellPadding festmachen.)
// die Hintergrundfarbe/-grafik bestimmen
// Wenn die Zelle ueber mehrere Zeilen geht muss ein evtl.
// an der Zeile gesetzter Hintergrund an die Zelle uebernommen
// Wenn es sich um eine Tabelle in der Tabelle handelt und
// die Zelle ueber die gesamte Heoehe der Tabelle geht muss
// ebenfalls der Hintergrund der Zeile uebernommen werden, weil
// die Line von der GC (zu Recht) wegoptimiert wird.
// die Breite der Box berechnen
// die Umrandung nur an Edit-Boxen setzen (bei der oberen und unteren
// Umrandung muss beruecks. werden, ob es sich um den ersten oder
// Leere Zeilen koennen zur Zeit nur dann ueber
// dicke Linien simuliert werden, wenn die Linie
// einfach ist.
// BorderDist nicht mehr Bestandteil einer Zelle mit fixer Breite
// wir setzen das Item nur, wenn es eine Umrandung gibt
// oder eine sheet::Border-Distanz vorgegeben ist. Fehlt letztere,
// dann gibt es eine Umrandung, und wir muessen die Distanz
// Format nur setzten, wenn es auch einen Value gibt oder die Box leer ist.
// wenn der StartNode dem StartNode der initial angelegten Box
// entspricht nehmen wir diese Box
// !!! kann noch vereinfacht werden
// An der Line eine Frabe zu setzen macht keinen Sinn, wenn sie
// die auesserste und gleichzeitig einzige Zeile einer Tabelle in
// der Tabelle ist.
// Ein an einer Tabellen in der Tabelle gesetzter Hintergrund
// wird an den Rows gesetzt. Das gilt auch fuer den Hintergrund
// der Zelle, in dem die Tabelle vorkommt.
// Tabellenhoehe einstellen. Da es sich um eine
// Mindesthoehe handelt, kann sie genauso wie in
// Netscape berechnet werden, also ohne Beruecksichtigung
// der tatsaechlichen Umrandungsbreite.
// sonst muessen wir die Hoehe aus dem Attribut entfernen
// und koennen uns das Format merken
// Die HTML-Tabellen-Zellen bilden genau eine Box.
// Dann muss hinter der Box gesplittet werden
// nur eine Inhalts-Section
// und die ist keine Tabelle
// und die ist eine Tabelle: dann bauen wir eine neue
// Box und fuegen die Zeilen der Tabelle in die Zeilen
// der Box ein
// mehrere Inhalts Sections: dann brauchen wir eine Box mit Zeilen
// normale Absaetze werden zu einer Box in einer Zeile
// Wenn es noch kein Line-Format ohne Hoehe gibt, koennen
// wir uns dieses her als soleches merken
// Tabellen werden direkt eingetragen
// Die Child-Tabelle muss einen Rahmen bekommen, wenn die umgebende
// Zelle einen Rand an der betreffenden Seite besitzt.
// Der obere bzw. untere Rand wird nur gesetzt, wenn die Tabelle
// ale erster bzw. letzter Absatz in der Zelle vorkommt. Ansonsten
// Fuer den linken/rechten Rand kann noch nicht entschieden werden,
// ob eine Umrandung der Tabelle noetig/moeglich ist, weil das davon
// abhaengt, ob "Filler"-Zellen eingefuegt werden. Hier werden deshalb
// erstmal nur Informationen gesammelt
// auch Filler bekommt eine Umrandung
// auch Filler bekommt eine Umrandung
// Die Child Tabelle darf keinen oberen oder linken Rahmen bekommen,
// wenn der bereits durch die umgebende Tabelle gesetzt ist.
// Sie darf jedoch immer einen oberen Rand bekommen, wenn die Tabelle
// nicht der erste Absatz in der Zelle ist.
// die Child-Tabelle muss die Farbe der Zelle erben, in der sie
// vorkommt, wenn sie keine eigene besitzt
// die ganze umgebende Tabelle ist eine Tabelle in der Tabelle
// und besteht nur aus einer Line, die bei der GC (zu Recht)
// wegoptimiert wird. Deshalb muss der Hintergrund der Line in
// diese Tabelle uebernommen werden.
// erstmal nur merken
// erstmal nur merken
// text::VertOrientation::TOP ist der default!
// benoetigte Spalten
// benoetigte Zeilen
// falls wir mehr Spalten benoetigen als wir zur Zeit haben,
// muessen wir in allen Zeilen noch Zellen hinzufuegen
// falls wir mehr Zeilen benoetigen als wir zur Zeit haben,
// muessen wir noch neue Zeilen hinzufuegen
// Testen, ob eine Ueberschneidung vorliegt und diese
// gegebenfalls beseitigen
// Der Inhalt reicht von einer weiter oben stehenden Zelle
// hier herein. Inhalt und Farbe der Zelle sind deshalb in
// jedem Fall noch dort verankert und koennen deshalb
// ueberschrieben werden bzw. von ProtectRowSpan geloescht
// (Inhalt) oder kopiert (Farbe) werden.
// Auch diese Inhalte sind in jedem Fall nich in der Zeile
// die Breite nur in die erste Zelle setzen!
// Ausserdem noch die Hoehe merken
// den Spaltenzaehler hinter die neuen Zellen setzen
// und die naechste freie Zelle suchen
// die vorhergende Section beenden, falls es schon eine Zeile gibt
// Anzahl benoetigter Zeilen;
// die naechste Zeile anlegen, falls sie nicht schon da ist
// den Spaltenzaehler wieder an den Anfang setzen
// und die naechste freie Zelle suchen
// leere Zellen bekommen einfach einen etwas dickeren unteren Rand!
// den COLSPAN aller leeren Zellen am Zeilenende so anpassen, dass
// eine Zelle daraus wird. Das kann man hier machen (und auf keinen
// Fall frueher), weill jetzt keine Zellen mehr in die Zeile eingefuegt
// benoetigte Spalten
// Die Anzahl der Tabellenzeilen richtet sich nur nach den
// <TR>-Elementen (d.h. nach nCurRow). Durch ROWSPAN aufgespannte
// Zeilen hinter Zeile nCurRow muessen wir deshalb loeschen
// und vor allem aber den ROWSPAN in den darueberliegenden Zeilen
// falls die Tabelle keine Spalte hat, muessen wir eine hinzufuegen
// falls die Tabelle keine Zeile hat, muessen wir eine hinzufuegen
// jetzt geht's richtig los ...
/* Wie werden Tabellen ausgerichtet?

erste Zeile: ohne Absatz-Einzuege
zweite Zeile: mit Absatz-Einzuegen

ALIGN=          LEFT            RIGHT           CENTER          -
-------------------------------------------------------------------------
xxx bei Tabellen mit WIDTH=nn% ist die Prozent-Angabe von Bedeutung:
xxx nn = 100        text::HoriOrientation::FULL       text::HoriOrientation::FULL       text::HoriOrientation::FULL       text::HoriOrientation::FULL %
xxx             text::HoriOrientation::NONE       text::HoriOrientation::NONE       text::HoriOrientation::NONE %     text::HoriOrientation::NONE %
xxx nn < 100        Rahmen F        Rahmen F        text::HoriOrientation::CENTER %   text::HoriOrientation::LEFT %
xxx             Rahmen F        Rahmen F        text::HoriOrientation::CENTER %   text::HoriOrientation::NONE %

bei Tabellen mit WIDTH=nn% ist die Prozent-Angabe von Bedeutung:
nn = 100        text::HoriOrientation::LEFT       text::HoriOrientation::RIGHT      text::HoriOrientation::CENTER %   text::HoriOrientation::LEFT %
                text::HoriOrientation::LEFT_AND   text::HoriOrientation::RIGHT      text::HoriOrientation::CENTER %   text::HoriOrientation::LEFT_AND %
nn < 100        Rahmen F        Rahmen F        text::HoriOrientation::CENTER %   text::HoriOrientation::LEFT %
                Rahmen F        Rahmen F        text::HoriOrientation::CENTER %   text::HoriOrientation::NONE %

sonst die berechnete Breite w
w = avail*      text::HoriOrientation::LEFT       text::HoriOrientation::RIGHT      text::HoriOrientation::CENTER     text::HoriOrientation::LEFT
                HORI_LEDT_AND   text::HoriOrientation::RIGHT      text::HoriOrientation::CENTER     text::HoriOrientation::LEFT_AND
w < avail       Rahmen L        Rahmen L        text::HoriOrientation::CENTER     text::HoriOrientation::LEFT
                Rahmen L        Rahmen L        text::HoriOrientation::CENTER     text::HoriOrientation::NONE

xxx *) wenn fuer die Tabelle keine Groesse angegeben wurde, wird immer
xxx   text::HoriOrientation::FULL genommen

*/
// Umrandung der Tabelle und aller in ihr enthaltenen berechnen
// Schritt 1: Die benoetigten Layout-Strukturen werden angelegt
// (inklusive Tabellen in Tabellen).
// Schritt 2: Die minimalen und maximalen Spaltenbreiten werden
// berechnet (inklusive Tabellen in Tabellen). Da wir noch keine
// Boxen haben, arabeiten wir noch auf den Start-Nodes.
// Schritt 3: Die tatsaechlichen Spaltenbreiten dieser Tabelle werden
// berechnet (nicht von Tabellen in Tabellen). Dies muss jetzt schon
// sein, damit wir entscheiden koennen ob Filler-Zellen benoetigt werden
// oder nicht (deshalb war auch Pass1 schon noetig).
// die linke und rechte Umrandung der Tabelle kann jetzt entgueltig
// linke Umrandung von auesserer Tabelle uebernehmen
// Umrandung nur setzen, wenn es erlaubt ist
// ggf. rechte Umrandung von auesserer Tabelle uebernehmen
// Fuer die Top-Table muss die Ausrichtung gesetzt werden
// Die Tabelle soll in einen Rahmen und ist auch schmaler
// als der verfuegbare Platz und nicht 100% breit.
// Dann kommt sie in einen Rahmen
// Die Tabelle passt entweder auf die Seite, soll aber in keinen
// Rahmen oder sie ist Breiter als die Seite und soll deshalb
// in keinen Rahmen
// in rechtsbuendigen Tabellen kann nicht auf den rechten
// Rand Ruecksicht genommen werden
// zentrierte Tabellen nehmen keine Ruecksicht auf Raender!
// linksbuendige Tabellen nehmen nur auf den linken Rand
// Ruecksicht
// das Tabellenform holen und anpassen
// die Default Line- und Box-Formate holen
// die erste Box merken und aus der ersten Zeile ausketten
// ggf. muessen fuer Tabellen in Tabellen "Filler"-Zellen eingefuegt
// dazu brauchen wir erstmal ein eine neue Table-Line in der Box
// Sicherstellen, dass wie ein Format ohne Hoehe erwischt haben
// sonst muessen wir die Hoehe aus dem Attribut entfernen
// und koennen uns das Format merken
// ggf. links eine Zelle einfuegen
// pPrevStNd ist der Vorgaenger-Start-Node der Tabelle. Den
// "Filler"-Node fuegen wir einfach dahinter ein ...
// jetzt die Tabelle bearbeiten
// und noch ggf. rechts eine Zelle einfuegen
// zum Schluss fuehren wir noch eine Garbage-Collection fuer die
// Hoehe einer einzeiligen Tabelle als Mindesthoehe der
// Zeile setzen. (War mal fixe Hoehe, aber das gibt manchmal
// Probleme (fix #34972#) und ist auch nicht Netscape 4.0
// Wenn eine Tabelle ohne Breitenangabe nicht links oder
// rechts umflossen werden soll, dann stacken wir sie
// in einem Rahmen mit 100%-Breite, damit ihre Groesse
// angepasst wird. Der Rahmen darf nicht angepasst werden.
// Links und rechts ausgerichtete Tabellen ohne Breite
// duerfen leider nicht in der Breite angepasst werden, denn
// sie wuerden nur schrumpfen aber nie wachsen.
// Nur Tabellen mit relativer Breite oder ohne Breite muessen
// angepasst werden.
// vorsicht, wenn Kommentare nicht uebrlesen werden!!!
// Bei Netscape entspricht ein Absatz-Ende zwei LFs
// (mit einem kommt man in die naechste Zeile, das
// zweite erzeugt eine Leerzeile) Diesen Abstand
// erreichen wie aber schon mit dem unteren
// Absatz-Abstand. Wenn nach den <BR> ein neuer
// Absatz aufgemacht wird, wird das Maximum des Abstands,
// der sich aus den BR und dem P ergibt genommen.
// Deshalb muessen wir 2 bzw. alle bei weniger
// als zweien loeschen
// Font-Stacks einfrieren
// Kontext-Stack einfrieren
// und noch ein par Zaehler retten
// Font-Stacks wieder auftauen
// und noch ein par Zaehler rekonstruieren
// und ein par Flags zuruecksetzen
// Liste aller Inhalte
// der aktuelle Inhalt oder 0
// Absatz-Index eines </NOBR>
// Zeichen-Index eines </NOBR>
// nur fuer Netscape
// nur fuer Netscape
// keine %-Angaben beruecksichtigen
// Leere BGCOLOR bei <TABLE>, <TR> und <TD>/<TH> wie Netscape
// ignorieren, bei allen anderen Tags *wirklich* nicht.
// einen neuen Kontext anlegen, aber das drawing::Alignment-Attribut
// nicht dort verankern, weil es noch ger keine Section gibt, in der
// Die Attribute muessen schon beim Auefrauemen des Kontext-Stacks
// entfernt worden sein, sonst ist etwas schiefgelaufen. Das
// Checken wir mal eben ...
// MIB 8.1.98: Wenn ausserhalb einer Zelle Attribute geoeffnet
// wurden stehen diese noch in der Attribut-Tabelle und werden erst
// ganz zum Schluss durch die CleanContext-Aufrufe in BuildTable
// geloescht. Damit es in diesem Fall keine Asserts gibt findet dann
// keine Ueberpruefung statt. Erkennen tut man diesen Fall an
// nContextStAttrMin: Der gemerkte Wert nContextStAttrMinSave ist der
// Wert, den nContextStAttrMin beim Start der Tabelle hatte. Und
// der aktuelle Wert von nContextStAttrMin entspricht der Anzahl der
// Kontexte, die beim Start der Zelle vorgefunden wurden. Sind beide
// Werte unterschiedlich, wurden ausserhalb der Zelle Kontexte
// angelegt und wir ueberpruefen nichts.
// jetzt muessen wir noch die Zelle an der aktuellen Position einfuegen
// <NOBR> wurde nicht beendet
// <NOBR> wurde unmittelbar vor dem Zellen-Ende beendet
// Zwischem dem </NOBR> und dem Zellen-Ende gibt es nur
// ein Blank oder einen Zeilenumbruch.
// eine neue Section anlegen, der PaM steht dann darin
// 1. Absatz auf nicht numeriert setzen
// Attributierungs-Anfang neu setzen
// <TH> bzw. <TD> wurde bereits gelesen
// die Tabelle besitzt noch keinen Inhalt, d.h. die eigentliche
// Tabelle muss erst noch angelegt werden
// Den linken/rechten Absatzeinzug ermitteln
// die aktuelle Position an die wir irgendwann zurueckkehren
// Wenn die Tabelle links oder rechts ausgerivchtet ist,
// oder in einen Rahmen soll, dann kommt sie auch in einen
// solchen.
// Entweder kommt die Tabelle in keinen Rahmen und befindet
// sich in keinem Rahmen (wird also durch Zellen simuliert),
// oder es gibt bereits Inhalt an der entsprechenden Stelle.
// Wenn die Tabelle in einen Rahmen kommt, muss
// nur ein neuer Absatz aufgemacht werden, wenn
// der Absatz Rahmen ohne Umlauf enthaelt.
// Sonst muss ein neuer Absatz aufgemacht werden,
// wenn der Absatz nicht leer ist, oder Rahmen
// oder text::Bookmarks enthaelt.
// ja, 0, weil schon
// vom Tabellenende vorher
// was gesetzt sein kann.
// Der Absatz wird gleich hinter die Tabelle
// verschoben. Deshalb entfernen wir alle harten
// Absaetze bzw. ueberschriften beeenden
// die harten Attribute an diesem Absatz werden nie mehr ungueltig
// einen Tabellen Kontext anlegen
// alle noch offenen Attribute beenden und hinter der Tabelle
// neu aufspannen
// Wenn wir einen schon vorhandenen Absatz verwenden, duerfen
// in den keine PostIts eingefuegt werden, weil der Absatz
// ja hinter die Tabelle wandert. Sie werden deshalb in den
// ersten Absatz der Tabelle verschoben.
// Bei Tabellen in Tabellen duerfen ebenfalls keine PostIts
// in einen noch leeren Absatz eingefuegt werden, weil
// der sonat nicht geloescht wird.
// Aktuelle Numerierung retten und auschalten.
// Die Tabelle soll in einen Rahmen geschaufelt werden.
// eine SwTable mit einer Box anlegen und den PaM in den
// Inhalt der Box-Section bewegen (der Ausrichtungs-Parameter
// ist erstmal nur ein Dummy und wird spaeter noch richtig
// gesetzt)
// noch vorhandene PostIts in den ersten Absatz
// der Tabelle setzen
// noch offene Bereiche muessen noch entfernt werden
// dannach entfernen wir ein ggf. zu viel vorhandenen
// leeren Absatz, aber nur, wenn er schon vor dem
// entfernen von LFs leer war
// noch vorhandene PostIts an das Ende des jetzt
// aktuellen Absatzes schieben
// Den Kontext-Stack einfrieren, denn es koennen auch mal
// irgendwo ausserhalb von Zellen Attribute gesetzt werden.
// Darf nicht frueher passieren, weil eventuell noch im
// Stack gesucht wird!!!
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// Token nach <TABLE>
// NextToken direkt aufrufen (z.B. um den Inhalt von
// Floating-Frames oder Applets zu ignorieren)
// nur wenn eine neue Tabelle aufgemacht wird, aber
// nicht wenn nach einem Pending in der Tabelle
// weitergelesen wird!
// HACK: Eine Section fuer eine Tabelle anlegen, die
// in einen Rahmen kommt.
// Diese Schleife muss vorwartes sein, weil die
// erste Option immer gewinnt.
// Wenn im aktuellen Absatz Flys verankert sind,
// muss die neue Tabelle in einen Rahmen.
// in der Zelle kann sich ein Bereich befinden!
// nur wenn die Tabelle wirklich zu Ende ist!
// Wenn jetzt keine Tabelle kommt haben wir eine
// Jetzt haben wir keine Section mehr
// Da wir diese Sction nicht mehr loeschen
// koennen (sie koeente zur erster Box
// gehoeren), fuegen wir sie ein.
// Jetzt haben wir keine Section mehr
// HACK fuer MS: Steht das <NOBR> zu beginn der Zelle?
// Mit Kommentar-Feldern werden Spaces nicht mehr geloescht
// ausserdem wollen wir fuer einen Kommentar keine neue Zelle
// eine neue Section anlegen, der PaM steht dann darin
// keine Section fuer einen leeren String anlegen
// eine neue Section anlegen, der PaM steht dann darin
// Falls der Inhalt der Zelle leer war, muessen wir noch einen
// leeren Inhalt anlegen. Ausserdem legen wir einen leeren Inhalt
// an, wenn die Zelle mit einer Tabelle aufgehoert hat und keine
// COL-Tags hatte (sonst wurde sie wahrscheinlich von uns exportiert,
// und dann wollen wir natuerlich keinen zusaetzlichen Absatz haben).
// Alle noch offenen Kontexte beenden. Wir nehmen hier
// AttrMin, weil nContxtStMin evtl. veraendert wurde.
// Da es durch EndContext wieder restauriert wird, geht das.
// LFs am Absatz-Ende entfernen
// falls fuer die Zelle eine Ausrichtung gesetzt wurde, muessen
// Alle noch offenen Kontexte beenden
// auch eine Numerierung muss beendet werden
// wir stehen jetzt (wahrschenlich) vor <TH>, <TD>, <TR> oder </TABLE>
// <TR> wurde bereist gelesen
// Leere BGCOLOR bei <TABLE>, <TR> und <TD>/<TH> wie Netsc.
// ignorieren, bei allen anderen Tags *wirklich* nicht.
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// naechstes Token
// NextToken direkt aufrufen (z.B. um den Inhalt von
// Floating-Frames oder Applets zu ignorieren)
// wo keine Zelle anfing kann auch keine aufhoehren, oder?
// und die ganzen anderen Tokens haben hier auch nicht zu
// suchen und machen nur die Tabelle kaputt
// spaltige Rahmen koennen wir hier leider nicht einguegen
// keinen neuen Absatz aufmachen!
// keinen neuen Absatz aufmachen!
// eine Image-Map fuegt nichts ein, deshalb koennen wir sie
// problemlos auch ohne Zelle parsen
// wir stehen jetzt (wahrscheinlich) vor <TR> oder </TABLE>
// <THEAD>, <TBODY> bzw. <TFOOT> wurde bereits gelesen
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// naechstes Token
// NextToken direkt aufrufen (z.B. um den Inhalt von
// Floating-Frames oder Applets zu ignorieren)
// spaltige Rahmen koennen wir hier leider nicht einguegen
// keinen neuen Absatz aufmachen!
// keinen neuen Absatz aufmachen!
// Blank-Strings sind Folge von CR+LF und kein Text
// <COLGROUP> wurde bereits gelesen, wenn bReadOptions
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// naechstes Token
// NextToken direkt aufrufen (z.B. um den Inhalt von
// Floating-Frames oder Applets zu ignorieren)
// die Angaben in <COLGRP> sollen ignoriert werden, wenn
// spaltige Rahmen koennen wir hier leider nicht einguegen
// gueltige Numerierung
// und die Attribute
// Die aktuelle Numerierung wurde gerettet und muss nur
// noch beendet werden.
// Die alten Stack wiederherstellen
// Die alte Attribut-Tabelle wiederherstellen
// Die alte Numerierung wieder aufspannen
// <CAPTION> wurde bereits gelesen
// Eine Text-Section im Icons-Bereich als Container fuer die
// Ueberschrift anlegen und PaM dort reinstellen.
// Tabellen-Ueberschriften sind immer zentriert.
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// naechstes Token
// </CAPTION> wird laut DTD benoetigt
// Alle noch offenen Kontexte beenden
// LF am Absatz-Ende entfernen
// Beim spaeteren verschieben der Beschriftung vor oder hinter
// die Tabelle wird der letzte Absatz nicht mitverschoben.
// Deshalb muss sich am Ende der Section immer ein leerer
// LFs am Absatz-Ende entfernen
// falls fuer die Zelle eine Ausrichtung gesetzt wurde, muessen
// Stacks und Attribut-Tabelle wiederherstellen
// PaM wiederherstellen.
// Aufbau der Tabelle anstossen und die Tabelle ggf. in einen
// Rahmen packen. Wenn true zurueckgegeben wird muss noch ein
// Absatz eingefuegt werden!
// Existiert schon ein Layout, dann muss an dieser Tabelle die
// BoxFrames neu erzeugt werden.
// keine %-Anagben benutzen!!!
// BORDER und BORDER=BORDER wie BORDER=1 behandeln
// Leere BGCOLOR bei <TABLE>, <TR> und <TD>/<TH> wie Netscape
// ignorieren, bei allen anderen Tags *wirklich* nicht.
// Wenn BORDER=0 oder kein BORDER gegeben ist, daan darf es auch
// keine Umrandung geben
// ist beim ersten GetNextToken schon pending, muss bei
// wiederaufsetzen auf jedenfall neu gelesen werden!
// </TABLE> wird laut DTD benoetigt
// naechstes Token
// NextToken direkt aufrufen (z.B. um den Inhalt von
// Floating-Frames oder Applets zu ignorieren)
// Wenn noch keine Tabelle eingefuegt wurde,
// die naechste Tabelle lesen
// spaltige Rahmen koennen wir hier leider nicht einguegen
// keinen neuen Absatz aufmachen!
// keinen neuen Absatz aufmachen!
// Blank-Strings sind u. U. eine Folge von CR+LF und kein Text
// Die Tabelle wurde auch angelegt
// Tabellen-Struktur anpassen
// ausserhalb von Zellen begonnene Kontexte beenden
// muss vor(!) dem Umsetzten der Attribut Tabelle existieren,
// weil die aktuelle danach nicht mehr existiert
// Tabellen-Beschriftung setzen
// Der letzte Absatz der Section wird nie mitkopiert. Deshalb
// muss die Section mindestens zwei Absaetze enthalten.
// Start-Node und letzten Absatz nicht mitkopieren.
// Wenn die Caption vor der Tabelle eingefuegt wurde muss
// eine an der Tabelle gestzte Seitenvorlage noch in den
// ersten Absatz der Ueberschrift verschoben werden.
// Ausserdem muessen alle gemerkten Indizes, die auf den
// Tabellen-Node zeigen noch verschoben werden.
// Die Section wird jetzt nicht mehr gebraucht.
// SwTable aufbereiten
// oberen Absatz-Abstand einstellen
// ggfs. eine Tabelle anspringen
// Wenn Import abgebrochen wurde kein erneutes Show
// aufrufen, weil die SwViewShell schon geloescht wurde!
// Genuegt nicht. Auch im ACCEPTING_STATE darf
// kein Show aufgerufen werden, weil sonst waehrend des
// Reschedules der Parser zerstoert wird, wenn noch ein
// DataAvailable-Link kommt. Deshalb: Nur im WORKING-State.
// Es wurde gar keine Tabelle gelesen.
// Dann muss eine evtl gelesene Beschriftung noch geloescht werden.


19 / 25 | libreoffice-4.4.0.3/sw/source/filter/html/swcss1.hxx
// Dieser Header seiht zwar harmlos aus, included aber eben doch
// ganz unauffaellig das ein oder andere! Andererseits wird diese
// Klasse recht selten benoetigt. Deshalb ein eigener Header.
// die Vorlagen fuer DL anlegen
// Die Font-Hoehe fuer eine bestimmte Font-Groesse (0-6) ermitteln
// Die aktuelle Font-Liste holen (auch 0 ist erlaubt)
// das Zeichen-Format zu einem Token und einer ggf leeren Klasse
// ermitteln
// eine TextFmtColl zu einer Pool-Id ermitteln
// Die linke oder rechte Seiten-Vorlage holen. In Dokumenten mit nur
// einer Vorlage gibt es nur eine rechtee Seite.
// Ansonsten ist die rechte Seite die HTML-Poolvorlage und die linke
// eine Benutzter-Vorlage, die on-demand angelegt wird, wenn
// bCreate gesetzt ist.
// Attribute an der HTML-Seitenvorlage setzen (gesetzte Attribute
// werden aus dem Item-Set geloescht ). Wird fuer's BODY-Tag
// aufgerufen.
// Wird fuer @page aufgerufen.
// Fuellen eines DropCap-Attributs


53 / 78 | libreoffice-4.4.0.3/sw/source/filter/html/htmlplug.cxx
// absolulte Groessenangaben in Twip umrechnen
// die Breite bearbeiten
// Hoehe bearbeiten
// linken/rechten Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// oberen/unteren Rand setzen
// Ggf. den Erstzeilen-Einzug noch plaetten
// Die Optionen werden vorwaerts gelesen, weil die Plugins sie in
// dieser Reihenfolge erwarten. Trotzdem darf immer nur der erste
// Wert einer Option beruecksichtigt werden.
// Es werden alle Parameter an das Plugin weitergereicht
// Die Default-Werte umsetzen (ausser Hoehe/Breite, das macht schon
// Size (0,0) wird in SetFrmSize auf (MINFLY, MINFLY) umgebogen
// die URL aufbereiten
// das Plugin anlegen
// den Anker setzen
// und noch die Groesse des Rahmens
// und in das Dok einfuegen
// Namen am FrmFmt setzen
// Ggf Frames anlegen und auto-geb. Rahmen registrieren
// HIDDEN-Plugins sollen absatzgebunden bleiben. Da RegisterFlyFrm
// absatzgebundene Rahmen mit DUrchlauf in am Zeichen gebundene
// Rahmen umwandelt, muessen die Frames hier von Hand angelegt werden.
// Eine neue Command-List anlegen
// Es werden alle Parameter auch an das Applet weitergereicht
// den Anker und die Ausrichtung setzen
// und noch die Groesse des Rahmens
// und in das Dok einfuegen
// Ggf Frames anlegen und auto-geb. Rahmen registrieren
// Eine neue Command-List anlegen
// Es werden alle Parameter auch an das Applet weitergereicht
// den Anker und die Ausrichtung setzen
// und noch die Groesse des Rahmens
// und in das Dok einfuegen
// Ggf Frames anlegen und auto-geb. Rahmen registrieren
// Erstmal die Optionen f?r das Writer-Frame-Format holen
// und jetzt die fuer den SfxFrame
// den Anker und die Ausrichtung setzen
// und noch die Groesse des Rahmens
// und in das Dok einfuegen
// Ggf Frames anlegen und auto-geb. Rahmen registrieren
// wenn meoglich vor dem "Objekt" einen Zeilen-Umbruch ausgeben
// erstmal das Plug-spezifische
// Das Plugin ist HIDDEN
// oder das Applet-Spezifische
// oder das Flating-Frame spezifische
// fuer Applets die Parameter als eigene Tags ausgeben
// und ein </APPLET> schreiben
// Inhalt von Applet einruecken
// Inhalt von Applet einruecken
// fuer Plugins die Parameter als Optionen schreiben
// und fuer Floating-Frames einfach noch ein </IFRAME>
// ausgeben


41 / 334 | libreoffice-4.4.0.3/sw/source/filter/html/htmlflyt.cxx
// Textrahmen mit Tabelle
// Textrahmen mit Tabelle und Ueberschrift
// spaltiger Rahmen
// leerer Textreahmen
// sonstiger Textreahmen
// Laufschrift
// Netscape schaltet FORM bei Controls in abs.-pos. SPAN aus.
// sonstige Zeichen-Objekte
// Textrahmen mit Tabelle
// Textrahmen mit Tabelle und Ueberschrift
// spaltiger Rahmen
// leerer Textreahmen
// sonstiger Textreahmen
// Laufschrift (fuer Netscape 4 im Container, damit
// die LAufschrift an der richtigen Stelle erscheint
// hier koennte man einen Container draus machen (Import fehlt)
// sonstige Zeichen-Objekte
// Textrahmen mit Tabelle
// Textrahmen mit Tabelle und Ueberschrift
// spaltiger Rahmen
// leerer Textreahmen
// sonstiger Textreahmen
// Laufschrift
// hier koennte man einen Container draus machen (Import fehlt)
// sonstige Zeichen-Objekte
// Textrahmen mit Tabelle
// Textrahmen mit Tabelle und Ueberschrift
// spaltiger Rahmen
// leerer Textreahmen
// sonstiger Textreahmen
// Laufschrift
// Netscape schaltet FORM bei Controls in abs.-pos. SPAN aus.
// sonstige Zeichen-Objekte
// Textrahmen mit Tabelle
// Textrahmen mit Tabelle und Ueberschrift
// spaltiger Rahmen
// leerer Textreahmen
// sonstiger Textreahmen
// Laufschrift (kann immer als MARQUEE exportiert werden, weil
// der Inhalt an der richtigen Stelle erscheint
// sonstige Zeichen-Objekte


111 / 184 | libreoffice-4.4.0.3/sw/source/filter/html/swhtml.hxx
// ein par Sachen, die man oefter mal braucht
// Attribut ueber dem gesamten Absatz setzen
// ist das Attribut gueltig?
// Anzahl noch zu schliessender Attrs mit einem Wert
// noch zu schliessene Attrs mit unterschiedl. Werten
// bereits geschlossene aber noch nicht gesetze Attrs
// Beim Setzen von Attributen aus Vorlagen kann es passieren,
// dass Attribute doch nicht mehr gesetzt werden sollen. Die zu loeschen
// waere sehr aufwendig, da man nicht so genau weiss, wo sie eingekettet
// sind. Sie werden deshalb einfach invalidiert und erst beim naechsten
// Tabelle der Attribute: Hier ist die Reihenfolge wichtig: Die Attribute
// vorne in der Tabelle werden in EndAllAttrs auch zuerst gesetzt.
// Zeichen-Attribute
// Zeichen-Hintergrund
// keine Absatz-Abstand-Behandlung
// Abstand hart auf 0cm setzen
// Abstand hart auf 0.5cm setzen
// Abstand nicht setzen aber 0cm merken
// die in dem Kontext gestarteten Attribute
// die Klasse des Kontexts
// das Token, zu dem der Kontext gehoehrt
// eine in dem Kontext begonnene Vorlage oder 0
// ein veraenderter rechter Rand
// ein veraenderter Erstzeilen-Einzug
// linker/rechtr Rand, Einzug veraendert?
// nTxtFmtColl ist nur ein default
// Der Kontext spannt eine SwSection auf
// Oberhalb liegende Stack-Elemente entf.
// Inhalt des aktuellen Script-Blocks
// URL eines Scripts
// Inhalt des aktuellen Style-Sheets
// ein gestartetes unbekanntes Token
// Bit 15: Fontfarbe wurde gesetzt
// "geschlossene", noch nicht gesetzte Attr.
// vorlauefige Absatz-Attribute
// der aktuelle Attribut/Token-Kontext
// SwPosition duerfte doch reichen, oder ??
// SwViewShell, an der das StartAction
// gerufen wurde.
// die aktuelle "auesserste" Tabelle
// die Seitengroesse der HTML-Vorlage
// die Font-Hoehen 1-7
// Zeilennummer eines Script-Blocks
// Elemente im Font-Stack bei <Hn>
// Wie viele Image-Maps fehlen noch?
// Untergrenze fuer Attributierung
// Anzahl der Eintraege der akt. Listbox
// ein geoeffnetes Absatz-Element
// Ausrichtung des aktuellen Absatz
// War's mal ein HTML-Dokument?
// Dokument bzw. Shell wurden initialisiert
// Flag um doppeltes init durch Rekursion
// zu verhindern.
// die View wurde schon erzeugt (asynchron)
// Crsr wieder auf den Anfang setzen
// Wir sind in einen Floating Frame
// unbekannte/nicht unterstuetze Tokens beh.
// In Tabellen: NextToken in jedem Fall rufen
// Inhalt eines Scripts/Styles ignorieren.
// Ist der aktuelle Listbox-Eintrag selekt.
// naechstes LF in TextArea ignorieren?
// Groesse einer Laufschrift anpassen?
// obererer Absatz-Abstand wird benoetigt
// gibt es ueberhaupt ein StarBasic-Modul
// Wir sind in einem NOEMBED-Bereich
// springe ggfs. zu einem vorgegebenem Mark
// Breite eines Selects neu setzen?
// Breite eines Selects neu setzen?
// Attribute am Dok setzen
// Einen neuen Textknoten an PaM-Position anlegen
// Ein Attribut beginnen/beenden
// ppDepAttr gibt einen Attribut-Tabellen-Eintrag an, dessen Attribute
// gesetzt sein muessen, bevor das Attribut beendet werden darf
// Verwalten von Absatz-Vorlagen
// die Vorlagen auf dem Stack bzw. deren Attribute setzen
// Verwalten des Attribut-Kontexts
// den obersten/spezifizierten Kontext holen, aber nicht ausserhalb
// des Kontexts mit Token nLimit suchen. Wenn bRemove gesetzt ist,
// Behandlung von Tags auf Absatz-Ebene
// <P> und <H1> bis <H6>
// <ADDRESS>, <BLOCKQUOTE> und <PRE>
// <DIV> und <CENTER>
// Fly-Frames einfuegen/verlassen
// alle durch <DIV> aufgespannten Bereiche verlassen
// Behandluung von Listen
// Numerierungs <OL> und Aufzaehlungs-Listen <UL> mit <LI>
// Definitions-Listen <DL> mit <DD>, <DT>
// Behandlung von Tags auf Zeichen-Ebene
// Tags wie <B>, <I> etc behandeln, die ein bestimmtes Attribut
// an und ausschalten, oder die wie SPAN nur Attribute aus Styles holen
// Tags, die durch Zeichenvorlagen realisiert werden
// Einfuegen von Grafiken, Plugins und Applets
// Image-Maps suchen und mit Grafik-Nodes verbinden
// Verankerung eines Fly-Frames bestimmen und entsprechende Attribute
// in den Attrset setzen (htmlgrin.cxx)
// Frames anlegen und Auto-gebundene Rahmen registrieren
// Die Groesse des Fly-Frames an die Vorgaben und Gegebenheiten anpassen
// (nicht fuer Grafiken, deshalb htmlplug.cxx)
// die eigentlichen Einfuege-Methoden fuer <IMG>, <EMBED> und <APPLET>
// und <PARAM>
// CommandLine mit Applet verkn. (htmlplug.cxx)
// CommandLine mit Applet verkn. (htmlplug.cxx)
// <BODY>-Tag auswerten: Hintergrund-Grafiken und -Farben setzen (htmlgrin.cxx)
// Einfuegen von Links und Bookmarks (htmlgrin.cxx)
// <A>-Tag auswerten: einen Link bzw. eine Bookmark einfuegen
// eine Bookmark einfuegen
// sind im aktuellen Absatz Bookmarks vorhanden?
// Einfuegen von Script/Basic-Elementen
// das zueletzt gelsene Basic-Modul parsen (htmlbas.cxx)
// ein Event in die SFX-Konfiguation eintragen (htmlbas.cxx)
// ein Event an ein VC-Control anhaengen (htmlform.cxx)


55 / 199 | libreoffice-4.4.0.3/sw/source/filter/html/parcss1.cxx
// Loop-Check: Um Endlos-Schleifen zu vermeiden, wird in jeder
// Schalife geprueft, ob ein Fortschritt in der Eingabe-Position
// stattgefunden hat
// Wenn noch nichts gelesen wurde ist das wie WS
// Diese Funktion realisiert den in
// bzw. http://www.w3.orh/pub/WWW/TR/WD-css1-960220.html
// beschriebenen Scanner fuer CSS1. Es handelt sich um eine direkte
// Umsetzung der dort beschriebenen Lex-Grammatik
// Merken, ob davor White-Space gelesen wurde
// den naechsten Identifer scannen
// und schauen, ob wir ihn kennen
// Fehlerbehandlung: '@ident' und alles bis
// zu einem Semikolon der dem Ende des folgenden
// den naechsten Identifer scannen
// Fehlerbehandlung: '!' ignorieren, IDENT nicht
// Fehlerbehandlung: '!' ignorieren
// \... geht noch nicht!!!
// erstmal versuchen eine Hex-Zahl zu scannen
// wir haben eine hexadezimale Farbe gefunden
// sonst versuchen wir es mit einer Zahl
// erstmal die Zahl scannen
// und nun Schauen, ob es eine Einheit gibt
// den naechsten Identifer scannen
// Ist es eine Einheit?
// erstmal versuchen eine Hex-Zahl zu scannen
// wir haben eine hexadezimale Farbe gefunden
// sonst versuchen wir es mit einer Zahl
// den naechsten Identifer scannen
// Fehlerbehandlung: Zeichen ignorieren
// Dies folegenden Funktionen realisieren den in
// bzw. http://www.w3.orh/pub/WWW/TR/WD-css1-960220.html
// beschriebenen Parser fuer CSS1. Es handelt sich um eine direkte
// Umsetzung der dort beschriebenen Grammatik
// url ueberspringen wir ungeprueft
// Fehlerbehandlung: ueberlesen
// Fehlerbehandlung: ueberlesen
// Selektor verarbeiten
// Selektor verarbeiten
// expression verarbeiten
// expression verarbeiten
// das war jetzt ein Look-Ahead
// wir wissen nicht was kommt, also aufhoehren
// falls ein Selektor angelegt wurd, ihn speichern
// das Vorzeichen wird nur fuer numerische Werte (ausser PERCENTAGE)
// beruecksichtigt und wird auf nValue angewendet!
// hier sind wir sehr lax, was die Syntax angeht, sollte aber kein
// Problem sein
// sonst landet das auch im naechsten Ident
// falls ein Expression angelegt wurde, diesen speichern
// expression verarbeiten
// expression verarbeiten
// Selektor loeschen
// Deklaration loeschen
// etwas anderes als eine Farbe kann es nicht sein
// HACK fuer MS-IE: DIe Farbe kann auch in einem String stehen


4 / 458 | libreoffice-4.4.0.3/sw/source/filter/html/css1atr.cxx
// Neu: nicht trennen
// Neu: nicht umbrechen
// Neu: Zeichenhintergrund
// neu:  Registerhaltigkeit


3 / 6 | libreoffice-4.4.0.3/sw/source/filter/html/htmlfly.cxx
// Auto-gebundene Rahmen werden ein Zeichen weiter hinten
// ausgegeben, weil dann die Positionierung mit Netscape
// uebereinstimmt.


1 / 52 | libreoffice-4.4.0.3/sw/source/uibase/docvw/srcedtw.cxx
// kleine Toleranz


1 / 19 | libreoffice-4.4.0.3/sw/source/uibase/docvw/edtwin2.cxx
// dann aufheben


1 / 26 | libreoffice-4.4.0.3/sw/source/uibase/inc/labimg.hxx
// printer shaft


1 / 5 | libreoffice-4.4.0.3/sw/source/uibase/app/mainwn.cxx
//while rescheduling


1 / 186 | libreoffice-4.4.0.3/sw/source/uibase/utlui/content.cxx
// ist es ein Inhaltstyp?


1 / 9 | libreoffice-4.4.0.3/sw/source/uibase/uiview/scroll.cxx
// hide autmatically - automatisch versteckt - then show


1 / 253 | libreoffice-4.4.0.3/sw/source/uibase/dochdl/swdtflvr.cxx
// Einfuegen


2 / 25 | libreoffice-4.4.0.3/sw/source/ui/chrdlg/pardlg.cxx
// Seitenumbruch nur, wenn der Cursor im Body-Bereich und nicht in
// einer Tabelle steht


1 / 27 | libreoffice-4.4.0.3/sw/source/ui/misc/pgfnote.cxx
// Breite


1 / 73 | libreoffice-4.4.0.3/sw/source/ui/frmdlg/column.cxx
// set in ItemSet setzen


1 / 67 | libreoffice-4.4.0.3/sw/source/ui/dbui/dbinsdlg.cxx
// Daten als Tabelle einfuegen


1 / 13 | libreoffice-4.4.0.3/sw/source/ui/fldui/flddb.cxx
// Allgemeine initialisierung


1 / 85 | libreoffice-4.4.0.3/eventattacher/source/eventattacher.cxx
// Methoden von XEventAttacher


11020 / 507269
